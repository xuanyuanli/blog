# Claude Code Provider Manager GUI ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£

## 1. æ€»ä½“æ¶æ„è®¾è®¡

### 1.1 æ¶æ„é£æ ¼å’Œè®¾è®¡åŸåˆ™

**æ¶æ„é£æ ¼ï¼š**
- **æ¡Œé¢åº”ç”¨æ¶æ„**: Tauri + React æ··åˆæ¶æ„
- **åˆ†å±‚æ¶æ„**: å‰ç«¯ UI å±‚ã€ä¸šåŠ¡é€»è¾‘å±‚ã€æ•°æ®è®¿é—®å±‚ã€ç³»ç»Ÿé›†æˆå±‚
- **äº‹ä»¶é©±åŠ¨æ¶æ„**: åŸºäº Tauri çš„å‰åç«¯é€šä¿¡æœºåˆ¶
- **æ’ä»¶åŒ–æ¶æ„**: æ”¯æŒåŠŸèƒ½æ¨¡å—åŒ–æ‰©å±•

**è®¾è®¡åŸåˆ™ï¼š**
- **å•ä¸€èŒè´£**: æ¯ä¸ªæ¨¡å—è´Ÿè´£å•ä¸€åŠŸèƒ½é¢†åŸŸ
- **å¼€æ”¾å°é—­**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
- **ä¾èµ–å€’ç½®**: é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–æŠ½è±¡
- **æ¥å£éš”ç¦»**: ä½¿ç”¨å°è€Œä¸“çš„æ¥å£ï¼Œé¿å…æ¥å£æ±¡æŸ“
- **æœ€å°æƒé™**: ç³»ç»Ÿæƒé™å’Œæ•°æ®è®¿é—®éµå¾ªæœ€å°æƒé™åŸåˆ™

### 1.2 ç³»ç»Ÿåˆ†å±‚æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å±•ç¤ºå±‚ (Presentation Layer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  React ç»„ä»¶å±‚                                                    â”‚
â”‚  â”œâ”€ Layoutç»„ä»¶ (Header, Sidebar, StatusBar)                     â”‚
â”‚  â”œâ”€ é¡µé¢ç»„ä»¶ (Dashboard, ProviderManagement, Settings)         â”‚
â”‚  â”œâ”€ ä¸šåŠ¡ç»„ä»¶ (ProviderCard, ConfigForm, StatusIndicator)       â”‚
â”‚  â””â”€ åŸºç¡€ç»„ä»¶ (Button, Input, Modal, Dialog)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  React Hooks & Context                                          â”‚
â”‚  â”œâ”€ useProvider (æä¾›å•†ç®¡ç†)                                     â”‚
â”‚  â”œâ”€ useEnvironment (ç¯å¢ƒåˆ‡æ¢)                                    â”‚  
â”‚  â”œâ”€ useValidator (é…ç½®éªŒè¯)                                      â”‚
â”‚  â””â”€ useSettings (åº”ç”¨è®¾ç½®)                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      æœåŠ¡å±‚ (Service Layer)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‰ç«¯æœåŠ¡ (TypeScript)           â”‚  åç«¯æœåŠ¡ (Rust)                â”‚
â”‚  â”œâ”€ ProviderService             â”‚  â”œâ”€ ConfigManager               â”‚
â”‚  â”œâ”€ ValidationService           â”‚  â”œâ”€ EnvironmentManager          â”‚
â”‚  â”œâ”€ LauncherService             â”‚  â”œâ”€ SecurityManager             â”‚
â”‚  â””â”€ StorageService              â”‚  â””â”€ SystemIntegration           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     æ•°æ®è®¿é—®å±‚ (Data Access Layer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Tauri Commands                                                  â”‚
â”‚  â”œâ”€ é…ç½®æ–‡ä»¶æ“ä½œ (JSON/TOML)                                     â”‚
â”‚  â”œâ”€ ç¯å¢ƒå˜é‡ç®¡ç† (ç³»ç»ŸAPI)                                       â”‚
â”‚  â”œâ”€ åŠ å¯†å­˜å‚¨ (ç³»ç»ŸKeychain/Registry)                            â”‚
â”‚  â””â”€ è¿›ç¨‹ç®¡ç† (ç³»ç»Ÿè¿›ç¨‹API)                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç³»ç»Ÿé›†æˆå±‚ (System Integration)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ“ä½œç³»ç»ŸAPI                                                     â”‚
â”‚  â”œâ”€ æ–‡ä»¶ç³»ç»Ÿ (é…ç½®å­˜å‚¨)                                          â”‚
â”‚  â”œâ”€ å®‰å…¨API (Windows DPAPI, macOS Keychain, Linux SecretAPI)   â”‚
â”‚  â”œâ”€ è¿›ç¨‹ç®¡ç† (Claude Codeå¯åŠ¨)                                   â”‚
â”‚  â””â”€ ç³»ç»Ÿé€šçŸ¥ (æ‰˜ç›˜ã€é€šçŸ¥ä¸­å¿ƒ)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 æŠ€æœ¯æ ˆé€‰å‹ç†ç”±

**å‰ç«¯æŠ€æœ¯æ ˆï¼š**
- **React 18**: ç»„ä»¶åŒ–å¼€å‘ï¼Œç”Ÿæ€æˆç†Ÿï¼Œå¼€å‘æ•ˆç‡é«˜
- **TypeScript**: ç±»å‹å®‰å…¨ï¼Œä»£ç è´¨é‡ä¿éšœï¼ŒIDEæ”¯æŒå¥½
- **Tailwind CSS**: åŸå­åŒ–CSSï¼Œå¿«é€Ÿæ ·å¼å¼€å‘
- **React Router**: å•é¡µé¢åº”ç”¨è·¯ç”±ç®¡ç†
- **Lucide React**: è½»é‡çº§å›¾æ ‡åº“ï¼Œé£æ ¼ç»Ÿä¸€

**åç«¯æŠ€æœ¯æ ˆï¼š**
- **Tauri**: Ruståç«¯ï¼Œæ€§èƒ½ä¼˜å¼‚ï¼Œå®‰å…¨æ€§å¼ºï¼Œè·¨å¹³å°æ”¯æŒ
- **Rust**: å†…å­˜å®‰å…¨ï¼Œé›¶æˆæœ¬æŠ½è±¡ï¼Œé€‚åˆç³»ç»Ÿçº§å¼€å‘
- **serde**: åºåˆ—åŒ–/ååºåˆ—åŒ–ï¼ŒJSONé…ç½®å¤„ç†
- **tokio**: å¼‚æ­¥è¿è¡Œæ—¶ï¼Œå¤„ç†IOå¯†é›†å‹æ“ä½œ

**æ„å»ºå·¥å…·é“¾ï¼š**
- **Vite**: å¿«é€Ÿçš„å‰ç«¯æ„å»ºå·¥å…·ï¼ŒHMRæ”¯æŒ
- **TypeScript Compiler**: ç±»å‹æ£€æŸ¥å’Œç¼–è¯‘
- **ESLint**: ä»£ç è´¨é‡æ£€æŸ¥
- **Cargo**: RuståŒ…ç®¡ç†å’Œæ„å»º

## 2. å‰ç«¯æ¶æ„è®¾è®¡

### 2.1 React ç»„ä»¶æ¶æ„

**ç»„ä»¶å±‚æ¬¡ç»“æ„ï¼š**
```
App
â”œâ”€â”€ Providers
â”‚   â”œâ”€â”€ ThemeProvider (ä¸»é¢˜ç®¡ç†)
â”‚   â”œâ”€â”€ ConfigProvider (é…ç½®ä¸Šä¸‹æ–‡)
â”‚   â””â”€â”€ NotificationProvider (é€šçŸ¥ç®¡ç†)
â”œâ”€â”€ Layout
â”‚   â”œâ”€â”€ AppHeader
â”‚   â”‚   â”œâ”€â”€ TitleBar
â”‚   â”‚   â””â”€â”€ MenuBar
â”‚   â”œâ”€â”€ AppSidebar  
â”‚   â”‚   â”œâ”€â”€ NavItem
â”‚   â”‚   â””â”€â”€ StatusPanel
â”‚   â”œâ”€â”€ MainContent
â”‚   â”‚   â””â”€â”€ PageContainer
â”‚   â””â”€â”€ StatusBar
â”‚       â”œâ”€â”€ ConnectionStatus
â”‚       â”œâ”€â”€ ActiveProvider
â”‚       â””â”€â”€ VersionInfo
â”œâ”€â”€ Pages
â”‚   â”œâ”€â”€ Dashboard
â”‚   â”‚   â”œâ”€â”€ OverviewPanel
â”‚   â”‚   â”œâ”€â”€ QuickActions
â”‚   â”‚   â””â”€â”€ RecentActivity
â”‚   â”œâ”€â”€ ProviderManagement
â”‚   â”‚   â”œâ”€â”€ ProviderList
â”‚   â”‚   â”œâ”€â”€ ProviderCard
â”‚   â”‚   â””â”€â”€ ProviderForm
â”‚   â”œâ”€â”€ EnvironmentSettings
â”‚   â”‚   â”œâ”€â”€ ActiveConfig
â”‚   â”‚   â”œâ”€â”€ EnvironmentSwitch
â”‚   â”‚   â””â”€â”€ EnvVariableView
â”‚   â””â”€â”€ SystemSettings
â”‚       â”œâ”€â”€ GeneralSettings
â”‚       â”œâ”€â”€ SecuritySettings
â”‚       â””â”€â”€ AdvancedSettings
â”œâ”€â”€ Components
â”‚   â”œâ”€â”€ UI Components
â”‚   â”‚   â”œâ”€â”€ Button
â”‚   â”‚   â”œâ”€â”€ Input
â”‚   â”‚   â”œâ”€â”€ Select
â”‚   â”‚   â”œâ”€â”€ Modal
â”‚   â”‚   â””â”€â”€ Toast
â”‚   â”œâ”€â”€ Business Components
â”‚   â”‚   â”œâ”€â”€ ProviderCard
â”‚   â”‚   â”œâ”€â”€ ConfigForm
â”‚   â”‚   â”œâ”€â”€ ValidationStatus
â”‚   â”‚   â””â”€â”€ LaunchButton
â”‚   â””â”€â”€ Layout Components
â”‚       â”œâ”€â”€ Card
â”‚       â”œâ”€â”€ Panel
â”‚       â””â”€â”€ Section
â””â”€â”€ Modals
    â”œâ”€â”€ AddProviderModal
    â”œâ”€â”€ EditProviderModal
    â”œâ”€â”€ ConfirmDialog
    â””â”€â”€ SettingsModal
```

### 2.2 çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ

**Context + Hooks æ¨¡å¼ï¼š**

```typescript
// é…ç½®ç®¡ç†ä¸Šä¸‹æ–‡
interface ConfigContextType {
  providers: Provider[];
  activeProvider: Provider | null;
  settings: AppSettings;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  addProvider: (provider: Omit<Provider, 'id'>) => Promise<void>;
  updateProvider: (id: string, updates: Partial<Provider>) => Promise<void>;
  deleteProvider: (id: string) => Promise<void>;
  switchProvider: (id: string) => Promise<void>;
  validateProvider: (id: string) => Promise<ValidationResult>;
  updateSettings: (settings: Partial<AppSettings>) => Promise<void>;
}

// ä¸»è¦çš„ Context Providers
const ConfigProvider: React.FC<{ children: ReactNode }>;
const ThemeProvider: React.FC<{ children: ReactNode }>;
const NotificationProvider: React.FC<{ children: ReactNode }>;

// è‡ªå®šä¹‰ Hooks
const useConfig = () => useContext(ConfigContext);
const useTheme = () => useContext(ThemeContext);
const useNotification = () => useContext(NotificationContext);
```

**çŠ¶æ€ç®¡ç†å±‚çº§ï¼š**
1. **å…¨å±€çŠ¶æ€**: åº”ç”¨é…ç½®ã€ä¸»é¢˜ã€é€šçŸ¥
2. **é¡µé¢çŠ¶æ€**: è¡¨å•æ•°æ®ã€é¡µé¢ç‰¹å®šçŠ¶æ€
3. **ç»„ä»¶çŠ¶æ€**: UIçŠ¶æ€ã€ä¸´æ—¶æ•°æ®

### 2.3 è·¯ç”±è®¾è®¡

```typescript
// è·¯ç”±é…ç½®
const routes = [
  {
    path: '/',
    element: <Layout />,
    children: [
      { index: true, element: <Dashboard /> },
      { path: 'providers', element: <ProviderManagement /> },
      { path: 'environment', element: <EnvironmentSettings /> },
      { path: 'settings', element: <SystemSettings /> },
    ],
  },
];

// è·¯ç”±æƒé™æ§åˆ¶
const ProtectedRoute: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { isConfigured } = useConfig();
  
  if (!isConfigured) {
    return <Navigate to="/setup" replace />;
  }
  
  return <>{children}</>;
};
```

### 2.4 UI ç»„ä»¶è®¾è®¡æ¨¡å¼

**åŸå­åŒ–è®¾è®¡åŸåˆ™ï¼š**
- **åŸå­**: Button, Input, Icon, Badge
- **åˆ†å­**: SearchBox, FormField, StatusIndicator
- **æœ‰æœºä½“**: ProviderCard, ConfigForm, NavigationMenu
- **æ¨¡æ¿**: PageLayout, ModalLayout
- **é¡µé¢**: Dashboard, ProviderManagement

**ç»„ä»¶è§„èŒƒï¼š**
```typescript
// ç»„ä»¶æ¥å£è§„èŒƒ
interface BaseComponentProps {
  className?: string;
  testId?: string;
  children?: ReactNode;
}

interface ButtonProps extends BaseComponentProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  onClick?: () => void;
}

// æ ·å¼ç³»ç»Ÿ (Tailwind + CSS Modules)
const buttonVariants = {
  primary: 'bg-blue-600 hover:bg-blue-700 text-white',
  secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-900',
  danger: 'bg-red-600 hover:bg-red-700 text-white',
};
```

## 3. åç«¯æ¶æ„è®¾è®¡ï¼ˆTauriï¼‰

### 3.1 Rust åç«¯æ¨¡å—è®¾è®¡

**æ¨¡å—ç»“æ„ï¼š**
```
src-tauri/src/
â”œâ”€â”€ main.rs                 // åº”ç”¨ç¨‹åºå…¥å£
â”œâ”€â”€ lib.rs                  // åº“æ ¹æ¨¡å—
â”œâ”€â”€ commands/               // Tauri Commands
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ config.rs          // é…ç½®ç®¡ç†å‘½ä»¤
â”‚   â”œâ”€â”€ provider.rs        // æä¾›å•†ç®¡ç†å‘½ä»¤
â”‚   â”œâ”€â”€ environment.rs     // ç¯å¢ƒç®¡ç†å‘½ä»¤
â”‚   â”œâ”€â”€ validation.rs      // éªŒè¯å‘½ä»¤
â”‚   â””â”€â”€ launcher.rs        // å¯åŠ¨å™¨å‘½ä»¤
â”œâ”€â”€ services/              // æ ¸å¿ƒä¸šåŠ¡æœåŠ¡
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ config_service.rs  // é…ç½®æœåŠ¡
â”‚   â”œâ”€â”€ security_service.rs// å®‰å…¨æœåŠ¡  
â”‚   â”œâ”€â”€ env_service.rs     // ç¯å¢ƒæœåŠ¡
â”‚   â””â”€â”€ system_service.rs  // ç³»ç»Ÿé›†æˆæœåŠ¡
â”œâ”€â”€ models/                // æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ provider.rs        // æä¾›å•†æ¨¡å‹
â”‚   â”œâ”€â”€ config.rs          // é…ç½®æ¨¡å‹
â”‚   â””â”€â”€ settings.rs        // è®¾ç½®æ¨¡å‹
â”œâ”€â”€ utils/                 // å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ crypto.rs          // åŠ å¯†å·¥å…·
â”‚   â”œâ”€â”€ filesystem.rs      // æ–‡ä»¶ç³»ç»Ÿå·¥å…·
â”‚   â””â”€â”€ validation.rs      // éªŒè¯å·¥å…·
â””â”€â”€ errors/                // é”™è¯¯å®šä¹‰
    â”œâ”€â”€ mod.rs
    â””â”€â”€ app_error.rs       // åº”ç”¨é”™è¯¯ç±»å‹
```

### 3.2 API æ¥å£è®¾è®¡

**Tauri Commands æ¥å£ï¼š**

```rust
// é…ç½®ç®¡ç†å‘½ä»¤
#[tauri::command]
async fn load_config() -> Result<Configuration, AppError>;

#[tauri::command]  
async fn save_config(config: Configuration) -> Result<(), AppError>;

// æä¾›å•†ç®¡ç†å‘½ä»¤
#[tauri::command]
async fn add_provider(provider: CreateProviderRequest) -> Result<Provider, AppError>;

#[tauri::command]
async fn update_provider(id: String, updates: UpdateProviderRequest) -> Result<Provider, AppError>;

#[tauri::command]
async fn delete_provider(id: String) -> Result<(), AppError>;

#[tauri::command]
async fn get_providers() -> Result<Vec<Provider>, AppError>;

// ç¯å¢ƒç®¡ç†å‘½ä»¤
#[tauri::command]
async fn switch_environment(provider_id: String) -> Result<(), AppError>;

#[tauri::command]
async fn get_current_environment() -> Result<EnvironmentInfo, AppError>;

// éªŒè¯å‘½ä»¤
#[tauri::command]
async fn validate_provider(provider: Provider) -> Result<ValidationResult, AppError>;

#[tauri::command]
async fn test_connection(base_url: String, auth_token: String) -> Result<ConnectionTest, AppError>;

// å¯åŠ¨å™¨å‘½ä»¤
#[tauri::command]
async fn launch_claude_code(config: LaunchConfig) -> Result<ProcessInfo, AppError>;

#[tauri::command]
async fn get_process_status(pid: u32) -> Result<ProcessStatus, AppError>;
```

### 3.3 æ•°æ®æŒä¹…åŒ–æ–¹æ¡ˆ

**é…ç½®å­˜å‚¨ç­–ç•¥ï¼š**
```rust
// é…ç½®æ–‡ä»¶ç»“æ„
pub struct ConfigManager {
    config_dir: PathBuf,
    config_file: PathBuf,
    secure_storage: SecureStorage,
}

impl ConfigManager {
    pub fn new() -> Result<Self, AppError> {
        let config_dir = Self::get_config_dir()?;
        let config_file = config_dir.join("config.json");
        let secure_storage = SecureStorage::new()?;
        
        Ok(Self {
            config_dir,
            config_file,
            secure_storage,
        })
    }
    
    pub async fn load_config(&self) -> Result<Configuration, AppError> {
        // ä»é…ç½®æ–‡ä»¶åŠ è½½åŸºæœ¬é…ç½®
        let mut config: Configuration = if self.config_file.exists() {
            let content = fs::read_to_string(&self.config_file).await?;
            serde_json::from_str(&content)?
        } else {
            Configuration::default()
        };
        
        // ä»å®‰å…¨å­˜å‚¨åŠ è½½æ•æ„Ÿæ•°æ®
        for provider in &mut config.providers {
            provider.auth_token = self.secure_storage
                .get_token(&provider.id)
                .await?
                .unwrap_or_default();
        }
        
        Ok(config)
    }
}
```

**å®‰å…¨å­˜å‚¨å®ç°ï¼š**
```rust
// è·¨å¹³å°å®‰å…¨å­˜å‚¨
pub struct SecureStorage {
    #[cfg(windows)]
    windows_storage: WindowsSecureStorage,
    #[cfg(target_os = "macos")]
    macos_storage: MacOSSecureStorage,
    #[cfg(target_os = "linux")]
    linux_storage: LinuxSecureStorage,
}

impl SecureStorage {
    pub async fn store_token(&self, provider_id: &str, token: &str) -> Result<(), AppError> {
        #[cfg(windows)]
        return self.windows_storage.store_token(provider_id, token).await;
        
        #[cfg(target_os = "macos")]
        return self.macos_storage.store_token(provider_id, token).await;
        
        #[cfg(target_os = "linux")]
        return self.linux_storage.store_token(provider_id, token).await;
    }
    
    pub async fn get_token(&self, provider_id: &str) -> Result<Option<String>, AppError> {
        // å¹³å°ç‰¹å®šå®ç°...
    }
}
```

### 3.4 ç³»ç»Ÿé›†æˆæ¥å£

**ç¯å¢ƒå˜é‡ç®¡ç†ï¼š**
```rust
pub struct EnvironmentManager;

impl EnvironmentManager {
    pub fn set_claude_environment(provider: &Provider) -> Result<(), AppError> {
        std::env::set_var("ANTHROPIC_BASE_URL", &provider.base_url);
        std::env::set_var("ANTHROPIC_AUTH_TOKEN", &provider.auth_token);
        std::env::set_var("ANTHROPIC_MODEL", &provider.model);
        std::env::set_var("ANTHROPIC_SMALL_FAST_MODEL", &provider.small_fast_model);
        Ok(())
    }
    
    pub fn get_current_environment() -> EnvironmentInfo {
        EnvironmentInfo {
            base_url: std::env::var("ANTHROPIC_BASE_URL").ok(),
            model: std::env::var("ANTHROPIC_MODEL").ok(),
            small_fast_model: std::env::var("ANTHROPIC_SMALL_FAST_MODEL").ok(),
            // auth_token ä¸è¿”å›ï¼Œå®‰å…¨è€ƒè™‘
        }
    }
}
```

**è¿›ç¨‹ç®¡ç†ï¼š**
```rust
pub struct ProcessManager {
    active_processes: Arc<Mutex<HashMap<String, Child>>>,
}

impl ProcessManager {
    pub async fn launch_claude_code(&self, config: &LaunchConfig) -> Result<ProcessInfo, AppError> {
        let mut cmd = Command::new("claude-code");
        
        // è®¾ç½®å·¥ä½œç›®å½•
        if let Some(work_dir) = &config.working_directory {
            cmd.current_dir(work_dir);
        }
        
        // æ·»åŠ å¯åŠ¨å‚æ•°
        for arg in &config.args {
            cmd.arg(arg);
        }
        
        // å¯åŠ¨è¿›ç¨‹
        let child = cmd.spawn()?;
        let pid = child.id();
        
        // å­˜å‚¨è¿›ç¨‹å¼•ç”¨
        self.active_processes.lock().unwrap()
            .insert(config.session_id.clone(), child);
        
        Ok(ProcessInfo {
            pid,
            session_id: config.session_id.clone(),
            started_at: chrono::Utc::now(),
        })
    }
}
```

## 4. æ•°æ®æ¶æ„è®¾è®¡

### 4.1 æ•°æ®æ¨¡å‹å®šä¹‰

**æ ¸å¿ƒæ•°æ®æ¨¡å‹ï¼š**

```typescript
// TypeScript å‰ç«¯æ¨¡å‹
interface Provider {
  id: string;
  name: string;
  baseUrl: string;
  authToken: string;  // åœ¨å‰ç«¯å†…å­˜ä¸­ä¸´æ—¶å­˜å‚¨ï¼Œä¸æŒä¹…åŒ–
  model: string;
  smallFastModel: string;
  createdAt: Date;
  updatedAt: Date;
  isActive: boolean;
  isValid?: boolean;
  lastValidated?: Date;
  tags?: string[];
  description?: string;
}

interface Configuration {
  version: string;
  activeProviderId: string | null;
  providers: Provider[];
  settings: AppSettings;
  metadata: ConfigMetadata;
}

interface AppSettings {
  theme: 'light' | 'dark' | 'system';
  language: string;
  autoValidate: boolean;
  autoStart: boolean;
  startMinimized: boolean;
  closeToTray: boolean;
  claudeCodePath?: string;
  defaultWorkingDirectory?: string;
  startupArgs: string[];
  updateCheck: boolean;
  telemetry: boolean;
}

interface ValidationResult {
  isValid: boolean;
  connectionStatus: 'success' | 'timeout' | 'error';
  authStatus: 'success' | 'invalid' | 'expired';
  modelStatus: 'available' | 'unavailable' | 'unknown';
  errors: ValidationError[];
  warnings: ValidationWarning[];
  latency?: number;
}
```

**Rust åç«¯æ¨¡å‹ï¼š**
```rust
// Rust åç«¯å¯¹åº”æ¨¡å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Provider {
    pub id: String,
    pub name: String,
    pub base_url: String,
    // auth_token ä¸åœ¨é…ç½®æ–‡ä»¶ä¸­å­˜å‚¨
    pub model: String,
    pub small_fast_model: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub is_active: bool,
    pub tags: Option<Vec<String>>,
    pub description: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Configuration {
    pub version: String,
    pub active_provider_id: Option<String>,
    pub providers: Vec<Provider>,
    pub settings: AppSettings,
    pub metadata: ConfigMetadata,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecureProviderData {
    pub provider_id: String,
    pub auth_token: String,
    pub encrypted_at: chrono::DateTime<chrono::Utc>,
}
```

### 4.2 é…ç½®æ–‡ä»¶ç»“æ„

**ä¸»é…ç½®æ–‡ä»¶ (config.json)ï¼š**
```json
{
  "version": "1.0.0",
  "activeProviderId": "provider-001",
  "providers": [
    {
      "id": "provider-001",
      "name": "Claude Official",
      "baseUrl": "https://api.anthropic.com",
      "model": "claude-3-sonnet-20240229",
      "smallFastModel": "claude-3-haiku-20240307",
      "createdAt": "2024-01-15T10:30:00Z",
      "updatedAt": "2024-01-15T10:30:00Z",
      "isActive": true,
      "tags": ["official", "production"],
      "description": "å®˜æ–¹ Claude API"
    }
  ],
  "settings": {
    "theme": "system",
    "language": "zh-CN",
    "autoValidate": true,
    "autoStart": false,
    "startMinimized": false,
    "closeToTray": true,
    "startupArgs": [],
    "updateCheck": true,
    "telemetry": false
  },
  "metadata": {
    "configVersion": "1.0.0",
    "lastModified": "2024-01-15T10:30:00Z",
    "backupEnabled": true,
    "encryptionEnabled": true
  }
}
```

**å¤‡ä»½å’Œç‰ˆæœ¬ç®¡ç†ï¼š**
```
config/
â”œâ”€â”€ config.json              // å½“å‰é…ç½®
â”œâ”€â”€ config.backup.json       // è‡ªåŠ¨å¤‡ä»½
â”œâ”€â”€ config.v1.json          // ç‰ˆæœ¬å¤‡ä»½
â”œâ”€â”€ secure/                 // å®‰å…¨å­˜å‚¨ç›®å½•
â”‚   â””â”€â”€ tokens.encrypted    // åŠ å¯†çš„æ•æ„Ÿæ•°æ®
â””â”€â”€ logs/                   // æ—¥å¿—æ–‡ä»¶
    â”œâ”€â”€ app.log
    â””â”€â”€ security.log
```

### 4.3 åŠ å¯†å­˜å‚¨æ–¹æ¡ˆ

**å¹³å°ç‰¹å®šåŠ å¯†å®ç°ï¼š**

```rust
// Windows DPAPI å®ç°
#[cfg(windows)]
impl WindowsSecureStorage {
    pub async fn store_token(&self, provider_id: &str, token: &str) -> Result<(), AppError> {
        let data = format!("{}:{}", provider_id, token);
        let encrypted = dpapi::encrypt_data(data.as_bytes(), None, None)?;
        
        let key_path = format!("SOFTWARE\\ClaudeCodeProviderManager\\Tokens\\{}", provider_id);
        self.write_registry(&key_path, &encrypted)?;
        
        Ok(())
    }
}

// macOS Keychain å®ç°
#[cfg(target_os = "macos")]
impl MacOSSecureStorage {
    pub async fn store_token(&self, provider_id: &str, token: &str) -> Result<(), AppError> {
        let service = "claude-code-provider-manager";
        let account = provider_id;
        
        keychain::set_generic_password(service, account, token.as_bytes())?;
        
        Ok(())
    }
}

// Linux Secret Service å®ç°  
#[cfg(target_os = "linux")]
impl LinuxSecureStorage {
    pub async fn store_token(&self, provider_id: &str, token: &str) -> Result<(), AppError> {
        let connection = secret_service::SecretService::connect(
            secret_service::EncryptionType::Dh
        ).await?;
        
        let collection = connection.get_default_collection().await?;
        
        let attributes = vec![
            ("service", "claude-code-provider-manager"),
            ("provider_id", provider_id),
        ];
        
        collection.create_item(
            &format!("Claude Provider: {}", provider_id),
            attributes,
            token.as_bytes(),
            true, // replace existing
            "text/plain",
        ).await?;
        
        Ok(())
    }
}
```

### 4.4 æ•°æ®æµè®¾è®¡

**é…ç½®æ•°æ®æµï¼š**
```mermaid
graph TD
    A[ç”¨æˆ·æ“ä½œ] --> B[Reactç»„ä»¶]
    B --> C[è‡ªå®šä¹‰Hook]
    C --> D[Tauri Command]
    D --> E[RustæœåŠ¡å±‚]
    E --> F[æ•°æ®æŒä¹…åŒ–]
    F --> G[é…ç½®æ–‡ä»¶]
    F --> H[å®‰å…¨å­˜å‚¨]
    
    I[åº”ç”¨å¯åŠ¨] --> J[åŠ è½½é…ç½®]
    J --> K[è§£å¯†æ•æ„Ÿæ•°æ®]
    K --> L[åˆå¹¶é…ç½®]
    L --> M[æ›´æ–°å‰ç«¯çŠ¶æ€]
    
    N[ç¯å¢ƒåˆ‡æ¢] --> O[éªŒè¯é…ç½®]
    O --> P[è®¾ç½®ç¯å¢ƒå˜é‡]
    P --> Q[æ›´æ–°ç³»ç»ŸçŠ¶æ€]
    Q --> R[é€šçŸ¥å‰ç«¯æ›´æ–°]
```

## 5. å®‰å…¨æ¶æ„è®¾è®¡

### 5.1 æ•æ„Ÿæ•°æ®ä¿æŠ¤

**æ•°æ®åˆ†ç±»å’Œä¿æŠ¤ç­–ç•¥ï¼š**

```rust
// å®‰å…¨çº§åˆ«å®šä¹‰
#[derive(Debug, Clone)]
pub enum SecurityLevel {
    Public,      // å…¬å¼€æ•°æ®ï¼Œå¯ä»¥æ˜æ–‡å­˜å‚¨
    Internal,    // å†…éƒ¨æ•°æ®ï¼Œæœ¬åœ°åŠ å¯†å­˜å‚¨
    Confidential,// æœºå¯†æ•°æ®ï¼Œç³»ç»Ÿå®‰å…¨å­˜å‚¨
    Secret,      // ç§˜å¯†æ•°æ®ï¼Œæœ€é«˜çº§åˆ«ä¿æŠ¤
}

// æ•°æ®ä¿æŠ¤å®ç°
pub struct DataProtection {
    local_cipher: ChaCha20Poly1305,
    system_storage: SecureStorage,
}

impl DataProtection {
    pub fn protect_data(&self, data: &[u8], level: SecurityLevel) -> Result<Vec<u8>, AppError> {
        match level {
            SecurityLevel::Public => Ok(data.to_vec()),
            SecurityLevel::Internal => self.encrypt_local(data),
            SecurityLevel::Confidential | SecurityLevel::Secret => {
                self.store_system_secure(data)
            }
        }
    }
    
    fn encrypt_local(&self, data: &[u8]) -> Result<Vec<u8>, AppError> {
        let nonce = ChaCha20Poly1305::generate_nonce(&mut OsRng);
        let ciphertext = self.local_cipher.encrypt(&nonce, data)?;
        
        let mut result = Vec::new();
        result.extend_from_slice(&nonce);
        result.extend_from_slice(&ciphertext);
        
        Ok(result)
    }
}
```

### 5.2 åŠ å¯†å­˜å‚¨å®ç°

**å¤šå±‚åŠ å¯†ç­–ç•¥ï¼š**

```rust
pub struct EncryptionManager {
    // åº”ç”¨çº§åŠ å¯†ï¼ˆç”¨äºé…ç½®æ–‡ä»¶ï¼‰
    app_key: [u8; 32],
    // ç³»ç»Ÿçº§åŠ å¯†ï¼ˆç”¨äºæ•æ„Ÿä»¤ç‰Œï¼‰
    system_storage: SecureStorage,
}

impl EncryptionManager {
    pub fn new() -> Result<Self, AppError> {
        let app_key = Self::derive_app_key()?;
        let system_storage = SecureStorage::new()?;
        
        Ok(Self {
            app_key,
            system_storage,
        })
    }
    
    fn derive_app_key() -> Result<[u8; 32], AppError> {
        // ä½¿ç”¨è®¾å¤‡å”¯ä¸€æ ‡è¯†ç¬¦å’Œåº”ç”¨ä¿¡æ¯ç”Ÿæˆå¯†é’¥
        let device_id = Self::get_device_id()?;
        let app_info = "claude-code-provider-manager-v1";
        
        let mut hasher = Sha256::new();
        hasher.update(device_id.as_bytes());
        hasher.update(app_info.as_bytes());
        
        let hash = hasher.finalize();
        let mut key = [0u8; 32];
        key.copy_from_slice(&hash);
        
        Ok(key)
    }
    
    pub fn encrypt_config(&self, data: &str) -> Result<String, AppError> {
        let cipher = ChaCha20Poly1305::new(&self.app_key.into());
        let nonce = ChaCha20Poly1305::generate_nonce(&mut OsRng);
        
        let ciphertext = cipher.encrypt(&nonce, data.as_bytes())?;
        
        // Base64ç¼–ç å­˜å‚¨
        let mut result = Vec::new();
        result.extend_from_slice(&nonce);
        result.extend_from_slice(&ciphertext);
        
        Ok(base64::encode(result))
    }
    
    pub fn decrypt_config(&self, encrypted: &str) -> Result<String, AppError> {
        let data = base64::decode(encrypted)?;
        
        if data.len() < 12 {
            return Err(AppError::DecryptionError("Invalid data length".to_string()));
        }
        
        let (nonce_bytes, ciphertext) = data.split_at(12);
        let nonce = GenericArray::from_slice(nonce_bytes);
        
        let cipher = ChaCha20Poly1305::new(&self.app_key.into());
        let plaintext = cipher.decrypt(nonce, ciphertext)?;
        
        Ok(String::from_utf8(plaintext)?)
    }
}
```

### 5.3 æƒé™ç®¡ç†

**æœ€å°æƒé™åŸåˆ™å®ç°ï¼š**

```rust
pub struct PermissionManager {
    required_permissions: Vec<Permission>,
    granted_permissions: Vec<Permission>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Permission {
    ReadConfig,
    WriteConfig,
    AccessSecureStorage,
    ManageEnvironment,
    LaunchProcess,
    NetworkAccess,
    FileSystemAccess(PathBuf),
}

impl PermissionManager {
    pub fn check_permission(&self, permission: &Permission) -> Result<(), AppError> {
        if !self.granted_permissions.contains(permission) {
            return Err(AppError::PermissionDenied(format!("{:?}", permission)));
        }
        Ok(())
    }
    
    pub async fn request_permissions(&mut self) -> Result<(), AppError> {
        // è¯·æ±‚å¿…è¦çš„ç³»ç»Ÿæƒé™
        for permission in &self.required_permissions {
            match permission {
                Permission::AccessSecureStorage => {
                    self.request_secure_storage_access().await?;
                }
                Permission::LaunchProcess => {
                    self.request_process_launch_access().await?;
                }
                Permission::FileSystemAccess(path) => {
                    self.request_filesystem_access(path).await?;
                }
                _ => {} // å…¶ä»–æƒé™é»˜è®¤æˆäºˆ
            }
        }
        Ok(())
    }
}
```

### 5.4 å®‰å…¨é€šä¿¡

**APIé€šä¿¡å®‰å…¨ï¼š**

```rust
pub struct SecureApiClient {
    client: reqwest::Client,
    timeout: Duration,
}

impl SecureApiClient {
    pub fn new() -> Self {
        let client = reqwest::Client::builder()
            .timeout(Duration::from_secs(30))
            .danger_accept_invalid_certs(false) // å¼ºåˆ¶è¯ä¹¦éªŒè¯
            .https_only(true) // ä»…å…è®¸HTTPS
            .build()
            .expect("Failed to create HTTP client");
            
        Self {
            client,
            timeout: Duration::from_secs(30),
        }
    }
    
    pub async fn validate_connection(
        &self, 
        base_url: &str, 
        auth_token: &str
    ) -> Result<ValidationResult, AppError> {
        // æ„å»ºå®‰å…¨è¯·æ±‚å¤´
        let mut headers = reqwest::header::HeaderMap::new();
        headers.insert(
            "Authorization",
            format!("Bearer {}", auth_token).parse()?
        );
        headers.insert(
            "User-Agent",
            "Claude-Code-Provider-Manager/1.0".parse()?
        );
        
        // å‘é€æµ‹è¯•è¯·æ±‚
        let response = self
            .client
            .get(&format!("{}/v1/models", base_url))
            .headers(headers)
            .timeout(self.timeout)
            .send()
            .await?;
            
        let status = response.status();
        let latency = response.extensions()
            .get::<reqwest::ResponseTime>()
            .map(|rt| rt.elapsed())
            .unwrap_or_default();
            
        Ok(ValidationResult {
            is_valid: status.is_success(),
            connection_status: if status.is_success() { 
                "success" 
            } else { 
                "error" 
            }.to_string(),
            latency: Some(latency.as_millis() as u32),
            // ... å…¶ä»–å­—æ®µ
        })
    }
}
```

## 6. è·¨å¹³å°é€‚é…æ¶æ„

### 6.1 å¹³å°å·®å¼‚å¤„ç†

**å¹³å°ç‰¹å®šä»£ç ç»„ç»‡ï¼š**

```rust
// å¹³å°æŠ½è±¡å±‚
pub trait PlatformAdapter {
    fn get_config_dir(&self) -> Result<PathBuf, AppError>;
    fn get_secure_storage(&self) -> Result<Box<dyn SecureStorageBackend>, AppError>;
    fn setup_system_integration(&self) -> Result<(), AppError>;
    fn get_system_theme(&self) -> Result<SystemTheme, AppError>;
}

// Windows å®ç°
#[cfg(windows)]
pub struct WindowsPlatform;

#[cfg(windows)]
impl PlatformAdapter for WindowsPlatform {
    fn get_config_dir(&self) -> Result<PathBuf, AppError> {
        let appdata = std::env::var("APPDATA")?;
        Ok(PathBuf::from(appdata).join("ClaudeCodeProviderManager"))
    }
    
    fn setup_system_integration(&self) -> Result<(), AppError> {
        // Windows ç³»ç»Ÿæ‰˜ç›˜è®¾ç½®
        self.setup_system_tray()?;
        // Windows æ³¨å†Œè¡¨é›†æˆ
        self.setup_registry_integration()?;
        // Windows å¼€å§‹èœå•å¿«æ·æ–¹å¼
        self.create_start_menu_shortcut()?;
        Ok(())
    }
}

// macOS å®ç°  
#[cfg(target_os = "macos")]
pub struct MacOSPlatform;

#[cfg(target_os = "macos")]
impl PlatformAdapter for MacOSPlatform {
    fn get_config_dir(&self) -> Result<PathBuf, AppError> {
        let home = std::env::var("HOME")?;
        Ok(PathBuf::from(home)
            .join("Library")
            .join("Application Support")
            .join("ClaudeCodeProviderManager"))
    }
    
    fn setup_system_integration(&self) -> Result<(), AppError> {
        // macOS èœå•æ åº”ç”¨è®¾ç½®
        self.setup_menu_bar_app()?;
        // macOS Dock é›†æˆ
        self.setup_dock_integration()?;
        // macOS é€šçŸ¥ä¸­å¿ƒ
        self.setup_notification_center()?;
        Ok(())
    }
}

// Linux å®ç°
#[cfg(target_os = "linux")]  
pub struct LinuxPlatform;

#[cfg(target_os = "linux")]
impl PlatformAdapter for LinuxPlatform {
    fn get_config_dir(&self) -> Result<PathBuf, AppError> {
        if let Ok(xdg_config) = std::env::var("XDG_CONFIG_HOME") {
            Ok(PathBuf::from(xdg_config).join("claude-code-provider-manager"))
        } else {
            let home = std::env::var("HOME")?;
            Ok(PathBuf::from(home).join(".config").join("claude-code-provider-manager"))
        }
    }
    
    fn setup_system_integration(&self) -> Result<(), AppError> {
        // Linux ç³»ç»Ÿæ‰˜ç›˜ (æ”¯æŒå¤šç§æ¡Œé¢ç¯å¢ƒ)
        self.setup_system_tray_linux()?;
        // Linux .desktop æ–‡ä»¶
        self.create_desktop_entry()?;
        // Linux è‡ªå¯åŠ¨è®¾ç½®
        self.setup_autostart()?;
        Ok(())
    }
}
```

### 6.2 ç³»ç»Ÿé›†æˆæ–¹æ¡ˆ

**ç³»ç»Ÿæ‰˜ç›˜é›†æˆï¼š**

```rust
pub struct SystemTrayManager {
    platform: Box<dyn PlatformAdapter>,
    tray_icon: Option<TrayIcon>,
}

impl SystemTrayManager {
    pub fn new() -> Result<Self, AppError> {
        let platform = Self::get_platform_adapter()?;
        
        Ok(Self {
            platform,
            tray_icon: None,
        })
    }
    
    pub fn setup_tray(&mut self) -> Result<(), AppError> {
        let menu = self.create_tray_menu()?;
        
        let tray_icon = TrayIcon::builder()
            .with_icon(self.get_tray_icon()?)
            .with_tooltip("Claude Code Provider Manager")
            .with_menu(menu)
            .build()?;
            
        // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
        tray_icon.on_click(|_| {
            // æ˜¾ç¤º/éšè—ä¸»çª—å£
            WindowManager::toggle_main_window();
        });
        
        self.tray_icon = Some(tray_icon);
        Ok(())
    }
    
    fn create_tray_menu(&self) -> Result<Menu, AppError> {
        let menu = Menu::new()
            .add_item("æ˜¾ç¤ºç•Œé¢", "show_window")
            .add_separator()
            .add_submenu("å¿«é€Ÿåˆ‡æ¢", self.create_provider_submenu()?)
            .add_item("å¯åŠ¨ Claude Code", "launch_claude")
            .add_separator()
            .add_item("è®¾ç½®", "settings")
            .add_item("é€€å‡º", "quit");
            
        Ok(menu)
    }
}
```

**æ–‡ä»¶å…³è”å’Œåè®®å¤„ç†ï¼š**

```rust
pub struct ProtocolHandler;

impl ProtocolHandler {
    // æ³¨å†Œè‡ªå®šä¹‰åè®® claude-code-provider://
    pub fn register_protocol() -> Result<(), AppError> {
        #[cfg(windows)]
        self.register_windows_protocol()?;
        
        #[cfg(target_os = "macos")]
        self.register_macos_protocol()?;
        
        #[cfg(target_os = "linux")]
        self.register_linux_protocol()?;
        
        Ok(())
    }
    
    pub fn handle_protocol_url(&self, url: &str) -> Result<(), AppError> {
        // è§£æåè®®URL: claude-code-provider://switch/provider-id
        let parsed = url::Url::parse(url)?;
        
        match parsed.path() {
            "/switch" => {
                if let Some(provider_id) = parsed.query_pairs().find(|(k, _)| k == "id") {
                    self.switch_to_provider(&provider_id.1)?;
                }
            }
            "/launch" => {
                self.launch_claude_code()?;
            }
            _ => {
                return Err(AppError::InvalidProtocolUrl(url.to_string()));
            }
        }
        
        Ok(())
    }
}
```

### 6.3 æ‰“åŒ…åˆ†å‘ç­–ç•¥

**æ„å»ºé…ç½®ï¼š**

```toml
# Cargo.toml ä¸­çš„å¹³å°ç‰¹å®šé…ç½®
[package.metadata.bundle]
name = "Claude Code Provider Manager"
identifier = "com.claude.provider-manager"
version = "1.0.0"
resources = ["assets/*"]
copyright = "Copyright Â© 2024"
short_description = "Claude API Provider Management Tool"
long_description = """
A cross-platform desktop application for managing Claude API providers 
and configurations with secure credential storage.
"""

[package.metadata.bundle.windows]
wix = true
sign_tool = "signtool"
sign_params = "/fd SHA256 /tr http://timestamp.digicert.com /td SHA256"

[package.metadata.bundle.osx]
signing_identity = "Developer ID Application"
provider_short_name = "ClaudeManager"
entitlements = "entitlements.plist"

[package.metadata.bundle.linux]
appimage = true
desktop_file = "assets/claude-code-provider-manager.desktop"
```

**CI/CD æ„å»ºæµç¨‹ï¼š**

```yaml
# .github/workflows/build.yml
name: Build and Release

on:
  push:
    tags: ['v*']

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Install dependencies
        run: npm ci
      - name: Build application
        run: npm run tauri:build
      - name: Sign Windows binary
        run: |
          signtool sign /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 \
                  /f ${{ secrets.WINDOWS_CERTIFICATE }} \
                  /p ${{ secrets.CERTIFICATE_PASSWORD }} \
                  "src-tauri/target/release/bundle/msi/*.msi"

  build-macos:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js and Rust
        # ... ç±»ä¼¼é…ç½®
      - name: Build and sign
        run: |
          npm run tauri:build
          codesign --force --deep --sign "${{ secrets.MACOS_CERTIFICATE }}" \
                   "src-tauri/target/release/bundle/dmg/*.app"

  build-linux:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.0-dev \
                                  libappindicator3-dev librsvg2-dev
      - name: Build application
        run: npm run tauri:build
```

## 7. éƒ¨ç½²æ¶æ„è®¾è®¡

### 7.1 æ„å»ºæµç¨‹è®¾è®¡

**æœ¬åœ°å¼€å‘æ„å»ºæµç¨‹ï¼š**

```bash
# å¼€å‘ç¯å¢ƒå¯åŠ¨
npm run dev           # å¯åŠ¨å‰ç«¯å¼€å‘æœåŠ¡å™¨
npm run tauri:dev     # å¯åŠ¨ Tauri å¼€å‘æ¨¡å¼ï¼ˆçƒ­é‡è½½ï¼‰

# æ„å»ºæµç¨‹
npm run build         # æ„å»ºå‰ç«¯èµ„æº
npm run tauri:build   # æ„å»ºå®Œæ•´åº”ç”¨ç¨‹åº

# è´¨é‡æ£€æŸ¥
npm run lint          # ä»£ç è´¨é‡æ£€æŸ¥
npm run lint:fix      # è‡ªåŠ¨ä¿®å¤ä»£ç é—®é¢˜
cargo test            # Rust åç«¯æµ‹è¯•
npm run test          # å‰ç«¯æµ‹è¯•ï¼ˆå¦‚æœæœ‰ï¼‰
```

**ç”Ÿäº§æ„å»ºä¼˜åŒ–ï¼š**

```javascript
// vite.config.ts - ç”Ÿäº§æ„å»ºä¼˜åŒ–
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  
  // æ„å»ºä¼˜åŒ–
  build: {
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      },
    },
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom', 'react-router-dom'],
          tauri: ['@tauri-apps/api'],
          icons: ['lucide-react'],
        },
      },
    },
    sourcemap: false, // ç”Ÿäº§ç¯å¢ƒä¸ç”Ÿæˆ sourcemap
  },
  
  // å¼€å‘æœåŠ¡å™¨é…ç½®
  server: {
    port: 3000,
    strictPort: true,
  },
  
  // ç¯å¢ƒå˜é‡å¤„ç†
  define: {
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version),
    __BUILD_TIME__: JSON.stringify(new Date().toISOString()),
  },
});
```

### 7.2 è‡ªåŠ¨åŒ–éƒ¨ç½²

**GitHub Actions å®Œæ•´æµç¨‹ï¼š**

```yaml
name: Release

on:
  push:
    tags: ['v*']

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint frontend
        run: npm run lint
      
      - name: Test Rust backend
        run: cargo test --manifest-path=src-tauri/Cargo.toml
  
  build:
    name: Build ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    needs: test
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows-x64
            os: windows-latest
            target: x86_64-pc-windows-msvc
            
          - platform: macos-x64
            os: macos-latest
            target: x86_64-apple-darwin
            
          - platform: macos-arm64
            os: macos-latest
            target: aarch64-apple-darwin
            
          - platform: linux-x64
            os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      
      - name: Install Linux dependencies
        if: matrix.platform == 'linux-x64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev libwebkit2gtk-4.0-dev \
            libappindicator3-dev librsvg2-dev \
            libasound2-dev
      
      - name: Install frontend dependencies
        run: npm ci
      
      - name: Build frontend
        run: npm run build
      
      - name: Build Tauri application
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Claude Code Provider Manager ${{ github.ref_name }}'
          releaseBody: |
            # Claude Code Provider Manager ${{ github.ref_name }}
            
            ## ğŸš€ æ–°åŠŸèƒ½
            - è¯¦ç»†æ›´æ–°æ—¥å¿—è¯·æŸ¥çœ‹ CHANGELOG.md
            
            ## ğŸ“¦ ä¸‹è½½
            è¯·æ ¹æ®æ‚¨çš„æ“ä½œç³»ç»Ÿä¸‹è½½å¯¹åº”çš„å®‰è£…åŒ…ï¼š
            - Windows: `.msi` å®‰è£…ç¨‹åº
            - macOS: `.dmg` ç£ç›˜æ˜ åƒ
            - Linux: `.AppImage` æˆ– `.deb` åŒ…
            
            ## ğŸ” å®‰å…¨éªŒè¯
            æ‰€æœ‰å‘å¸ƒçš„äºŒè¿›åˆ¶æ–‡ä»¶éƒ½ç»è¿‡æ•°å­—ç­¾åï¼Œè¯·ç¡®ä¿éªŒè¯ç­¾ååå†å®‰è£…ã€‚
          releaseDraft: false
          prerelease: false

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: build
    if: success()
    
    steps:
      - name: Send notification
        run: |
          echo "Release ${{ github.ref_name }} completed successfully"
          # å¯ä»¥æ·»åŠ å…¶ä»–é€šçŸ¥æ–¹å¼ï¼Œå¦‚å‘é€é‚®ä»¶ã€Slackæ¶ˆæ¯ç­‰
```

### 7.3 ç‰ˆæœ¬ç®¡ç†ç­–ç•¥

**è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶ï¼š**

```json
{
  "version": "1.2.3",
  "versionCode": "10203",
  "releaseChannel": "stable"
}
```

ç‰ˆæœ¬å·è§„åˆ™ï¼š
- **Major (1.x.x)**: é‡å¤§æ¶æ„å˜æ›´ã€ä¸å…¼å®¹çš„APIå˜æ›´
- **Minor (x.2.x)**: æ–°åŠŸèƒ½æ·»åŠ ã€å‘åå…¼å®¹çš„æ”¹è¿›
- **Patch (x.x.3)**: Bugä¿®å¤ã€å®‰å…¨æ›´æ–°

**è‡ªåŠ¨æ›´æ–°å®ç°ï¼š**

```rust
pub struct UpdateManager {
    current_version: Version,
    update_url: String,
    auto_check: bool,
}

impl UpdateManager {
    pub async fn check_for_updates(&self) -> Result<Option<UpdateInfo>, AppError> {
        if !self.auto_check {
            return Ok(None);
        }
        
        let response = reqwest::get(&format!("{}/latest", self.update_url)).await?;
        let update_info: UpdateInfo = response.json().await?;
        
        if update_info.version > self.current_version {
            Ok(Some(update_info))
        } else {
            Ok(None)
        }
    }
    
    pub async fn download_and_install_update(&self, update_info: &UpdateInfo) -> Result<(), AppError> {
        // ä¸‹è½½æ›´æ–°åŒ…
        let update_package = self.download_update(update_info).await?;
        
        // éªŒè¯ç­¾å
        self.verify_update_signature(&update_package)?;
        
        // æ‰§è¡Œæ›´æ–°
        #[cfg(windows)]
        self.install_windows_update(&update_package).await?;
        
        #[cfg(target_os = "macos")]
        self.install_macos_update(&update_package).await?;
        
        #[cfg(target_os = "linux")]
        self.install_linux_update(&update_package).await?;
        
        Ok(())
    }
}

#[derive(Debug, Deserialize)]
pub struct UpdateInfo {
    pub version: Version,
    pub release_notes: String,
    pub download_url: String,
    pub signature: String,
    pub file_size: u64,
    pub required: bool,
}
```

**é…ç½®è¿ç§»æœºåˆ¶ï¼š**

```rust
pub struct ConfigMigration {
    migrations: Vec<Box<dyn Migration>>,
}

trait Migration: Send + Sync {
    fn version(&self) -> Version;
    fn migrate(&self, config: &mut Configuration) -> Result<(), AppError>;
}

// ç¤ºä¾‹ï¼šv1.0 åˆ° v1.1 çš„é…ç½®è¿ç§»
pub struct MigrationV1_0ToV1_1;

impl Migration for MigrationV1_0ToV1_1 {
    fn version(&self) -> Version {
        Version::new(1, 1, 0)
    }
    
    fn migrate(&self, config: &mut Configuration) -> Result<(), AppError> {
        // æ·»åŠ æ–°çš„è®¾ç½®å­—æ®µ
        if config.settings.telemetry.is_none() {
            config.settings.telemetry = Some(false);
        }
        
        // è¿ç§»æä¾›å•†é…ç½®æ ¼å¼
        for provider in &mut config.providers {
            if provider.tags.is_none() {
                provider.tags = Some(Vec::new());
            }
        }
        
        // æ›´æ–°é…ç½®ç‰ˆæœ¬
        config.version = "1.1.0".to_string();
        
        Ok(())
    }
}
```

## 8. æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

### 8.1 å‰ç«¯æ€§èƒ½ä¼˜åŒ–

**React æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š**

```typescript
// ä½¿ç”¨ React.memo ä¼˜åŒ–ç»„ä»¶é‡æ¸²æŸ“
const ProviderCard = React.memo<ProviderCardProps>(({ provider, onEdit, onDelete }) => {
  const handleEdit = useCallback(() => {
    onEdit(provider.id);
  }, [provider.id, onEdit]);
  
  const handleDelete = useCallback(() => {
    onDelete(provider.id);
  }, [provider.id, onDelete]);
  
  return (
    <Card className="provider-card">
      <CardHeader>
        <h3>{provider.name}</h3>
        <StatusIndicator status={provider.isValid ? 'success' : 'error'} />
      </CardHeader>
      <CardContent>
        <p>{provider.baseUrl}</p>
        <p>{provider.model}</p>
      </CardContent>
      <CardActions>
        <Button onClick={handleEdit}>ç¼–è¾‘</Button>
        <Button variant="danger" onClick={handleDelete}>åˆ é™¤</Button>
      </CardActions>
    </Card>
  );
});

// è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
const ProviderList = () => {
  const { providers } = useConfig();
  
  const rowRenderer = useCallback(({ index, key, style }) => (
    <div key={key} style={style}>
      <ProviderCard provider={providers[index]} />
    </div>
  ), [providers]);
  
  return (
    <AutoSizer>
      {({ height, width }) => (
        <List
          width={width}
          height={height}
          rowCount={providers.length}
          rowHeight={120}
          rowRenderer={rowRenderer}
        />
      )}
    </AutoSizer>
  );
};

// çŠ¶æ€ç®¡ç†ä¼˜åŒ–
const ConfigProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(configReducer, initialState);
  
  // ä½¿ç”¨ useMemo ä¼˜åŒ–å¤æ‚è®¡ç®—
  const contextValue = useMemo(() => ({
    ...state,
    addProvider: (provider: Omit<Provider, 'id'>) => {
      dispatch({ type: 'ADD_PROVIDER_START' });
      return addProviderAsync(provider).then(
        (newProvider) => dispatch({ type: 'ADD_PROVIDER_SUCCESS', payload: newProvider }),
        (error) => dispatch({ type: 'ADD_PROVIDER_ERROR', payload: error.message })
      );
    },
    // å…¶ä»– actions...
  }), [state]);
  
  return (
    <ConfigContext.Provider value={contextValue}>
      {children}
    </ConfigContext.Provider>
  );
};
```

### 8.2 åç«¯æ€§èƒ½ä¼˜åŒ–

**Rust å¼‚æ­¥ä¼˜åŒ–ï¼š**

```rust
// å¹¶å‘é…ç½®éªŒè¯
pub struct ValidationService {
    client: Arc<reqwest::Client>,
    semaphore: Arc<Semaphore>,
}

impl ValidationService {
    pub async fn validate_providers_batch(
        &self, 
        providers: &[Provider]
    ) -> Result<Vec<ValidationResult>, AppError> {
        let tasks: Vec<_> = providers
            .iter()
            .map(|provider| {
                let client = Arc::clone(&self.client);
                let semaphore = Arc::clone(&self.semaphore);
                let provider = provider.clone();
                
                async move {
                    // é™åˆ¶å¹¶å‘æ•°é‡
                    let _permit = semaphore.acquire().await?;
                    
                    let start = std::time::Instant::now();
                    let result = self.validate_single_provider(&provider).await?;
                    let duration = start.elapsed();
                    
                    Ok::<ValidationResult, AppError>(ValidationResult {
                        provider_id: provider.id,
                        is_valid: result.is_valid,
                        latency: Some(duration.as_millis() as u32),
                        ..result
                    })
                }
            })
            .collect();
            
        let results = futures::future::try_join_all(tasks).await?;
        Ok(results)
    }
}

// ç¼“å­˜æœºåˆ¶
pub struct CacheManager<T> {
    cache: Arc<RwLock<HashMap<String, CachedItem<T>>>>,
    ttl: Duration,
}

#[derive(Debug, Clone)]
struct CachedItem<T> {
    data: T,
    created_at: Instant,
}

impl<T: Clone + Send + Sync + 'static> CacheManager<T> {
    pub fn new(ttl: Duration) -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
            ttl,
        }
    }
    
    pub async fn get_or_compute<F, Fut>(
        &self,
        key: &str,
        compute: F,
    ) -> Result<T, AppError>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = Result<T, AppError>>,
    {
        // å°è¯•ä»ç¼“å­˜è¯»å–
        {
            let cache = self.cache.read().await;
            if let Some(cached) = cache.get(key) {
                if cached.created_at.elapsed() < self.ttl {
                    return Ok(cached.data.clone());
                }
            }
        }
        
        // ç¼“å­˜ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸï¼Œé‡æ–°è®¡ç®—
        let computed_value = compute().await?;
        
        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.cache.write().await;
            cache.insert(key.to_string(), CachedItem {
                data: computed_value.clone(),
                created_at: Instant::now(),
            });
        }
        
        Ok(computed_value)
    }
}
```

### 8.3 åº”ç”¨ç›‘æ§å’Œè¯Šæ–­

**æ€§èƒ½ç›‘æ§ï¼š**

```rust
pub struct PerformanceMonitor {
    metrics: Arc<RwLock<ApplicationMetrics>>,
    start_time: Instant,
}

#[derive(Debug, Default)]
pub struct ApplicationMetrics {
    pub startup_time: Duration,
    pub memory_usage: u64,
    pub cpu_usage: f64,
    pub api_call_count: u64,
    pub api_call_latency: Vec<Duration>,
    pub cache_hit_rate: f64,
    pub error_count: u64,
}

impl PerformanceMonitor {
    pub async fn collect_metrics(&self) -> ApplicationMetrics {
        let mut metrics = self.metrics.write().await;
        
        // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
        metrics.memory_usage = self.get_memory_usage();
        metrics.cpu_usage = self.get_cpu_usage();
        
        // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
        metrics.cache_hit_rate = self.calculate_cache_hit_rate();
        
        // è®¡ç®—å¹³å‡å»¶è¿Ÿ
        if !metrics.api_call_latency.is_empty() {
            let total: Duration = metrics.api_call_latency.iter().sum();
            metrics.average_latency = total / metrics.api_call_latency.len() as u32;
        }
        
        metrics.clone()
    }
    
    pub async fn log_api_call(&self, duration: Duration, success: bool) {
        let mut metrics = self.metrics.write().await;
        metrics.api_call_count += 1;
        metrics.api_call_latency.push(duration);
        
        if !success {
            metrics.error_count += 1;
        }
        
        // ä¿æŒæœ€è¿‘1000æ¬¡è°ƒç”¨çš„è®°å½•
        if metrics.api_call_latency.len() > 1000 {
            metrics.api_call_latency.remove(0);
        }
    }
}

// é”™è¯¯è¿½è¸ª
pub struct ErrorTracker {
    errors: Arc<RwLock<VecDeque<ErrorEntry>>>,
    max_entries: usize,
}

#[derive(Debug, Clone)]
pub struct ErrorEntry {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub error: String,
    pub context: HashMap<String, String>,
    pub stack_trace: Option<String>,
}

impl ErrorTracker {
    pub async fn track_error(&self, error: &AppError, context: HashMap<String, String>) {
        let entry = ErrorEntry {
            timestamp: chrono::Utc::now(),
            error: error.to_string(),
            context,
            stack_trace: error.backtrace().map(|bt| bt.to_string()),
        };
        
        let mut errors = self.errors.write().await;
        errors.push_back(entry);
        
        // ä¿æŒé”™è¯¯æ—¥å¿—å¤§å°
        while errors.len() > self.max_entries {
            errors.pop_front();
        }
    }
    
    pub async fn get_recent_errors(&self, limit: usize) -> Vec<ErrorEntry> {
        let errors = self.errors.read().await;
        errors.iter()
            .rev()
            .take(limit)
            .cloned()
            .collect()
    }
}
```

## 9. æµ‹è¯•ç­–ç•¥

### 9.1 å‰ç«¯æµ‹è¯•

**å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ï¼š**

```typescript
// ç»„ä»¶æµ‹è¯•
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ProviderCard } from '../ProviderCard';

describe('ProviderCard', () => {
  const mockProvider: Provider = {
    id: 'test-1',
    name: 'Test Provider',
    baseUrl: 'https://api.test.com',
    model: 'claude-3-sonnet',
    smallFastModel: 'claude-3-haiku',
    isActive: false,
    isValid: true,
    // ... å…¶ä»–å¿…éœ€å­—æ®µ
  };

  it('renders provider information correctly', () => {
    render(
      <ProviderCard 
        provider={mockProvider}
        onEdit={jest.fn()}
        onDelete={jest.fn()}
      />
    );
    
    expect(screen.getByText('Test Provider')).toBeInTheDocument();
    expect(screen.getByText('https://api.test.com')).toBeInTheDocument();
    expect(screen.getByText('claude-3-sonnet')).toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', async () => {
    const mockOnEdit = jest.fn();
    
    render(
      <ProviderCard 
        provider={mockProvider}
        onEdit={mockOnEdit}
        onDelete={jest.fn()}
      />
    );
    
    fireEvent.click(screen.getByText('ç¼–è¾‘'));
    
    await waitFor(() => {
      expect(mockOnEdit).toHaveBeenCalledWith('test-1');
    });
  });
});

// Hook æµ‹è¯•
import { renderHook, act } from '@testing-library/react';
import { useConfig } from '../hooks/useConfig';

describe('useConfig', () => {
  it('should add provider correctly', async () => {
    const { result } = renderHook(() => useConfig());
    
    const newProvider = {
      name: 'New Provider',
      baseUrl: 'https://api.new.com',
      authToken: 'token-123',
      model: 'claude-3-sonnet',
      smallFastModel: 'claude-3-haiku',
    };
    
    await act(async () => {
      await result.current.addProvider(newProvider);
    });
    
    expect(result.current.providers).toHaveLength(1);
    expect(result.current.providers[0].name).toBe('New Provider');
  });
});
```

### 9.2 åç«¯æµ‹è¯•

**Rust å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ï¼š**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_config_manager_load_save() {
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("test_config.json");
        
        let mut config_manager = ConfigManager::new(config_path.clone()).unwrap();
        
        // åˆ›å»ºæµ‹è¯•é…ç½®
        let test_config = Configuration {
            version: "1.0.0".to_string(),
            active_provider_id: None,
            providers: vec![
                Provider {
                    id: "test-1".to_string(),
                    name: "Test Provider".to_string(),
                    base_url: "https://api.test.com".to_string(),
                    model: "claude-3-sonnet".to_string(),
                    small_fast_model: "claude-3-haiku".to_string(),
                    created_at: chrono::Utc::now(),
                    updated_at: chrono::Utc::now(),
                    is_active: false,
                    tags: None,
                    description: None,
                }
            ],
            settings: AppSettings::default(),
            metadata: ConfigMetadata::default(),
        };
        
        // ä¿å­˜é…ç½®
        config_manager.save_config(&test_config).await.unwrap();
        
        // åŠ è½½é…ç½®
        let loaded_config = config_manager.load_config().await.unwrap();
        
        assert_eq!(loaded_config.version, "1.0.0");
        assert_eq!(loaded_config.providers.len(), 1);
        assert_eq!(loaded_config.providers[0].name, "Test Provider");
    }

    #[tokio::test]
    async fn test_validation_service() {
        let validation_service = ValidationService::new().unwrap();
        
        let provider = Provider {
            id: "test-1".to_string(),
            name: "Test Provider".to_string(),
            base_url: "https://httpbin.org".to_string(), // ä½¿ç”¨æµ‹è¯•æœåŠ¡
            model: "claude-3-sonnet".to_string(),
            small_fast_model: "claude-3-haiku".to_string(),
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            is_active: false,
            tags: None,
            description: None,
        };
        
        let result = validation_service
            .validate_connection(&provider.base_url, "fake-token")
            .await;
            
        // éªŒè¯è¿”å›ç»“æœçš„ç»“æ„
        match result {
            Ok(validation_result) => {
                assert!(validation_result.latency.is_some());
                // æ›´å¤šæ–­è¨€...
            }
            Err(_) => {
                // ç½‘ç»œé”™è¯¯æ˜¯å¯ä»¥æ¥å—çš„ï¼Œä¸»è¦æ˜¯æµ‹è¯•ä»£ç ç»“æ„
            }
        }
    }

    #[test]
    fn test_encryption_manager() {
        let encryption_manager = EncryptionManager::new().unwrap();
        
        let original_data = "sensitive-auth-token-12345";
        
        // åŠ å¯†
        let encrypted = encryption_manager.encrypt_config(original_data).unwrap();
        assert_ne!(encrypted, original_data);
        
        // è§£å¯†
        let decrypted = encryption_manager.decrypt_config(&encrypted).unwrap();
        assert_eq!(decrypted, original_data);
    }
}

// é›†æˆæµ‹è¯•
#[cfg(test)]
mod integration_tests {
    use super::*;
    use std::sync::Arc;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_full_provider_lifecycle() {
        let temp_dir = TempDir::new().unwrap();
        let app_state = AppState::new_for_testing(temp_dir.path()).await.unwrap();
        
        // æ·»åŠ æä¾›å•†
        let create_request = CreateProviderRequest {
            name: "Test Provider".to_string(),
            base_url: "https://api.test.com".to_string(),
            auth_token: "token-123".to_string(),
            model: "claude-3-sonnet".to_string(),
            small_fast_model: "claude-3-haiku".to_string(),
        };
        
        let provider = commands::add_provider(app_state.clone(), create_request)
            .await
            .unwrap();
            
        // éªŒè¯æä¾›å•†å·²æ·»åŠ 
        let providers = commands::get_providers(app_state.clone()).await.unwrap();
        assert_eq!(providers.len(), 1);
        assert_eq!(providers[0].id, provider.id);
        
        // æ›´æ–°æä¾›å•†
        let update_request = UpdateProviderRequest {
            name: Some("Updated Provider".to_string()),
            base_url: None,
            auth_token: None,
            model: None,
            small_fast_model: None,
        };
        
        let updated_provider = commands::update_provider(
            app_state.clone(),
            provider.id.clone(),
            update_request
        ).await.unwrap();
        
        assert_eq!(updated_provider.name, "Updated Provider");
        
        // åˆ é™¤æä¾›å•†
        commands::delete_provider(app_state.clone(), provider.id.clone())
            .await
            .unwrap();
            
        let providers_after_delete = commands::get_providers(app_state.clone())
            .await
            .unwrap();
        assert_eq!(providers_after_delete.len(), 0);
    }
}
```

### 9.3 ç«¯åˆ°ç«¯æµ‹è¯•

**ä½¿ç”¨ Playwright è¿›è¡Œ E2E æµ‹è¯•ï¼š**

```typescript
// e2e/provider-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Provider Management', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    // ç­‰å¾…åº”ç”¨åŠ è½½å®Œæˆ
    await page.waitForSelector('[data-testid="app-loaded"]');
  });

  test('should add new provider', async ({ page }) => {
    // ç‚¹å‡»æ·»åŠ æä¾›å•†æŒ‰é’®
    await page.click('[data-testid="add-provider-button"]');
    
    // å¡«å†™æä¾›å•†ä¿¡æ¯
    await page.fill('[data-testid="provider-name"]', 'Test Provider');
    await page.fill('[data-testid="provider-url"]', 'https://api.test.com');
    await page.fill('[data-testid="provider-token"]', 'test-token-123');
    await page.selectOption('[data-testid="provider-model"]', 'claude-3-sonnet');
    await page.selectOption('[data-testid="provider-small-model"]', 'claude-3-haiku');
    
    // ä¿å­˜æä¾›å•†
    await page.click('[data-testid="save-provider-button"]');
    
    // éªŒè¯æä¾›å•†å·²æ·»åŠ åˆ°åˆ—è¡¨
    await expect(page.locator('[data-testid="provider-list"]')).toContainText('Test Provider');
    await expect(page.locator('[data-testid="provider-list"]')).toContainText('https://api.test.com');
  });

  test('should switch active provider', async ({ page }) => {
    // å‡è®¾å·²æœ‰ä¸¤ä¸ªæä¾›å•†
    await addTestProvider(page, 'Provider 1');
    await addTestProvider(page, 'Provider 2');
    
    // ç‚¹å‡»åˆ‡æ¢æä¾›å•†
    await page.click('[data-testid="provider-1-activate-button"]');
    
    // ç¡®è®¤åˆ‡æ¢å¯¹è¯æ¡†
    await page.click('[data-testid="confirm-switch-button"]');
    
    // éªŒè¯çŠ¶æ€æ æ˜¾ç¤ºå½“å‰æ¿€æ´»çš„æä¾›å•†
    await expect(page.locator('[data-testid="active-provider-indicator"]'))
      .toContainText('Provider 1');
  });

  test('should validate provider connection', async ({ page }) => {
    await page.click('[data-testid="add-provider-button"]');
    
    // å¡«å†™æä¾›å•†ä¿¡æ¯
    await page.fill('[data-testid="provider-name"]', 'Invalid Provider');
    await page.fill('[data-testid="provider-url"]', 'https://invalid-url.com');
    await page.fill('[data-testid="provider-token"]', 'invalid-token');
    
    // ç‚¹å‡»éªŒè¯æŒ‰é’®
    await page.click('[data-testid="validate-provider-button"]');
    
    // ç­‰å¾…éªŒè¯ç»“æœ
    await page.waitForSelector('[data-testid="validation-result"]');
    
    // éªŒè¯æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
    await expect(page.locator('[data-testid="validation-result"]'))
      .toHaveClass(/error/);
  });

  async function addTestProvider(page: Page, name: string) {
    await page.click('[data-testid="add-provider-button"]');
    await page.fill('[data-testid="provider-name"]', name);
    await page.fill('[data-testid="provider-url"]', 'https://api.test.com');
    await page.fill('[data-testid="provider-token"]', 'test-token');
    await page.selectOption('[data-testid="provider-model"]', 'claude-3-sonnet');
    await page.selectOption('[data-testid="provider-small-model"]', 'claude-3-haiku');
    await page.click('[data-testid="save-provider-button"]');
  }
});
```

## 10. æ–‡æ¡£å’Œç»´æŠ¤

### 10.1 æŠ€æœ¯æ–‡æ¡£ç»“æ„

**æ–‡æ¡£ç»„ç»‡æ¶æ„ï¼š**
```
docs/
â”œâ”€â”€ README.md                    // é¡¹ç›®æ¦‚è¿°å’Œå¿«é€Ÿå¼€å§‹
â”œâ”€â”€ ARCHITECTURE.md             // æœ¬æ¶æ„è®¾è®¡æ–‡æ¡£
â”œâ”€â”€ API_REFERENCE.md            // Tauri Commands API å‚è€ƒ
â”œâ”€â”€ DEPLOYMENT.md               // éƒ¨ç½²å’Œå‘å¸ƒæŒ‡å—
â”œâ”€â”€ SECURITY.md                 // å®‰å…¨è®¾è®¡å’Œæœ€ä½³å®è·µ
â”œâ”€â”€ CONTRIBUTING.md             // è´¡çŒ®æŒ‡å—
â”œâ”€â”€ CHANGELOG.md               // ç‰ˆæœ¬æ›´æ–°æ—¥å¿—
â”œâ”€â”€ development/               // å¼€å‘æ–‡æ¡£
â”‚   â”œâ”€â”€ setup.md              // å¼€å‘ç¯å¢ƒæ­å»º
â”‚   â”œâ”€â”€ coding-standards.md   // ä»£ç è§„èŒƒ
â”‚   â”œâ”€â”€ testing.md            // æµ‹è¯•æŒ‡å—
â”‚   â””â”€â”€ debugging.md          // è°ƒè¯•æŒ‡å—
â”œâ”€â”€ user-guide/               // ç”¨æˆ·æ–‡æ¡£
â”‚   â”œâ”€â”€ installation.md       // å®‰è£…æŒ‡å—
â”‚   â”œâ”€â”€ getting-started.md    // å…¥é—¨æ•™ç¨‹
â”‚   â”œâ”€â”€ features.md           // åŠŸèƒ½è¯´æ˜
â”‚   â””â”€â”€ troubleshooting.md    // æ•…éšœæ’é™¤
â””â”€â”€ assets/                   // æ–‡æ¡£èµ„æº
    â”œâ”€â”€ images/              // æˆªå›¾å’Œå›¾è¡¨
    â””â”€â”€ diagrams/            // æ¶æ„å›¾å’Œæµç¨‹å›¾
```

### 10.2 ä»£ç è´¨é‡ä¿éšœ

**ä»£ç è§„èŒƒå’Œå·¥å…·é…ç½®ï¼š**

```json
// .eslintrc.json - å‰ç«¯ä»£ç è§„èŒƒ
{
  "extends": [
    "@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "react/prop-types": "off",
    "react/react-in-jsx-scope": "off"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
```

```toml
# Cargo.toml - Rust ä»£ç è§„èŒƒé…ç½®
[lints.rust]
unsafe_code = "forbid"
unused_imports = "warn"
unused_variables = "warn"

[lints.clippy]
all = "warn"
pedantic = "warn"
nursery = "warn"
cargo = "warn"
```

### 10.3 æŒç»­é›†æˆå’Œè´¨é‡æ£€æŸ¥

**ä»£ç è´¨é‡æ£€æŸ¥æµç¨‹ï¼š**

```yaml
# .github/workflows/quality.yml
name: Code Quality

on: [push, pull_request]

jobs:
  frontend-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint TypeScript
        run: npm run lint
      
      - name: Type check
        run: npx tsc --noEmit
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  backend-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      
      - name: Check formatting
        run: cargo fmt --manifest-path=src-tauri/Cargo.toml --check
      
      - name: Lint with Clippy
        run: cargo clippy --manifest-path=src-tauri/Cargo.toml --all-targets --all-features -- -D warnings
      
      - name: Run tests
        run: cargo test --manifest-path=src-tauri/Cargo.toml
      
      - name: Security audit
        run: cargo audit --file src-tauri/Cargo.lock

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run npm audit
        run: npm audit --audit-level moderate
      
      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
```

## ç»“è¯­

æœ¬ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£ä¸º Claude Code Provider Manager GUI é¡¹ç›®æä¾›äº†å…¨é¢çš„æŠ€æœ¯æ¶æ„æŒ‡å¯¼ï¼Œæ¶µç›–äº†ä»å‰ç«¯UIç»„ä»¶åˆ°åç«¯ç³»ç»Ÿé›†æˆçš„å„ä¸ªå±‚é¢ã€‚

### ä¸»è¦äº®ç‚¹ï¼š

1. **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**: é‡‡ç”¨ React + Tauri æ¶æ„ï¼Œå…¼é¡¾å¼€å‘æ•ˆç‡å’Œåº”ç”¨æ€§èƒ½
2. **å®‰å…¨ä¼˜å…ˆ**: å¤šå±‚åŠ å¯†å­˜å‚¨ã€å¹³å°åŸç”Ÿå®‰å…¨APIé›†æˆã€æƒé™æœ€å°åŒ–åŸåˆ™
3. **è·¨å¹³å°æ”¯æŒ**: ç»Ÿä¸€çš„ä»£ç åŸºç¡€ï¼Œå¹³å°ç‰¹å®šçš„ä¼˜åŒ–å’Œé›†æˆ
4. **å¯æ‰©å±•è®¾è®¡**: æ¨¡å—åŒ–æ¶æ„ã€æ’ä»¶åŒ–æ”¯æŒã€æ¸…æ™°çš„æ¥å£å®šä¹‰
5. **è´¨é‡ä¿éšœ**: å®Œå–„çš„æµ‹è¯•ç­–ç•¥ã€è‡ªåŠ¨åŒ–CI/CDã€ä»£ç è´¨é‡ç›‘æ§

### å®æ–½å»ºè®®ï¼š

1. **åˆ†é˜¶æ®µå¼€å‘**: å»ºè®®æŒ‰MVP -> å¢å¼ºç‰ˆ -> ä¸“ä¸šç‰ˆçš„è·¯çº¿å›¾é€æ­¥å®æ–½
2. **å®‰å…¨æµ‹è¯•**: é‡ç‚¹å…³æ³¨æ•æ„Ÿæ•°æ®å¤„ç†å’Œè·¨å¹³å°å®‰å…¨å­˜å‚¨çš„æµ‹è¯•éªŒè¯
3. **æ€§èƒ½ç›‘æ§**: å»ºç«‹åº”ç”¨æ€§èƒ½åŸºçº¿ï¼ŒæŒç»­ç›‘æ§å’Œä¼˜åŒ–ç”¨æˆ·ä½“éªŒ
4. **ç”¨æˆ·åé¦ˆ**: å»ºç«‹ç”¨æˆ·åé¦ˆæ”¶é›†æœºåˆ¶ï¼Œè¿­ä»£ä¼˜åŒ–äº§å“åŠŸèƒ½

è¿™ä¸ªæ¶æ„è®¾è®¡ä¸ºé¡¹ç›®å›¢é˜Ÿæä¾›äº†æ¸…æ™°çš„å¼€å‘è·¯å¾„å’ŒæŠ€æœ¯å†³ç­–ä¾æ®ï¼Œç¡®ä¿æœ€ç»ˆäº¤ä»˜çš„äº§å“æ—¢æ»¡è¶³ç”¨æˆ·éœ€æ±‚ï¼Œåˆå…·å¤‡è‰¯å¥½çš„å¯ç»´æŠ¤æ€§å’Œæ‰©å±•æ€§ã€‚