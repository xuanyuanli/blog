---
title: AIç¼–ç¨‹æ—¶ä»£ä¸‹çš„åç«¯å¼€å‘åˆ©å™¨ï¼šSupabase
date: 2025-09-17 10:45:00
permalink: /pages/supabase-ai-backend/
categories:
  - æ¶æ„
  - AI
tags:
  - Supabase
  - AIç¼–ç¨‹
author:
  name: è½©è¾•æ
  link: https://github.com/xuanyuanli
---

æœ¬æ–‡èšç„¦â€œAI ç¼–ç¨‹æ—¶ä»£â€çš„åº”ç”¨åç«¯è¯‰æ±‚ï¼Œç”¨ Supabase ä½œä¸ºä¸€ä½“åŒ–æ–¹æ¡ˆçš„æ ¸å¿ƒæ”¯ç‚¹ï¼Œä»æ¶æ„åˆ°å·¥ç¨‹è½åœ°ç»™å‡ºå¯å¤ç”¨çš„å®è·µæ¡†æ¶ä¸æ¸…å•ã€‚

<!-- more -->

## ä¸€ã€å¼•è¨€ï¼šAI ç¼–ç¨‹æ—¶ä»£çš„åç«¯æ–°è¯‰æ±‚

éšç€ ChatGPTã€Claudeã€GitHub Copilot ç­‰ `AI ç¼–ç¨‹å·¥å…·`çš„æ™®åŠï¼Œè½¯ä»¶å¼€å‘çš„èŠ‚å¥å’Œæ¨¡å¼æ­£åœ¨å‘ç”Ÿæ ¹æœ¬æ€§è½¬å˜ã€‚å¼€å‘è€…ä»¬å¯ä»¥åœ¨å‡ åˆ†é’Ÿå†…ç”Ÿæˆå®Œæ•´çš„åŠŸèƒ½æ¨¡å—ï¼Œå¿«é€ŸéªŒè¯äº§å“æƒ³æ³•ï¼Œè¿™ç§"æ•æ·è‡³ä¸Š"çš„å¼€å‘æ¨¡å¼å¯¹åç«¯æ¶æ„æå‡ºäº†å…¨æ–°çš„è¯‰æ±‚ï¼š

### 1ã€æé€ŸåŸå‹éªŒè¯
ä¼ ç»Ÿçš„åç«¯æ­å»ºå¾€å¾€éœ€è¦å‡ å¤©ç”šè‡³å‡ å‘¨ï¼Œè€Œåœ¨ AI ç¼–ç¨‹æ—¶ä»£ï¼Œäº§å“ç»ç†å¯èƒ½åœ¨åˆé¤æ—¶é—´å°±æƒ³å‡ºäº†ä¸‰ä¸ªä¸åŒçš„äº§å“æ–¹å‘ã€‚åç«¯æ¶æ„å¿…é¡»æ”¯æŒ`å°æ—¶çº§`çš„ MVP æ­å»ºï¼Œè®©æƒ³æ³•èƒ½å¤Ÿå¿«é€Ÿè½åœ°éªŒè¯ã€‚

### 2ã€å‘é‡æ£€ç´¢èƒ½åŠ›æˆä¸ºåˆšéœ€
å‡ ä¹æ‰€æœ‰çš„ AI åº”ç”¨éƒ½ç¦»ä¸å¼€ `RAG`ï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰æ¨¡å¼ï¼š
- **çŸ¥è¯†åº“é—®ç­”**ï¼šç”¨æˆ·ä¸Šä¼ æ–‡æ¡£ï¼ŒAI åŸºäºæ–‡æ¡£å†…å®¹å›ç­”é—®é¢˜
- **ä»£ç åŠ©æ‰‹**ï¼šæ£€ç´¢ç›¸å…³ä»£ç ç‰‡æ®µï¼Œæä¾›ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„å»ºè®®
- **ä¸ªæ€§åŒ–æ¨è**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºå‘é‡ï¼Œæ¨èç›¸å…³å†…å®¹

è¿™æ„å‘³ç€å‘é‡æ•°æ®åº“ä¸å†æ˜¯"å¯é€‰é¡¹"ï¼Œè€Œæ˜¯ä¸å…³ç³»æ•°æ®åº“åŒç­‰é‡è¦çš„åŸºç¡€è®¾æ–½ã€‚

### 3ã€æµå¼å¤„ç†ä¸å®æ—¶äº¤äº’
ç”¨æˆ·å¯¹ AI åº”ç”¨çš„ä½“éªŒæœŸæœ›å·²ç»è¢« ChatGPT é‡æ–°å®šä¹‰ï¼š
- **é€å­—æµå¼è¾“å‡º**ï¼šçœ‹åˆ° AI "æ€è€ƒ"çš„è¿‡ç¨‹ï¼Œè€Œéç­‰å¾…æœ€ç»ˆç»“æœ
- **å®æ—¶åä½œ**ï¼šå¤šç”¨æˆ·åŒæ—¶ç¼–è¾‘æ–‡æ¡£ã€ä»£ç ï¼ŒAI å®æ—¶æä¾›å»ºè®®
- **çŠ¶æ€åŒæ­¥**ï¼šå¯¹è¯å†å²ã€å¤„ç†è¿›åº¦åœ¨å¤šè®¾å¤‡é—´æ— ç¼åŒæ­¥

### 4ã€å¼¹æ€§è®¡è´¹ä¸é…é¢ç®¡ç†
AI æ¨ç†çš„æˆæœ¬æ³¢åŠ¨å·¨å¤§ï¼Œä» GPT-4 çš„æ¯åƒ token $0.03ï¼Œåˆ°æœ¬åœ°æ¨¡å‹çš„è¿‘ä¹å…è´¹ã€‚åº”ç”¨éœ€è¦ï¼š
- **ç²¾ç¡®çš„ç”¨é‡è¿½è¸ª**ï¼šæŒ‰ tokenã€æŒ‰è¯·æ±‚ã€æŒ‰ç”¨æˆ·ç²¾ç»†è®¡è´¹
- **çµæ´»çš„é…é¢ç­–ç•¥**ï¼šå…è´¹é¢åº¦ã€è®¢é˜…å¥—é¤ã€æŒ‰é‡ä»˜è´¹çš„æ··åˆæ¨¡å¼
- **æˆæœ¬æ§åˆ¶**ï¼šé˜²æ­¢æ¶æ„è°ƒç”¨å¯¼è‡´çš„è´¹ç”¨çˆ†ç‚¸

### 5ã€å¤šç§Ÿæˆ·å®‰å…¨éš”ç¦»
AI åº”ç”¨å¾€å¾€å¤„ç†æ•æ„Ÿçš„ç”¨æˆ·æ•°æ®ï¼ˆæ–‡æ¡£ã€å¯¹è¯è®°å½•ã€ä»£ç ç‰‡æ®µï¼‰ï¼Œéœ€è¦ä¸¥æ ¼çš„æ•°æ®éš”ç¦»ï¼š
- **ä¼ä¸šçº§å¤šç§Ÿæˆ·**ï¼šä¸åŒç»„ç»‡çš„æ•°æ®ç»å¯¹éš”ç¦»
- **ç»†ç²’åº¦æƒé™æ§åˆ¶**ï¼šé¡¹ç›®çº§ã€ç”¨æˆ·çº§çš„æ•°æ®è®¿é—®æ§åˆ¶
- **å®¡è®¡ä¸åˆè§„**ï¼šæ•°æ®è®¿é—®æ—¥å¿—ã€åˆ é™¤è®°å½•çš„å®Œæ•´è¿½è¸ª

è¿™äº›æ–°è¯‰æ±‚å¯¹ä¼ ç»Ÿçš„åç«¯æŠ€æœ¯æ ˆæå‡ºäº†æŒ‘æˆ˜ï¼šä½ éœ€è¦åŒæ—¶ç²¾é€š PostgreSQLã€Redisã€Elasticsearchã€æ¶ˆæ¯é˜Ÿåˆ—ã€èº«ä»½è®¤è¯ç­‰å¤šä¸ªç»„ä»¶ï¼Œè¿˜è¦è€ƒè™‘å®ƒä»¬ä¹‹é—´çš„é›†æˆä¸è¿ç»´å¤æ‚åº¦ã€‚è€Œ `Supabase` ä½œä¸ºä¸€ä¸ª"åç«¯å³æœåŠ¡"å¹³å°ï¼Œæ°å¥½åœ¨è¿™ä¸ªæ—¶é—´ç‚¹æä¾›äº†ä¸€ä¸ªæ•´åˆçš„è§£å†³æ–¹æ¡ˆã€‚

## äºŒã€ä¸ºä»€ä¹ˆé€‰æ‹© Supabaseï¼ˆAI åœºæ™¯ä¼˜åŠ¿ä¸è¾¹ç•Œï¼‰

åœ¨ä¼—å¤šåç«¯æ–¹æ¡ˆä¸­ï¼Œ`Supabase` ä¸º AI åº”ç”¨æä¾›äº†ç‹¬ç‰¹çš„ä»·å€¼ä¸»å¼ ã€‚è®©æˆ‘ä»¬ä»æŠ€æœ¯æ¶æ„å’Œä¸šåŠ¡åœºæ™¯ä¸¤ä¸ªç»´åº¦æ¥åˆ†æå…¶é€‚ç”¨æ€§ã€‚

### 1ã€æ ¸å¿ƒä¼˜åŠ¿ï¼šAI æ—¶ä»£çš„å®Œç¾å¥‘åˆ

#### 1.1ã€PostgreSQL + pgvectorï¼šåŸç”Ÿå‘é‡æ”¯æŒ
ä¸åŒäº Pineconeã€Weaviate ç­‰ä¸“ç”¨å‘é‡æ•°æ®åº“ï¼ŒSupabase åŸºäº `PostgreSQL` + `pgvector` æ‰©å±•ï¼Œæä¾›äº†ç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼š

**äº‹åŠ¡ä¸€è‡´æ€§**ï¼šå‘é‡æ•°æ®ä¸ä¸šåŠ¡æ•°æ®åœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­å¤„ç†
```sql
BEGIN;
-- æ’å…¥æ–‡æ¡£å…ƒæ•°æ®
INSERT INTO documents (title, content, user_id)
VALUES ('AIç¼–ç¨‹æŒ‡å—', '...', 'user123') RETURNING id;

-- æ’å…¥å¯¹åº”çš„å‘é‡æ•°æ®
INSERT INTO embeddings (document_id, vector)
VALUES (currval('documents_id_seq'), '[0.1, 0.2, ...]');
COMMIT;
```

**å…³è”æŸ¥è¯¢èƒ½åŠ›**ï¼šå‘é‡æ£€ç´¢å¯ä»¥ä¸ä¸šåŠ¡é€»è¾‘æ— ç¼ç»“åˆ
```sql
-- åœ¨ç”¨æˆ·æƒé™èŒƒå›´å†…è¿›è¡Œå‘é‡æ£€ç´¢
SELECT d.title, d.content, 1 - (e.vector <=> query_vector) as similarity
FROM documents d
JOIN embeddings e ON d.id = e.document_id
JOIN user_permissions p ON d.org_id = p.org_id
WHERE p.user_id = auth.uid()
ORDER BY e.vector <=> query_vector
LIMIT 10;
```

**ä¸°å¯Œçš„ç´¢å¼•ç­–ç•¥**ï¼š
- `ivfflat`ï¼šé€‚åˆä¸­ç­‰è§„æ¨¡ï¼ˆ< 100ä¸‡å‘é‡ï¼‰ï¼ŒæŸ¥è¯¢é€Ÿåº¦å¿«
- `hnsw`ï¼šé€‚åˆå¤§è§„æ¨¡æ•°æ®ï¼Œå†…å­˜å‹å¥½ï¼Œæ”¯æŒå¹¶å‘æŸ¥è¯¢

#### 1.2ã€ä¸€ä½“åŒ–æ¶æ„ï¼šå‡å°‘é›†æˆåœ°ç‹±
ä¼ ç»Ÿæ–¹æ¡ˆå¾€å¾€éœ€è¦ç»„åˆå¤šä¸ªæœåŠ¡ï¼š
```
Firebase Auth + AWS S3 + Pinecone + Redis + Express.js + WebSocket...
```

Supabase å°†è¿™äº›èƒ½åŠ›æ•´åˆåœ¨ä¸€ä¸ªå¹³å°ï¼š
- **Auth**ï¼šJWT + Row Level Securityï¼ŒåŸç”Ÿå¤šç§Ÿæˆ·æ”¯æŒ
- **Storage**ï¼šæ–‡ä»¶ä¸Šä¼  + CDN + æƒé™æ§åˆ¶
- **Database**ï¼šPostgreSQL + å®æ—¶è®¢é˜…
- **Edge Functions**ï¼šAI æ¨ç†ç½‘å…³ + æµå¼å¤„ç†
- **Realtime**ï¼šWebSocket + çŠ¶æ€åŒæ­¥

#### 1.3ã€Row Level Security (RLS)ï¼šå®‰å…¨å¤šç§Ÿæˆ·
è¿™æ˜¯ Supabase ç›¸æ¯”å…¶ä»– BaaS çš„æ€æ‰‹çº§ç‰¹æ€§ï¼š

```sql
-- ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±ç»„ç»‡çš„æ•°æ®
create policy "Users can only access their org data" on documents
for all using (
  exists (
    select 1 from memberships
    where user_id = auth.uid() and org_id = documents.org_id
  )
);
```

RLS åœ¨æ•°æ®åº“å±‚é¢å¼ºåˆ¶æ‰§è¡Œæƒé™ï¼Œå³ä½¿åº”ç”¨å±‚æœ‰ bugï¼Œä¹Ÿæ— æ³•ç»•è¿‡å®‰å…¨ç­–ç•¥ã€‚

#### 1.4ã€å¼€æºä¸è‡ªæ‰˜ç®¡ï¼šé¿å…å‚å•†é”å®š
- **äº‘æœåŠ¡**ï¼šå¿«é€Ÿå¼€å§‹ï¼Œå®Œæ•´çš„è¿ç»´æ”¯æŒ
- **è‡ªæ‰˜ç®¡**ï¼šæ•°æ®ä¸»æƒï¼Œè‡ªå®šä¹‰æ‰©å±•ï¼Œæˆæœ¬å¯æ§
- **è¿ç§»å‹å¥½**ï¼šæ ‡å‡† PostgreSQLï¼Œéšæ—¶å¯ä»¥è¿ç§»åˆ°å…¶ä»–å¹³å°

### 2ã€æŠ€æœ¯è¾¹ç•Œï¼šä½•æ—¶éœ€è¦è¡¥å……æ–¹æ¡ˆ

#### 2.1ã€è¶…å¤§è§„æ¨¡å‘é‡æ£€ç´¢ï¼ˆ> 500ä¸‡å‘é‡ï¼‰
**é—®é¢˜**ï¼špgvector åœ¨æå¤§è§„æ¨¡ä¸‹çš„æ€§èƒ½ç“¶é¢ˆ
**è§£å†³æ–¹æ¡ˆ**ï¼š
- **æ··åˆæ¶æ„**ï¼šSupabase å­˜å‚¨å…ƒæ•°æ®ï¼Œä¸“ç”¨å‘é‡åº“ï¼ˆPinecone/Milvusï¼‰å­˜å‚¨å‘é‡
- **åˆ†ç‰‡ç­–ç•¥**ï¼šæŒ‰ç§Ÿæˆ·ã€æ—¶é—´æˆ–ä¸»é¢˜åˆ†ç‰‡ï¼Œé™ä½å•è¡¨è§„æ¨¡

#### 2.2ã€å¤æ‚çš„ AI æ¨ç†ç®¡é“
**é—®é¢˜**ï¼šEdge Functions æœ‰ 10MB å†…å­˜é™åˆ¶ï¼Œä¸é€‚åˆå¤§æ¨¡å‹æ¨ç†
**è§£å†³æ–¹æ¡ˆ**ï¼š
- **å¼‚æ­¥å¤„ç†**ï¼šEdge Functions æ¥æ”¶è¯·æ±‚ â†’ é˜Ÿåˆ— â†’ Worker å¤„ç† â†’ Webhook å›è°ƒ
- **å¤–éƒ¨ AI æœåŠ¡**ï¼šEdge Functions ä½œä¸ºä»£ç†ï¼Œè°ƒç”¨ OpenAI/Anthropic API

#### 2.3ã€å®æ—¶åä½œçš„é«˜å¹¶å‘åœºæ™¯
**é—®é¢˜**ï¼šRealtime çš„è¿æ¥æ•°é™åˆ¶ï¼ˆå…è´¹ç‰ˆ 200 å¹¶å‘ï¼‰
**è§£å†³æ–¹æ¡ˆ**ï¼š
- **åˆ†å±‚æ¶æ„**ï¼šæ ¸å¿ƒçŠ¶æ€ç”¨ Supabase Realtimeï¼ŒUI å±‚ç”¨ Socket.io
- **äº‹ä»¶èšåˆ**ï¼šå‡å°‘æ¨é€é¢‘ç‡ï¼Œæ‰¹é‡å¤„ç†çŠ¶æ€æ›´æ–°

### 3ã€ä¸šåŠ¡åœºæ™¯é€‚é…åº¦åˆ†æ

#### 3.1ã€ğŸŸ¢ å®Œç¾é€‚é…åœºæ™¯
- **AI èŠå¤©åº”ç”¨**ï¼šå¯¹è¯å†å² + æµå¼è¾“å‡º + å¤šç”¨æˆ·åä½œ
- **çŸ¥è¯†åº“é—®ç­”**ï¼šæ–‡æ¡£ä¸Šä¼  + å‘é‡æ£€ç´¢ + æƒé™æ§åˆ¶
- **ä»£ç åŠ©æ‰‹**ï¼šä»£ç ç‰‡æ®µå­˜å‚¨ + è¯­ä¹‰æœç´¢ + å®æ—¶å»ºè®®

#### 3.2ã€ğŸŸ¡ éƒ¨åˆ†é€‚é…åœºæ™¯
- **å¤§è§„æ¨¡å†…å®¹å¹³å°**ï¼šå¯èƒ½éœ€è¦ CDN + ç¼“å­˜å±‚ä¼˜åŒ–
- **é«˜é¢‘äº¤æ˜“ AI**ï¼šéœ€è¦è¯„ä¼°å»¶è¿Ÿè¦æ±‚ï¼Œå¯èƒ½éœ€è¦å†…å­˜æ•°æ®åº“

#### 3.3ã€ğŸ”´ ä¸é€‚é…åœºæ™¯
- **å¤§æ¨¡å‹è®­ç»ƒ**ï¼šéœ€è¦ GPU é›†ç¾¤ï¼Œé Supabase ç›®æ ‡åœºæ™¯
- **å®æ—¶éŸ³è§†é¢‘ AI**ï¼šéœ€è¦ä¸“ç”¨çš„æµåª’ä½“æœåŠ¡

### 4ã€æˆæœ¬è€ƒé‡ï¼šTCO åˆ†æ

**å¼€å‘æˆæœ¬**ï¼šSupabase å¯ä»¥å‡å°‘ 60-80% çš„åç«¯å¼€å‘æ—¶é—´
**è¿ç»´æˆæœ¬**ï¼šæ‰˜ç®¡æœåŠ¡æ¶ˆé™¤äº† DevOps å›¢é˜Ÿçš„å¿…è¦æ€§
**æ‰©å±•æˆæœ¬**ï¼šæŒ‰éœ€ä»˜è´¹ï¼Œä½†å¤§è§„æ¨¡ä¸‹å¯èƒ½æ¯”è‡ªå»ºæ–¹æ¡ˆæ˜‚è´µ

**ç”œèœœç‚¹**ï¼š10-100 ä¸‡ç”¨æˆ·çš„ä¸­ç­‰è§„æ¨¡ AI åº”ç”¨

## ä¸‰ã€å‚è€ƒæ¶æ„ï¼ˆWeb/ç§»åŠ¨ + Supabase æ¨¡å—ï¼‰

```
Client(Next.js/Expo)
  â”‚
  â”œâ”€ Auth(JWT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                        â”‚
  â”œâ”€ Upload â†’ Storage â”€â”€â”  â”‚
  â”‚                     â”‚  â”‚
  â”œâ”€ Chat/SSE/WebSocket â”‚  â”‚
  â”‚                     â”‚  â”‚
  â–¼                     â–¼  â–¼
Edge Functions (AI ç½‘å…³/é…é¢/æ—¥å¿—)
  â”‚     â”œâ”€ LLM æä¾›å•†è°ƒç”¨ï¼ˆæµå¼ï¼‰
  â”‚     â”œâ”€ å†™ messages/usage_events
  â”‚     â””â”€ è§¦å‘å‘é‡å…¥åº“ç®¡é“
  â–¼
Postgres + pgvectorï¼ˆä¸šåŠ¡è¡¨/å‘é‡è¡¨/RLSï¼‰
Realtimeï¼ˆä¼šè¯/çŠ¶æ€æ¨é€ï¼‰
```

## å››ã€æ ¸å¿ƒç»„ä»¶é€Ÿè§ˆ

- Auth + RLSï¼šå†…ç½®ç”¨æˆ·ä½“ç³» + è¡Œçº§å®‰å…¨ï¼Œæ”¯æŒå¤šç§Ÿæˆ·éš”ç¦»ã€‚
- Storageï¼šæ–‡æ¡£ä¸èµ„æºç»Ÿä¸€å­˜å‚¨ï¼ŒWebhook/ä»»åŠ¡è§¦å‘å¤„ç†ã€‚
- pgvectorï¼š`vector` åˆ— + `ivfflat`/`hnsw` ç´¢å¼•ï¼Œå®ç°é«˜æ•ˆç›¸ä¼¼åº¦æ£€ç´¢ã€‚
- Edge Functionsï¼šé‰´æƒç½‘å…³ã€é…é¢æ§åˆ¶ã€æµå¼ä»£ç†ã€å®¡è®¡è½åº“ã€‚
- Realtimeï¼šä¼šè¯çŠ¶æ€/ååŒç¼–è¾‘/è¿›åº¦æ¡ç­‰å®æ—¶ä½“éªŒã€‚

## äº”ã€å…³é”®å®è·µä¸€ï¼šé‰´æƒä¸å¤šç§Ÿæˆ·

åœ¨ AI åº”ç”¨ä¸­ï¼Œå¤šç§Ÿæˆ·æ¶æ„ä¸ä»…æ˜¯æˆæœ¬ä¼˜åŒ–çš„éœ€è¦ï¼Œæ›´æ˜¯æ•°æ®å®‰å…¨çš„åŸºç¡€ã€‚Supabase çš„ `Row Level Security` (RLS) æä¾›äº†æ•°æ®åº“çº§åˆ«çš„æƒé™æ§åˆ¶ï¼Œè¿™æ˜¯å…¶ç›¸å¯¹äº Firebase ç­‰ç«å“çš„æ ¸å¿ƒä¼˜åŠ¿ã€‚

### 1ã€å¤šç§Ÿæˆ·æ•°æ®æ¨¡å‹è®¾è®¡

#### 1.1ã€å±‚æ¬¡åŒ–ç§Ÿæˆ·ç»“æ„
```sql
-- ç»„ç»‡è¡¨ï¼šé¡¶çº§ç§Ÿæˆ·
CREATE TABLE organizations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é¡¹ç›®è¡¨ï¼šäºŒçº§ç§Ÿæˆ·
CREATE TABLE projects (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(org_id, name)
);

-- æˆå‘˜å…³ç³»è¡¨ï¼šæƒé™ç®¡æ§
CREATE TABLE memberships (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  role TEXT CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, org_id)
);
```

#### 1.2ã€ä¸šåŠ¡è¡¨è®¾è®¡åŸåˆ™
æ‰€æœ‰ä¸šåŠ¡è¡¨éƒ½éœ€è¦æºå¸¦ç§Ÿæˆ·æ ‡è¯†ï¼š

```sql
-- æ–‡æ¡£è¡¨
CREATE TABLE documents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT,
  upload_user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- å¯¹è¯è¡¨
CREATE TABLE conversations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  title TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 2ã€ç­–ç•¥è®¾è®¡æ¨¡å¼

#### 2.1ã€åŸºç¡€ç»„ç»‡çº§éš”ç¦»
```sql
-- ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±æ‰€å±ç»„ç»‡çš„æ•°æ®
CREATE POLICY "org_isolation_policy" ON documents
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM memberships
    WHERE user_id = auth.uid()
      AND org_id = documents.org_id
  )
);
```

#### 2.2ã€è§’è‰²åŸºæƒé™æ§åˆ¶
```sql
-- åˆ›å»ºè§’è‰²æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_user_role(target_org_id UUID, required_role TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM memberships
    WHERE user_id = auth.uid()
      AND org_id = target_org_id
      AND (
        CASE required_role
          WHEN 'viewer' THEN role IN ('viewer', 'member', 'admin', 'owner')
          WHEN 'member' THEN role IN ('member', 'admin', 'owner')
          WHEN 'admin' THEN role IN ('admin', 'owner')
          WHEN 'owner' THEN role = 'owner'
          ELSE FALSE
        END
      )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- åº”ç”¨è§’è‰²ç­–ç•¥
CREATE POLICY "documents_select_policy" ON documents
FOR SELECT USING (check_user_role(org_id, 'viewer'));

CREATE POLICY "documents_insert_policy" ON documents
FOR INSERT WITH CHECK (check_user_role(org_id, 'member'));

CREATE POLICY "documents_update_policy" ON documents
FOR UPDATE USING (check_user_role(org_id, 'member'));

CREATE POLICY "documents_delete_policy" ON documents
FOR DELETE USING (check_user_role(org_id, 'admin'));
```

#### 2.3ã€é¡¹ç›®çº§ç»†ç²’åº¦æ§åˆ¶
```sql
-- é¡¹ç›®çº§æƒé™è¡¨
CREATE TABLE project_permissions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  permission TEXT CHECK (permission IN ('read', 'write', 'admin')),
  granted_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, project_id)
);

-- é¡¹ç›®çº§è®¿é—®ç­–ç•¥
CREATE POLICY "project_level_access" ON documents
FOR ALL USING (
  -- ç»„ç»‡æˆå‘˜ + é¡¹ç›®æƒé™
  check_user_role(org_id, 'viewer') AND
  EXISTS (
    SELECT 1 FROM project_permissions pp
    WHERE pp.user_id = auth.uid()
      AND pp.project_id = documents.project_id
      AND pp.permission IN ('read', 'write', 'admin')
  )
);
```

### 3ã€ä½“ç³»ä¸ API Key ç®¡ç†

#### 3.1ã€ç”¨æˆ· JWT Token
Supabase è‡ªåŠ¨å¤„ç†ç”¨æˆ·è®¤è¯ï¼ŒJWT ä¸­åŒ…å« `user_id`ï¼Œå¯åœ¨ RLS ä¸­é€šè¿‡ `auth.uid()` è®¿é—®ã€‚

#### 3.2ã€é¡¹ç›®çº§ API Key
ç”¨äºæœåŠ¡é—´è°ƒç”¨ï¼Œå®ç°æœ€å°æƒé™åŸåˆ™ï¼š

```sql
-- API Key è¡¨
CREATE TABLE api_keys (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  key_hash TEXT UNIQUE NOT NULL, -- å­˜å‚¨ hashï¼Œä¸å­˜å‚¨æ˜æ–‡
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  permissions JSONB DEFAULT '[]', -- ["documents:read", "conversations:write"]
  expires_at TIMESTAMPTZ,
  created_by UUID REFERENCES auth.users(id),
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE
);

-- API Key æƒé™æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_api_key_permission(
  key_hash TEXT,
  required_permission TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  key_record RECORD;
BEGIN
  SELECT * INTO key_record
  FROM api_keys
  WHERE key_hash = $1
    AND is_active = TRUE
    AND (expires_at IS NULL OR expires_at > NOW());

  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;

  -- æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
  UPDATE api_keys SET last_used_at = NOW() WHERE id = key_record.id;

  -- æ£€æŸ¥æƒé™
  RETURN key_record.permissions @> to_jsonb(required_permission);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### 3.3ã€Edge Functions ä¸­çš„æƒé™éªŒè¯
```typescript
// åœ¨ Edge Functions ä¸­éªŒè¯ API Key
export async function validateApiKey(request: Request, requiredPermission: string) {
  const apiKey = request.headers.get('X-API-Key');
  if (!apiKey) {
    throw new Error('API Key required');
  }

  const keyHash = await crypto.subtle.digest(
    'SHA-256',
    new TextEncoder().encode(apiKey)
  );

  const { data, error } = await supabase.rpc('check_api_key_permission', {
    key_hash: Array.from(new Uint8Array(keyHash)).map(b => b.toString(16).padStart(2, '0')).join(''),
    required_permission: requiredPermission
  });

  if (error || !data) {
    throw new Error('Invalid API Key or insufficient permissions');
  }

  return true;
}
```

### 4ã€å®é™…åº”ç”¨åœºæ™¯

#### 4.1ã€AI èŠå¤©åº”ç”¨
- **ç»„ç»‡éš”ç¦»**ï¼šä¸åŒå…¬å¸çš„å¯¹è¯è®°å½•å®Œå…¨éš”ç¦»
- **é¡¹ç›®æƒé™**ï¼šåŒå…¬å¸å†…ä¸åŒé¡¹ç›®çš„è®¿é—®æ§åˆ¶
- **è§’è‰²æƒé™**ï¼šç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹æ‰€æœ‰å¯¹è¯ï¼Œæ™®é€šç”¨æˆ·åªèƒ½çœ‹è‡ªå·±çš„

#### 4.2ã€çŸ¥è¯†åº“å¹³å°
- **æ–‡æ¡£çº§æƒé™**ï¼šæ•æ„Ÿæ–‡æ¡£åªæœ‰ç‰¹å®šè§’è‰²å¯è®¿é—®
- **å‘é‡æ•°æ®åŒæ­¥**ï¼šRLS ç¡®ä¿å‘é‡æ£€ç´¢ä¹Ÿéµå®ˆæƒé™è§„åˆ™
- **API è®¿é—®æ§åˆ¶**ï¼šå¤–éƒ¨ç³»ç»Ÿé€šè¿‡ API Key è®¿é—®ç‰¹å®šé¡¹ç›®æ•°æ®

#### 4.3ã€ä»£ç åŠ©æ‰‹
- **ä»£ç åº“éš”ç¦»**ï¼šä¸åŒå›¢é˜Ÿçš„ä»£ç ä¸¥æ ¼éš”ç¦»
- **åŠŸèƒ½æƒé™**ï¼šè¯»å–ä»£ç  vs ç”Ÿæˆä»£ç çš„æƒé™åˆ†ç¦»
- **å®¡è®¡è¿½è¸ª**ï¼šæ‰€æœ‰ä»£ç è®¿é—®è¡Œä¸ºçš„å®Œæ•´è®°å½•

## å…­ã€å…³é”®å®è·µäºŒï¼šçŸ¥è¯†åº“ä¸å‘é‡æ£€ç´¢

çŸ¥è¯†åº“æ˜¯ AI åº”ç”¨çš„æ•°æ®åŸºç¡€ï¼Œè€Œå‘é‡æ£€ç´¢åˆ™æ˜¯å®ç°è¯­ä¹‰æœç´¢çš„æ ¸å¿ƒæŠ€æœ¯ã€‚Supabase é€šè¿‡ `pgvector` æ‰©å±•æä¾›äº†ä¼ä¸šçº§çš„å‘é‡æ•°æ®åº“èƒ½åŠ›ï¼Œä¸ä¼ ç»Ÿå…³ç³»æ•°æ®æ— ç¼é›†æˆã€‚

### 1ã€æ•°æ®æ¨¡å‹è®¾è®¡ï¼šä¸‰å±‚æ¶æ„

#### 1.1ã€æ–‡æ¡£å±‚ï¼ˆDocumentsï¼‰
å­˜å‚¨åŸå§‹æ–‡æ¡£çš„å…ƒæ•°æ®å’Œå†…å®¹ï¼š

```sql
CREATE TABLE documents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,

  -- æ–‡æ¡£åŸºæœ¬ä¿¡æ¯
  title TEXT NOT NULL,
  content TEXT, -- åŸå§‹æ–‡æœ¬å†…å®¹
  file_path TEXT, -- Storage ä¸­çš„æ–‡ä»¶è·¯å¾„
  file_type TEXT CHECK (file_type IN ('pdf', 'docx', 'txt', 'md', 'html')),
  file_size BIGINT,

  -- å¤„ç†çŠ¶æ€
  processing_status TEXT DEFAULT 'pending'
    CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed')),
  error_message TEXT,

  -- å…ƒæ•°æ®
  metadata JSONB DEFAULT '{}',
  upload_user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ·»åŠ ç´¢å¼•
CREATE INDEX idx_documents_org_project ON documents(org_id, project_id);
CREATE INDEX idx_documents_status ON documents(processing_status);
CREATE INDEX idx_documents_created_at ON documents(created_at DESC);
```

#### 1.2ã€åˆ†å—å±‚ï¼ˆChunksï¼‰
å°†é•¿æ–‡æ¡£åˆ‡åˆ†ä¸ºé€‚åˆå‘é‡åŒ–çš„ç‰‡æ®µï¼š

```sql
CREATE TABLE chunks (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,

  -- åˆ†å—å†…å®¹
  content TEXT NOT NULL,
  content_hash TEXT UNIQUE, -- ç”¨äºå»é‡
  chunk_index INTEGER NOT NULL, -- åœ¨æ–‡æ¡£ä¸­çš„é¡ºåº

  -- åˆ†å—å…ƒæ•°æ®
  start_offset INTEGER, -- åœ¨åŸæ–‡æ¡£ä¸­çš„èµ·å§‹ä½ç½®
  end_offset INTEGER,   -- åœ¨åŸæ–‡æ¡£ä¸­çš„ç»“æŸä½ç½®
  token_count INTEGER,  -- token æ•°é‡ä¼°ç®—

  -- åˆ†å—ç­–ç•¥å…ƒæ•°æ®
  chunk_strategy JSONB DEFAULT '{}', -- {"method": "recursive", "chunk_size": 1000, "overlap": 200}

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ·»åŠ ç´¢å¼•
CREATE INDEX idx_chunks_document ON chunks(document_id);
CREATE INDEX idx_chunks_hash ON chunks(content_hash);
CREATE UNIQUE INDEX idx_chunks_document_index ON chunks(document_id, chunk_index);
```

#### 1.3ã€å‘é‡å±‚ï¼ˆEmbeddingsï¼‰
å­˜å‚¨å‘é‡è¡¨ç¤ºå’Œæ£€ç´¢ç´¢å¼•ï¼š

```sql
-- å¯ç”¨ pgvector æ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE embeddings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  chunk_id UUID REFERENCES chunks(id) ON DELETE CASCADE,

  -- å‘é‡æ•°æ®
  vector vector(1536), -- OpenAI ada-002 çš„ç»´åº¦
  model_name TEXT NOT NULL DEFAULT 'text-embedding-ada-002',
  model_version TEXT,

  -- å‘é‡å…ƒæ•°æ®
  vector_norm REAL, -- å‘é‡æ¨¡é•¿ï¼Œç”¨äºå½’ä¸€åŒ–æ£€æŸ¥
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å‘é‡ç´¢å¼•ï¼šæ ¹æ®æ•°æ®è§„æ¨¡é€‰æ‹©
-- å°äº 100ä¸‡å‘é‡ï¼šä½¿ç”¨ ivfflat
CREATE INDEX idx_embeddings_vector_ivfflat
ON embeddings USING ivfflat (vector vector_cosine_ops)
WITH (lists = 100);

-- å¤§äº 100ä¸‡å‘é‡ï¼šä½¿ç”¨ hnsw
-- CREATE INDEX idx_embeddings_vector_hnsw
-- ON embeddings USING hnsw (vector vector_cosine_ops)
-- WITH (m = 16, ef_construction = 64);

-- ä¸šåŠ¡ç´¢å¼•
CREATE INDEX idx_embeddings_chunk ON embeddings(chunk_id);
CREATE INDEX idx_embeddings_model ON embeddings(model_name);
```

### 2ã€æ–‡æ¡£å¤„ç†ç®¡é“

#### 2.1ã€æ–‡æ¡£ä¸Šä¼ ä¸é¢„å¤„ç†
é€šè¿‡ Supabase Storage å’Œ Edge Functions æ„å»ºå¤„ç†ç®¡é“ï¼š

```typescript
// Edge Function: document-upload
import { createClient } from '@supabase/supabase-js'

export async function handleDocumentUpload(request: Request) {
  const formData = await request.formData()
  const file = formData.get('file') as File
  const projectId = formData.get('project_id') as string

  // 1. ä¸Šä¼ åˆ° Storage
  const fileName = `${projectId}/${crypto.randomUUID()}-${file.name}`
  const { data: uploadData, error: uploadError } = await supabase.storage
    .from('documents')
    .upload(fileName, file)

  if (uploadError) throw uploadError

  // 2. åˆ›å»ºæ–‡æ¡£è®°å½•
  const { data: document, error: dbError } = await supabase
    .from('documents')
    .insert({
      title: file.name,
      file_path: uploadData.path,
      file_type: getFileType(file.name),
      file_size: file.size,
      project_id: projectId,
      processing_status: 'pending'
    })
    .select()
    .single()

  // 3. è§¦å‘å¼‚æ­¥å¤„ç†
  await triggerDocumentProcessing(document.id)

  return new Response(JSON.stringify(document), { status: 200 })
}
```

#### 2.2ã€æ–‡æœ¬æå–ä¸åˆ†å—
```typescript
// Edge Function: document-processor
export async function processDocument(documentId: string) {
  // 1. è·å–æ–‡æ¡£ä¿¡æ¯
  const { data: document } = await supabase
    .from('documents')
    .select('*')
    .eq('id', documentId)
    .single()

  try {
    // 2. æ›´æ–°çŠ¶æ€ä¸ºå¤„ç†ä¸­
    await supabase
      .from('documents')
      .update({ processing_status: 'processing' })
      .eq('id', documentId)

    // 3. ä» Storage ä¸‹è½½æ–‡ä»¶
    const { data: fileData } = await supabase.storage
      .from('documents')
      .download(document.file_path)

    // 4. æå–æ–‡æœ¬å†…å®¹
    const textContent = await extractText(fileData, document.file_type)

    // 5. æ–‡æœ¬åˆ†å—
    const chunks = await chunkText(textContent, {
      chunkSize: 1000,
      overlap: 200,
      strategy: 'recursive'
    })

    // 6. æ‰¹é‡æ’å…¥åˆ†å—
    const chunkInserts = chunks.map((chunk, index) => ({
      document_id: documentId,
      content: chunk.content,
      content_hash: hashContent(chunk.content),
      chunk_index: index,
      start_offset: chunk.startOffset,
      end_offset: chunk.endOffset,
      token_count: estimateTokens(chunk.content),
      chunk_strategy: { chunkSize: 1000, overlap: 200, strategy: 'recursive' }
    }))

    const { data: insertedChunks } = await supabase
      .from('chunks')
      .insert(chunkInserts)
      .select()

    // 7. è§¦å‘å‘é‡åŒ–
    await triggerEmbeddingGeneration(insertedChunks.map(c => c.id))

    // 8. æ›´æ–°æ–‡æ¡£çŠ¶æ€
    await supabase
      .from('documents')
      .update({
        content: textContent,
        processing_status: 'completed'
      })
      .eq('id', documentId)

  } catch (error) {
    // é”™è¯¯å¤„ç†
    await supabase
      .from('documents')
      .update({
        processing_status: 'failed',
        error_message: error.message
      })
      .eq('id', documentId)
  }
}
```

#### 2.3ã€å‘é‡ç”Ÿæˆä¸å…¥åº“
```typescript
// Edge Function: embedding-generator
export async function generateEmbeddings(chunkIds: string[]) {
  const { data: chunks } = await supabase
    .from('chunks')
    .select('id, content')
    .in('id', chunkIds)

  for (const chunk of chunks) {
    try {
      // è°ƒç”¨ OpenAI Embedding API
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          input: chunk.content,
          model: 'text-embedding-ada-002'
        })
      })

      const embeddingData = await response.json()
      const vector = embeddingData.data[0].embedding

      // è®¡ç®—å‘é‡æ¨¡é•¿ï¼ˆç”¨äºè´¨é‡æ£€æŸ¥ï¼‰
      const vectorNorm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0))

      // æ’å…¥å‘é‡æ•°æ®
      await supabase
        .from('embeddings')
        .insert({
          chunk_id: chunk.id,
          vector: vector,
          model_name: 'text-embedding-ada-002',
          vector_norm: vectorNorm
        })

    } catch (error) {
      console.error(`Failed to generate embedding for chunk ${chunk.id}:`, error)
    }
  }
}
```

### 3ã€è¯­ä¹‰æ£€ç´¢å®ç°

#### 3.1ã€åŸºç¡€ç›¸ä¼¼åº¦æœç´¢
```sql
-- åˆ›å»ºç›¸ä¼¼åº¦æœç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION search_similar_chunks(
  query_embedding vector(1536),
  match_threshold float DEFAULT 0.8,
  match_count int DEFAULT 10,
  target_org_id uuid DEFAULT NULL,
  target_project_id uuid DEFAULT NULL
)
RETURNS TABLE (
  chunk_id uuid,
  document_id uuid,
  content text,
  similarity float,
  document_title text
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id as chunk_id,
    c.document_id,
    c.content,
    1 - (e.vector <=> query_embedding) as similarity,
    d.title as document_title
  FROM chunks c
  JOIN embeddings e ON c.id = e.chunk_id
  JOIN documents d ON c.document_id = d.id
  WHERE
    1 - (e.vector <=> query_embedding) > match_threshold
    AND (target_org_id IS NULL OR d.org_id = target_org_id)
    AND (target_project_id IS NULL OR d.project_id = target_project_id)
  ORDER BY e.vector <=> query_embedding
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql;
```

#### 3.2ã€å¸¦æƒé™æ§åˆ¶çš„æ£€ç´¢
```sql
-- å¸¦ RLS çš„æœç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION search_with_permissions(
  query_embedding vector(1536),
  match_threshold float DEFAULT 0.8,
  match_count int DEFAULT 10
)
RETURNS TABLE (
  chunk_id uuid,
  content text,
  similarity float,
  document_title text
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id as chunk_id,
    c.content,
    1 - (e.vector <=> query_embedding) as similarity,
    d.title as document_title
  FROM chunks c
  JOIN embeddings e ON c.id = e.chunk_id
  JOIN documents d ON c.document_id = d.id
  WHERE
    1 - (e.vector <=> query_embedding) > match_threshold
    AND check_user_role(d.org_id, 'viewer') -- ç¡®ä¿ç”¨æˆ·æœ‰æƒé™è®¿é—®
  ORDER BY e.vector <=> query_embedding
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### 3.3ã€æ··åˆæ£€ç´¢ï¼šå‘é‡ + å…³é”®è¯
```sql
-- æ··åˆæ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION hybrid_search(
  query_text text,
  query_embedding vector(1536),
  match_count int DEFAULT 10,
  semantic_weight float DEFAULT 0.7,
  keyword_weight float DEFAULT 0.3
)
RETURNS TABLE (
  chunk_id uuid,
  content text,
  combined_score float,
  semantic_similarity float,
  keyword_score float
) AS $$
BEGIN
  RETURN QUERY
  WITH semantic_results AS (
    SELECT
      c.id as chunk_id,
      c.content,
      1 - (e.vector <=> query_embedding) as similarity
    FROM chunks c
    JOIN embeddings e ON c.id = e.chunk_id
    JOIN documents d ON c.document_id = d.id
    WHERE check_user_role(d.org_id, 'viewer')
    ORDER BY e.vector <=> query_embedding
    LIMIT match_count * 2
  ),
  keyword_results AS (
    SELECT
      c.id as chunk_id,
      c.content,
      ts_rank(to_tsvector('english', c.content), plainto_tsquery('english', query_text)) as rank
    FROM chunks c
    JOIN documents d ON c.document_id = d.id
    WHERE
      to_tsvector('english', c.content) @@ plainto_tsquery('english', query_text)
      AND check_user_role(d.org_id, 'viewer')
    ORDER BY rank DESC
    LIMIT match_count * 2
  )
  SELECT
    COALESCE(s.chunk_id, k.chunk_id) as chunk_id,
    COALESCE(s.content, k.content) as content,
    (COALESCE(s.similarity, 0) * semantic_weight + COALESCE(k.rank, 0) * keyword_weight) as combined_score,
    COALESCE(s.similarity, 0) as semantic_similarity,
    COALESCE(k.rank, 0) as keyword_score
  FROM semantic_results s
  FULL OUTER JOIN keyword_results k ON s.chunk_id = k.chunk_id
  ORDER BY combined_score DESC
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 4ã€ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

#### 4.1ã€å‘é‡ç´¢å¼•é€‰æ‹©
```sql
-- æ ¹æ®æ•°æ®è§„æ¨¡åŠ¨æ€è°ƒæ•´ç´¢å¼•å‚æ•°
DO $$
DECLARE
    vector_count bigint;
BEGIN
    SELECT COUNT(*) INTO vector_count FROM embeddings;

    IF vector_count < 100000 THEN
        -- å°è§„æ¨¡ï¼šä½¿ç”¨ ivfflatï¼Œlists = sqrt(vector_count)
        DROP INDEX IF EXISTS idx_embeddings_vector_hnsw;
        CREATE INDEX IF NOT EXISTS idx_embeddings_vector_ivfflat
        ON embeddings USING ivfflat (vector vector_cosine_ops)
        WITH (lists = GREATEST(10, LEAST(100, SQRT(vector_count)::int)));
    ELSE
        -- å¤§è§„æ¨¡ï¼šä½¿ç”¨ hnsw
        DROP INDEX IF EXISTS idx_embeddings_vector_ivfflat;
        CREATE INDEX IF NOT EXISTS idx_embeddings_vector_hnsw
        ON embeddings USING hnsw (vector vector_cosine_ops)
        WITH (m = 16, ef_construction = 64);
    END IF;
END $$;
```

#### 4.2ã€ç´¢å¼•ç»´æŠ¤ç­–ç•¥
```sql
-- å®šæœŸé‡å»ºç´¢å¼•ï¼ˆåœ¨ä½å³°æœŸæ‰§è¡Œï¼‰
CREATE OR REPLACE FUNCTION rebuild_vector_index()
RETURNS void AS $$
BEGIN
  -- é‡å»ºç´¢å¼•å‰å…ˆåˆ†æè¡¨ç»Ÿè®¡ä¿¡æ¯
  ANALYZE embeddings;

  -- å¹¶å‘é‡å»ºç´¢å¼•
  REINDEX INDEX CONCURRENTLY idx_embeddings_vector_ivfflat;

  -- æ›´æ–°è¡¨ç»Ÿè®¡ä¿¡æ¯
  ANALYZE embeddings;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºå®šæ—¶ä»»åŠ¡ï¼ˆéœ€è¦ pg_cron æ‰©å±•ï¼‰
-- SELECT cron.schedule('rebuild-vector-index', '0 2 * * 0', 'SELECT rebuild_vector_index();');
```

### 5ã€è´¨é‡ç›‘æ§ä¸ä¼˜åŒ–

#### 5.1ã€æ£€ç´¢è´¨é‡æŒ‡æ ‡
```sql
-- åˆ›å»ºæ£€ç´¢æ—¥å¿—è¡¨
CREATE TABLE search_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  org_id UUID REFERENCES organizations(id),
  query_text TEXT,
  query_embedding vector(1536),
  results JSONB, -- è¿”å›çš„ç»“æœåˆ—è¡¨
  result_count INTEGER,
  search_time_ms INTEGER,
  clicked_results JSONB DEFAULT '[]', -- ç”¨æˆ·ç‚¹å‡»çš„ç»“æœ
  rating INTEGER CHECK (rating BETWEEN 1 AND 5), -- ç”¨æˆ·è¯„åˆ†
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ£€ç´¢è´¨é‡åˆ†æè§†å›¾
CREATE VIEW search_quality_metrics AS
SELECT
  DATE_TRUNC('day', created_at) as date,
  org_id,
  COUNT(*) as total_searches,
  AVG(result_count) as avg_results,
  AVG(search_time_ms) as avg_search_time,
  AVG(rating) as avg_rating,
  AVG(JSONB_ARRAY_LENGTH(clicked_results)) as avg_clicks
FROM search_logs
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE_TRUNC('day', created_at), org_id
ORDER BY date DESC;
```

#### 5.2ã€å‘é‡è´¨é‡æ£€æŸ¥
```sql
-- æ£€æŸ¥å‘é‡è´¨é‡
CREATE OR REPLACE FUNCTION check_vector_quality()
RETURNS TABLE (
  model_name text,
  total_vectors bigint,
  avg_norm float,
  zero_vectors bigint,
  invalid_vectors bigint
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.model_name,
    COUNT(*) as total_vectors,
    AVG(e.vector_norm) as avg_norm,
    COUNT(*) FILTER (WHERE e.vector_norm = 0) as zero_vectors,
    COUNT(*) FILTER (WHERE e.vector_norm IS NULL OR e.vector_norm < 0.1) as invalid_vectors
  FROM embeddings e
  GROUP BY e.model_name;
END;
$$ LANGUAGE plpgsql;
```

è¿™ä¸ªå‘é‡æ£€ç´¢ç³»ç»Ÿæä¾›äº†ï¼š
- **ä¼ä¸šçº§æ•°æ®éš”ç¦»**ï¼šé€šè¿‡ RLS ç¡®ä¿ç§Ÿæˆ·é—´æ•°æ®å®‰å…¨
- **é«˜æ€§èƒ½æ£€ç´¢**ï¼šå‘é‡ç´¢å¼• + æ··åˆæœç´¢
- **å¯è§‚æµ‹æ€§**ï¼šè´¨é‡ç›‘æ§å’Œæ€§èƒ½æŒ‡æ ‡
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒä»å°è§„æ¨¡åˆ°å¤§è§„æ¨¡çš„å¹³æ»‘æ‰©å±•

## ä¸ƒã€å…³é”®å®è·µä¸‰ï¼šæµå¼æ¨ç†æ¥å£

AI åº”ç”¨çš„ç”¨æˆ·ä½“éªŒæ ¸å¿ƒåœ¨äº"æ„ŸçŸ¥æ™ºèƒ½"ï¼Œè€Œæµå¼è¾“å‡ºæ˜¯å®ç°è¿™ç§ä½“éªŒçš„å…³é”®æŠ€æœ¯ã€‚Supabase çš„ Edge Functions + Realtime ç»„åˆä¸ºæ„å»ºæµå¼ AI æ¥å£æä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆã€‚

### 1ã€æµå¼æ¶æ„è®¾è®¡

#### 1.1ã€SSE (Server-Sent Events) å®ç°
Edge Functions å¤©ç„¶æ”¯æŒæµå¼å“åº”ï¼Œé€‚åˆç®€å•çš„å•å‘æ•°æ®æµï¼š

```typescript
// Edge Function: chat-stream
export async function handleChatStream(request: Request) {
  const { message, conversationId, projectId } = await request.json()

  // åˆ›å»ºæµå¼å“åº”
  const stream = new ReadableStream({
    async start(controller) {
      try {
        // 1. è®°å½•ç”¨æˆ·æ¶ˆæ¯
        const userMessage = await saveMessage({
          conversationId,
          role: 'user',
          content: message,
          projectId
        })

        // 2. åˆ›å»ºåŠ©æ‰‹æ¶ˆæ¯å ä½ç¬¦
        const assistantMessage = await saveMessage({
          conversationId,
          role: 'assistant',
          content: '',
          projectId,
          status: 'streaming'
        })

        // 3. è°ƒç”¨ AI æœåŠ¡ï¼ˆOpenAI/Anthropicï¼‰
        const completion = await openai.chat.completions.create({
          model: 'gpt-4',
          messages: await buildMessageHistory(conversationId),
          stream: true,
          temperature: 0.7,
        })

        let fullContent = ''

        // 4. æµå¼å¤„ç† AI å“åº”
        for await (const chunk of completion) {
          const delta = chunk.choices[0]?.delta?.content || ''

          if (delta) {
            fullContent += delta

            // å‘é€å¢é‡å†…å®¹
            const data = JSON.stringify({
              type: 'content_delta',
              messageId: assistantMessage.id,
              delta: delta,
              fullContent: fullContent
            })

            controller.enqueue(new TextEncoder().encode(`data: ${data}\n\n`))

            // å®šæœŸæ›´æ–°æ•°æ®åº“ï¼ˆæ¯100ä¸ªå­—ç¬¦æˆ–æ¯2ç§’ï¼‰
            if (fullContent.length % 100 === 0) {
              await updateMessage(assistantMessage.id, {
                content: fullContent,
                updated_at: new Date().toISOString()
              })
            }
          }
        }

        // 5. å®Œæˆæµå¼ä¼ è¾“
        await updateMessage(assistantMessage.id, {
          content: fullContent,
          status: 'completed',
          token_count: estimateTokens(fullContent)
        })

        // 6. è®°å½•ç”¨é‡äº‹ä»¶
        await recordUsageEvent({
          conversationId,
          userId: userMessage.user_id,
          projectId,
          inputTokens: estimateTokens(message),
          outputTokens: estimateTokens(fullContent),
          model: 'gpt-4'
        })

        controller.enqueue(new TextEncoder().encode(`data: {"type": "done"}\n\n`))
        controller.close()

      } catch (error) {
        console.error('Stream error:', error)
        controller.enqueue(
          new TextEncoder().encode(`data: {"type": "error", "message": "${error.message}"}\n\n`)
        )
        controller.close()
      }
    }
  })

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  })
}
```

#### 1.2ã€WebSocket + Realtime å®ç°
å¯¹äºéœ€è¦åŒå‘é€šä¿¡çš„å¤æ‚åœºæ™¯ï¼Œä½¿ç”¨ Supabase Realtimeï¼š

```typescript
// å‰ç«¯ï¼šå»ºç«‹ Realtime è¿æ¥
const setupRealtimeChat = (conversationId: string) => {
  const channel = supabase
    .channel(`conversation:${conversationId}`)
    .on('postgres_changes', {
      event: 'UPDATE',
      schema: 'public',
      table: 'messages',
      filter: `conversation_id=eq.${conversationId}`
    }, (payload) => {
      handleMessageUpdate(payload.new)
    })
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'messages',
      filter: `conversation_id=eq.${conversationId}`
    }, (payload) => {
      handleNewMessage(payload.new)
    })
    .subscribe()

  return channel
}

// å¤„ç†æ¶ˆæ¯æ›´æ–°
const handleMessageUpdate = (message: any) => {
  if (message.status === 'streaming') {
    // æµå¼æ›´æ–°æ¶ˆæ¯å†…å®¹
    updateMessageInUI(message.id, message.content)
  } else if (message.status === 'completed') {
    // æ¶ˆæ¯å®Œæˆï¼Œæ›´æ–° UI çŠ¶æ€
    markMessageComplete(message.id)
  }
}
```

#### 1.3ã€æ··åˆæ–¹æ¡ˆï¼šSSE + DB æ¨é€
ç»“åˆ SSE çš„ä½å»¶è¿Ÿå’Œæ•°æ®åº“çš„æŒä¹…åŒ–ï¼š

```typescript
// Edge Function: hybrid-chat
export async function handleHybridChat(request: Request) {
  const { message, conversationId } = await request.json()

  const stream = new ReadableStream({
    async start(controller) {
      let buffer = ''
      let lastDbUpdate = Date.now()

      for await (const chunk of aiCompletion) {
        const delta = chunk.choices[0]?.delta?.content || ''
        buffer += delta

        // ç«‹å³æ¨é€åˆ°å®¢æˆ·ç«¯
        controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify({
          type: 'delta',
          content: delta
        })}\n\n`))

        // æ¯500msæˆ–ç´¯ç§¯100å­—ç¬¦æ—¶æ›´æ–°æ•°æ®åº“
        const now = Date.now()
        if (now - lastDbUpdate > 500 || buffer.length % 100 === 0) {
          await updateMessageContent(messageId, buffer)
          lastDbUpdate = now

          // è§¦å‘ Realtime æ›´æ–°
          await supabase
            .from('message_updates')
            .insert({
              message_id: messageId,
              content: buffer,
              timestamp: new Date().toISOString()
            })
        }
      }
    }
  })
}
```

### 2ã€æ•°æ®æ¨¡å‹ï¼šå¯¹è¯ä¸æ¶ˆæ¯

#### 2.1ã€å¯¹è¯è¡¨
```sql
CREATE TABLE conversations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  title TEXT,
  system_prompt TEXT,
  model_config JSONB DEFAULT '{}', -- {"model": "gpt-4", "temperature": 0.7}

  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deleted')),
  message_count INTEGER DEFAULT 0,
  total_tokens INTEGER DEFAULT 0,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ·»åŠ ç´¢å¼•
CREATE INDEX idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
CREATE INDEX idx_conversations_project ON conversations(project_id);
```

#### 2.2ã€æ¶ˆæ¯è¡¨
```sql
CREATE TABLE messages (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,

  role TEXT NOT NULL CHECK (role IN ('system', 'user', 'assistant', 'tool')),
  content TEXT NOT NULL,
  content_type TEXT DEFAULT 'text' CHECK (content_type IN ('text', 'image', 'audio', 'file')),

  -- æµå¼çŠ¶æ€
  status TEXT DEFAULT 'completed' CHECK (status IN ('pending', 'streaming', 'completed', 'failed')),
  stream_position INTEGER DEFAULT 0, -- æµå¼è¾“å‡ºçš„å½“å‰ä½ç½®

  -- AI ç›¸å…³å…ƒæ•°æ®
  model_name TEXT,
  token_count INTEGER,
  finish_reason TEXT,
  tool_calls JSONB,

  -- å¼•ç”¨ä¸å…³è”
  parent_message_id UUID REFERENCES messages(id),
  references JSONB DEFAULT '[]', -- å¼•ç”¨çš„æ–‡æ¡£/ä»£ç ç‰‡æ®µ

  -- è´¨é‡æ§åˆ¶
  rating INTEGER CHECK (rating BETWEEN 1 AND 5),
  feedback TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ·»åŠ ç´¢å¼•
CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at);
CREATE INDEX idx_messages_status ON messages(status) WHERE status != 'completed';
CREATE INDEX idx_messages_streaming ON messages(conversation_id, stream_position) WHERE status = 'streaming';
```

### 3ã€å®¹é”™ä¸é‡è¯•æœºåˆ¶

#### 3.1ã€å¹‚ç­‰æ€§ä¿è¯
```typescript
// ä½¿ç”¨å¹‚ç­‰é”®é˜²æ­¢é‡å¤å¤„ç†
export async function handleChatWithIdempotency(request: Request) {
  const idempotencyKey = request.headers.get('Idempotency-Key')
  if (!idempotencyKey) {
    throw new Error('Idempotency-Key header required')
  }

  // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
  const existing = await supabase
    .from('idempotency_keys')
    .select('response_data, status')
    .eq('key', idempotencyKey)
    .single()

  if (existing.data) {
    if (existing.data.status === 'completed') {
      // è¿”å›ç¼“å­˜çš„ç»“æœ
      return new Response(existing.data.response_data)
    } else if (existing.data.status === 'processing') {
      // æ­£åœ¨å¤„ç†ä¸­ï¼Œè¿”å› 409
      return new Response('Request is being processed', { status: 409 })
    }
  }

  // è®°å½•å¤„ç†å¼€å§‹
  await supabase
    .from('idempotency_keys')
    .upsert({
      key: idempotencyKey,
      status: 'processing',
      created_at: new Date().toISOString()
    })

  try {
    const result = await processChatRequest(request)

    // è®°å½•æˆåŠŸç»“æœ
    await supabase
      .from('idempotency_keys')
      .update({
        status: 'completed',
        response_data: await result.text(),
        completed_at: new Date().toISOString()
      })
      .eq('key', idempotencyKey)

    return result
  } catch (error) {
    // è®°å½•å¤±è´¥çŠ¶æ€
    await supabase
      .from('idempotency_keys')
      .update({
        status: 'failed',
        error_message: error.message,
        failed_at: new Date().toISOString()
      })
      .eq('key', idempotencyKey)

    throw error
  }
}
```

#### 3.2ã€æ–­ç‚¹ç»­ä¼ 
```typescript
// æ”¯æŒé•¿å“åº”çš„æ–­ç‚¹ç»­ä¼ 
export async function resumeStreamingMessage(messageId: string) {
  const { data: message } = await supabase
    .from('messages')
    .select('content, stream_position, conversation_id')
    .eq('id', messageId)
    .single()

  if (message.status !== 'streaming') {
    throw new Error('Message is not in streaming state')
  }

  // ä»ä¸­æ–­ä½ç½®ç»§ç»­ç”Ÿæˆ
  const completion = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: await buildMessageHistory(message.conversation_id),
    stream: true,
    // ä¼ é€’å·²ç”Ÿæˆçš„å†…å®¹ä½œä¸º context
    prompt: message.content,
    continue_from: message.stream_position
  })

  // ç»§ç»­æµå¼å¤„ç†...
}
```

### 4ã€æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 4.1ã€è¿æ¥æ± ç®¡ç†
```typescript
// Edge Functions ä¸­çš„è¿æ¥å¤ç”¨
const aiClientPool = new Map<string, OpenAI>()

function getAIClient(apiKey: string): OpenAI {
  if (!aiClientPool.has(apiKey)) {
    aiClientPool.set(apiKey, new OpenAI({
      apiKey,
      maxRetries: 3,
      timeout: 30000
    }))
  }
  return aiClientPool.get(apiKey)!
}
```

#### 4.2ã€åˆ†å—ä¼ è¾“ä¼˜åŒ–
```typescript
// æ™ºèƒ½åˆ†å—ç­–ç•¥
function createChunkedStream(content: string) {
  return new ReadableStream({
    start(controller) {
      const sentences = content.split(/[.!?]+/)

      for (const sentence of sentences) {
        // æŒ‰å¥å­åˆ†å—ï¼Œæå‡é˜…è¯»ä½“éªŒ
        controller.enqueue(new TextEncoder().encode(
          `data: ${JSON.stringify({ delta: sentence + '. ' })}\n\n`
        ))

        // å¥å­é—´æ·»åŠ å°å»¶è¿Ÿï¼Œæ¨¡æ‹Ÿæ€è€ƒè¿‡ç¨‹
        await new Promise(resolve => setTimeout(resolve, 50))
      }

      controller.close()
    }
  })
}
```

#### 4.3ã€ç¼“å­˜ç­–ç•¥
```typescript
// å“åº”ç¼“å­˜ï¼ˆç›¸åŒé—®é¢˜çš„å¿«é€Ÿå“åº”ï¼‰
export async function getCachedResponse(
  messageHistory: Message[],
  cacheKey: string
) {
  const { data: cached } = await supabase
    .from('response_cache')
    .select('response, created_at')
    .eq('cache_key', cacheKey)
    .gte('created_at', new Date(Date.now() - 3600000).toISOString()) // 1å°æ—¶å†…æœ‰æ•ˆ
    .single()

  if (cached) {
    return cached.response
  }

  // ç”Ÿæˆæ–°å“åº”å¹¶ç¼“å­˜
  const response = await generateAIResponse(messageHistory)

  await supabase
    .from('response_cache')
    .insert({
      cache_key: cacheKey,
      response: response,
      expires_at: new Date(Date.now() + 3600000).toISOString()
    })

  return response
}
```

## å…«ã€å…³é”®å®è·µå››ï¼šç”¨é‡ç»Ÿè®¡ä¸é…é¢

AI åº”ç”¨çš„å•†ä¸šæ¨¡å¼å¾€å¾€åŸºäºä½¿ç”¨é‡è®¡è´¹ï¼Œç²¾ç¡®çš„ç”¨é‡ç»Ÿè®¡å’Œçµæ´»çš„é…é¢ç®¡ç†æ˜¯äº§å“æˆåŠŸçš„å…³é”®ã€‚Supabase çš„äº‹åŠ¡èƒ½åŠ›å’Œå®æ—¶ç‰¹æ€§ä¸ºæ„å»ºä¼ä¸šçº§è®¡è´¹ç³»ç»Ÿæä¾›äº†åšå®åŸºç¡€ã€‚

### 1ã€ç”¨é‡äº‹ä»¶æ¨¡å‹

#### 1.1ã€äº‹ä»¶é©±åŠ¨æ¶æ„
```sql
-- ç”¨é‡äº‹ä»¶è¡¨ï¼šè®°å½•æ‰€æœ‰å¯è®¡è´¹çš„æ“ä½œ
CREATE TABLE usage_events (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- ç§Ÿæˆ·ä¿¡æ¯
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- äº‹ä»¶åˆ†ç±»
  event_type TEXT NOT NULL, -- 'chat_completion', 'embedding', 'document_processing', 'api_call'
  event_subtype TEXT, -- 'gpt-4', 'gpt-3.5-turbo', 'text-embedding-ada-002'

  -- ç”¨é‡æ•°æ®
  input_tokens INTEGER DEFAULT 0,
  output_tokens INTEGER DEFAULT 0,
  total_tokens INTEGER GENERATED ALWAYS AS (input_tokens + output_tokens) STORED,

  -- æˆæœ¬è®¡ç®—
  input_cost DECIMAL(10,6) DEFAULT 0, -- ç²¾ç¡®åˆ°å¾®åˆ†
  output_cost DECIMAL(10,6) DEFAULT 0,
  total_cost DECIMAL(10,6) GENERATED ALWAYS AS (input_cost + output_cost) STORED,

  -- ä¸Šä¸‹æ–‡ä¿¡æ¯
  conversation_id UUID REFERENCES conversations(id),
  message_id UUID REFERENCES messages(id),
  document_id UUID REFERENCES documents(id),

  -- å…ƒæ•°æ®
  model_config JSONB,
  processing_time_ms INTEGER,
  error_message TEXT,

  -- æ—¶é—´ä¿¡æ¯
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ†åŒºè¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼Œæå‡æŸ¥è¯¢æ€§èƒ½ï¼‰
CREATE TABLE usage_events_y2024m01 PARTITION OF usage_events
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE usage_events_y2024m02 PARTITION OF usage_events
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
-- ... ç»§ç»­åˆ›å»ºå…¶ä»–æœˆä»½åˆ†åŒº

-- é«˜æ€§èƒ½ç´¢å¼•
CREATE INDEX idx_usage_events_org_time ON usage_events(org_id, created_at DESC);
CREATE INDEX idx_usage_events_user_time ON usage_events(user_id, created_at DESC);
CREATE INDEX idx_usage_events_project_time ON usage_events(project_id, created_at DESC);
CREATE INDEX idx_usage_events_type_time ON usage_events(event_type, created_at DESC);
```

#### 1.2ã€å®šä»·æ¨¡å‹é…ç½®
```sql
-- å®šä»·è§„åˆ™è¡¨
CREATE TABLE pricing_rules (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- è§„åˆ™æ ‡è¯†
  rule_name TEXT UNIQUE NOT NULL,
  event_type TEXT NOT NULL,
  event_subtype TEXT,

  -- å®šä»·ç­–ç•¥
  pricing_model TEXT NOT NULL CHECK (pricing_model IN ('per_token', 'per_request', 'per_duration', 'tiered')),

  -- åŸºç¡€ä»·æ ¼ï¼ˆæ¯åƒ token çš„ä»·æ ¼ï¼‰
  base_input_price DECIMAL(10,6) DEFAULT 0,
  base_output_price DECIMAL(10,6) DEFAULT 0,

  -- é˜¶æ¢¯å®šä»·
  tiers JSONB, -- [{"from": 0, "to": 10000, "multiplier": 1.0}, {"from": 10000, "to": 100000, "multiplier": 0.9}]

  -- æ—¶é—´æœ‰æ•ˆæ€§
  effective_from TIMESTAMPTZ DEFAULT NOW(),
  effective_to TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥å®šä»·è§„åˆ™ç¤ºä¾‹
INSERT INTO pricing_rules (rule_name, event_type, event_subtype, pricing_model, base_input_price, base_output_price) VALUES
('gpt-4-standard', 'chat_completion', 'gpt-4', 'per_token', 0.00003, 0.00006),
('gpt-3.5-standard', 'chat_completion', 'gpt-3.5-turbo', 'per_token', 0.000001, 0.000002),
('embedding-ada-002', 'embedding', 'text-embedding-ada-002', 'per_token', 0.0000001, 0);
```

#### 1.3ã€å®æ—¶æˆæœ¬è®¡ç®—
```sql
-- æˆæœ¬è®¡ç®—å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_usage_cost(
  p_event_type TEXT,
  p_event_subtype TEXT,
  p_input_tokens INTEGER,
  p_output_tokens INTEGER,
  p_org_id UUID DEFAULT NULL
) RETURNS TABLE (
  input_cost DECIMAL(10,6),
  output_cost DECIMAL(10,6),
  total_cost DECIMAL(10,6)
) AS $$
DECLARE
  pricing_rule RECORD;
  monthly_usage BIGINT;
  tier_multiplier DECIMAL(4,3) := 1.0;
BEGIN
  -- è·å–é€‚ç”¨çš„å®šä»·è§„åˆ™
  SELECT * INTO pricing_rule
  FROM pricing_rules
  WHERE event_type = p_event_type
    AND (event_subtype IS NULL OR event_subtype = p_event_subtype)
    AND effective_from <= NOW()
    AND (effective_to IS NULL OR effective_to > NOW())
  ORDER BY effective_from DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'No pricing rule found for event_type: %, event_subtype: %', p_event_type, p_event_subtype;
  END IF;

  -- è®¡ç®—é˜¶æ¢¯å®šä»·å€æ•°
  IF pricing_rule.pricing_model = 'tiered' AND p_org_id IS NOT NULL THEN
    SELECT COALESCE(SUM(total_tokens), 0) INTO monthly_usage
    FROM usage_events
    WHERE org_id = p_org_id
      AND event_type = p_event_type
      AND created_at >= DATE_TRUNC('month', NOW());

    -- æ ¹æ®æœˆåº¦ç”¨é‡ç¡®å®šé˜¶æ¢¯å€æ•°
    SELECT COALESCE(
      (SELECT (tier->>'multiplier')::DECIMAL
       FROM jsonb_array_elements(pricing_rule.tiers) AS tier
       WHERE monthly_usage >= (tier->>'from')::BIGINT
         AND (tier->>'to' IS NULL OR monthly_usage < (tier->>'to')::BIGINT)
       LIMIT 1), 1.0
    ) INTO tier_multiplier;
  END IF;

  -- è®¡ç®—æœ€ç»ˆæˆæœ¬
  RETURN QUERY SELECT
    (p_input_tokens * pricing_rule.base_input_price * tier_multiplier / 1000)::DECIMAL(10,6),
    (p_output_tokens * pricing_rule.base_output_price * tier_multiplier / 1000)::DECIMAL(10,6),
    ((p_input_tokens * pricing_rule.base_input_price + p_output_tokens * pricing_rule.base_output_price) * tier_multiplier / 1000)::DECIMAL(10,6);
END;
$$ LANGUAGE plpgsql;
```

### 2ã€é…é¢ç®¡ç†ç³»ç»Ÿ

#### 2.1ã€é…é¢é…ç½®
```sql
-- é…é¢è§„åˆ™è¡¨
CREATE TABLE quota_rules (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- é€‚ç”¨èŒƒå›´
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- é…é¢ç±»å‹
  quota_type TEXT NOT NULL, -- 'tokens', 'requests', 'cost', 'concurrent'
  event_type TEXT, -- é™åˆ¶ç‰¹å®šäº‹ä»¶ç±»å‹

  -- é…é¢é™åˆ¶
  quota_limit BIGINT NOT NULL,
  quota_period TEXT NOT NULL CHECK (quota_period IN ('minute', 'hour', 'day', 'month')),

  -- é‡ç½®ç­–ç•¥
  reset_schedule TEXT, -- cron è¡¨è¾¾å¼
  carry_over BOOLEAN DEFAULT FALSE, -- æ˜¯å¦å…è®¸æœªç”¨å®Œçš„é…é¢ç»“è½¬

  -- è¶…é™è¡Œä¸º
  enforcement_action TEXT DEFAULT 'block' CHECK (enforcement_action IN ('block', 'warn', 'throttle')),

  -- æ—¶é—´æœ‰æ•ˆæ€§
  effective_from TIMESTAMPTZ DEFAULT NOW(),
  effective_to TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é…é¢ä½¿ç”¨è®°å½•
CREATE TABLE quota_usage (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  quota_rule_id UUID REFERENCES quota_rules(id) ON DELETE CASCADE,

  -- ä½¿ç”¨æƒ…å†µ
  period_start TIMESTAMPTZ NOT NULL,
  period_end TIMESTAMPTZ NOT NULL,
  current_usage BIGINT DEFAULT 0,
  quota_limit BIGINT NOT NULL,

  -- çŠ¶æ€
  is_exceeded BOOLEAN DEFAULT FALSE,
  last_reset_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### 2.2ã€å®æ—¶é…é¢æ£€æŸ¥
```sql
-- é…é¢æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_quota_limits(
  p_org_id UUID,
  p_project_id UUID DEFAULT NULL,
  p_user_id UUID DEFAULT NULL,
  p_event_type TEXT DEFAULT NULL,
  p_requested_amount BIGINT DEFAULT 1
) RETURNS TABLE (
  is_allowed BOOLEAN,
  quota_type TEXT,
  current_usage BIGINT,
  quota_limit BIGINT,
  remaining BIGINT
) AS $$
DECLARE
  quota_rule RECORD;
  current_period_start TIMESTAMPTZ;
  current_period_end TIMESTAMPTZ;
  usage_amount BIGINT;
BEGIN
  -- æ£€æŸ¥æ‰€æœ‰é€‚ç”¨çš„é…é¢è§„åˆ™
  FOR quota_rule IN
    SELECT qr.* FROM quota_rules qr
    WHERE (qr.org_id = p_org_id OR qr.org_id IS NULL)
      AND (qr.project_id = p_project_id OR qr.project_id IS NULL)
      AND (qr.user_id = p_user_id OR qr.user_id IS NULL)
      AND (qr.event_type = p_event_type OR qr.event_type IS NULL)
      AND qr.effective_from <= NOW()
      AND (qr.effective_to IS NULL OR qr.effective_to > NOW())
    ORDER BY
      CASE WHEN qr.user_id IS NOT NULL THEN 1 ELSE 2 END,
      CASE WHEN qr.project_id IS NOT NULL THEN 1 ELSE 2 END,
      CASE WHEN qr.org_id IS NOT NULL THEN 1 ELSE 2 END
  LOOP
    -- è®¡ç®—å½“å‰å‘¨æœŸ
    CASE quota_rule.quota_period
      WHEN 'minute' THEN
        current_period_start := DATE_TRUNC('minute', NOW());
        current_period_end := current_period_start + INTERVAL '1 minute';
      WHEN 'hour' THEN
        current_period_start := DATE_TRUNC('hour', NOW());
        current_period_end := current_period_start + INTERVAL '1 hour';
      WHEN 'day' THEN
        current_period_start := DATE_TRUNC('day', NOW());
        current_period_end := current_period_start + INTERVAL '1 day';
      WHEN 'month' THEN
        current_period_start := DATE_TRUNC('month', NOW());
        current_period_end := current_period_start + INTERVAL '1 month';
    END CASE;

    -- è·å–å½“å‰å‘¨æœŸä½¿ç”¨é‡
    SELECT
      CASE quota_rule.quota_type
        WHEN 'tokens' THEN COALESCE(SUM(total_tokens), 0)
        WHEN 'requests' THEN COUNT(*)
        WHEN 'cost' THEN COALESCE(SUM(total_cost * 1000000), 0)::BIGINT -- è½¬æ¢ä¸ºå¾®åˆ†
        ELSE 0
      END
    INTO usage_amount
    FROM usage_events ue
    WHERE ue.created_at >= current_period_start
      AND ue.created_at < current_period_end
      AND (quota_rule.org_id IS NULL OR ue.org_id = quota_rule.org_id)
      AND (quota_rule.project_id IS NULL OR ue.project_id = quota_rule.project_id)
      AND (quota_rule.user_id IS NULL OR ue.user_id = quota_rule.user_id)
      AND (quota_rule.event_type IS NULL OR ue.event_type = quota_rule.event_type);

    -- æ£€æŸ¥æ˜¯å¦è¶…é™
    IF usage_amount + p_requested_amount > quota_rule.quota_limit THEN
      RETURN QUERY SELECT
        FALSE,
        quota_rule.quota_type,
        usage_amount,
        quota_rule.quota_limit,
        GREATEST(0, quota_rule.quota_limit - usage_amount);
      RETURN;
    END IF;
  END LOOP;

  -- æ‰€æœ‰é…é¢æ£€æŸ¥é€šè¿‡
  RETURN QUERY SELECT TRUE, ''::TEXT, 0::BIGINT, 0::BIGINT, 0::BIGINT;
END;
$$ LANGUAGE plpgsql;
```

### 3ã€èšåˆè§†å›¾ä¸æŠ¥è¡¨

#### 3.1ã€å®æ—¶ä½¿ç”¨é‡ç»Ÿè®¡
```sql
-- ç»„ç»‡çº§ä½¿ç”¨é‡è§†å›¾
CREATE VIEW org_usage_summary AS
SELECT
  ue.org_id,
  o.name as org_name,
  DATE_TRUNC('day', ue.created_at) as usage_date,
  ue.event_type,
  COUNT(*) as request_count,
  SUM(ue.input_tokens) as total_input_tokens,
  SUM(ue.output_tokens) as total_output_tokens,
  SUM(ue.total_tokens) as total_tokens,
  SUM(ue.total_cost) as total_cost,
  AVG(ue.processing_time_ms) as avg_processing_time
FROM usage_events ue
JOIN organizations o ON ue.org_id = o.id
WHERE ue.created_at >= NOW() - INTERVAL '30 days'
GROUP BY ue.org_id, o.name, DATE_TRUNC('day', ue.created_at), ue.event_type
ORDER BY usage_date DESC, total_cost DESC;

-- ç”¨æˆ·çº§ä½¿ç”¨é‡è§†å›¾
CREATE VIEW user_usage_summary AS
SELECT
  ue.user_id,
  p.email as user_email,
  ue.org_id,
  DATE_TRUNC('hour', ue.created_at) as usage_hour,
  COUNT(*) as request_count,
  SUM(ue.total_tokens) as total_tokens,
  SUM(ue.total_cost) as total_cost
FROM usage_events ue
JOIN auth.users p ON ue.user_id = p.id
WHERE ue.created_at >= NOW() - INTERVAL '7 days'
GROUP BY ue.user_id, p.email, ue.org_id, DATE_TRUNC('hour', ue.created_at)
ORDER BY usage_hour DESC, total_cost DESC;
```

#### 3.2ã€é…é¢ä½¿ç”¨ç‡ç›‘æ§
```sql
-- é…é¢ä½¿ç”¨ç‡è§†å›¾
CREATE VIEW quota_utilization AS
WITH current_usage AS (
  SELECT
    qr.id as quota_rule_id,
    qr.quota_type,
    qr.quota_limit,
    qr.quota_period,
    qr.org_id,
    qr.project_id,
    qr.user_id,
    CASE qr.quota_period
      WHEN 'minute' THEN DATE_TRUNC('minute', NOW())
      WHEN 'hour' THEN DATE_TRUNC('hour', NOW())
      WHEN 'day' THEN DATE_TRUNC('day', NOW())
      WHEN 'month' THEN DATE_TRUNC('month', NOW())
    END as period_start,
    CASE qr.quota_type
      WHEN 'tokens' THEN COALESCE(SUM(ue.total_tokens), 0)
      WHEN 'requests' THEN COUNT(ue.id)
      WHEN 'cost' THEN COALESCE(SUM(ue.total_cost * 1000000), 0)::BIGINT
      ELSE 0
    END as current_usage
  FROM quota_rules qr
  LEFT JOIN usage_events ue ON (
    (qr.org_id IS NULL OR ue.org_id = qr.org_id) AND
    (qr.project_id IS NULL OR ue.project_id = qr.project_id) AND
    (qr.user_id IS NULL OR ue.user_id = qr.user_id) AND
    (qr.event_type IS NULL OR ue.event_type = qr.event_type) AND
    ue.created_at >= CASE qr.quota_period
      WHEN 'minute' THEN DATE_TRUNC('minute', NOW())
      WHEN 'hour' THEN DATE_TRUNC('hour', NOW())
      WHEN 'day' THEN DATE_TRUNC('day', NOW())
      WHEN 'month' THEN DATE_TRUNC('month', NOW())
    END
  )
  WHERE qr.effective_from <= NOW()
    AND (qr.effective_to IS NULL OR qr.effective_to > NOW())
  GROUP BY qr.id, qr.quota_type, qr.quota_limit, qr.quota_period, qr.org_id, qr.project_id, qr.user_id
)
SELECT
  quota_rule_id,
  quota_type,
  quota_limit,
  quota_period,
  org_id,
  project_id,
  user_id,
  current_usage,
  ROUND((current_usage::DECIMAL / quota_limit * 100), 2) as utilization_percentage,
  GREATEST(0, quota_limit - current_usage) as remaining_quota,
  CASE
    WHEN current_usage >= quota_limit THEN 'EXCEEDED'
    WHEN current_usage >= quota_limit * 0.9 THEN 'WARNING'
    WHEN current_usage >= quota_limit * 0.7 THEN 'MODERATE'
    ELSE 'NORMAL'
  END as status
FROM current_usage
ORDER BY utilization_percentage DESC;
```

### 4ã€è®¡è´¹é›†æˆ

#### 4.1ã€å‘ç¥¨ç”Ÿæˆ
```sql
-- å‘ç¥¨è¡¨
CREATE TABLE invoices (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  -- å‘ç¥¨ä¿¡æ¯
  invoice_number TEXT UNIQUE NOT NULL,
  billing_period_start DATE NOT NULL,
  billing_period_end DATE NOT NULL,

  -- é‡‘é¢ä¿¡æ¯
  subtotal DECIMAL(10,2) NOT NULL,
  tax_amount DECIMAL(10,2) DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL,

  -- çŠ¶æ€
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'sent', 'paid', 'overdue', 'cancelled')),
  due_date DATE,
  paid_at TIMESTAMPTZ,

  -- å…ƒæ•°æ®
  line_items JSONB, -- è¯¦ç»†çš„è®¡è´¹é¡¹ç›®

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç”Ÿæˆæœˆåº¦å‘ç¥¨å‡½æ•°
CREATE OR REPLACE FUNCTION generate_monthly_invoice(
  p_org_id UUID,
  p_billing_month DATE
) RETURNS UUID AS $$
DECLARE
  invoice_id UUID;
  line_items JSONB := '[]'::JSONB;
  total_cost DECIMAL(10,2) := 0;
BEGIN
  -- æ±‡æ€»å½“æœˆä½¿ç”¨é‡
  WITH monthly_usage AS (
    SELECT
      event_type,
      event_subtype,
      SUM(total_tokens) as total_tokens,
      SUM(total_cost) as cost
    FROM usage_events
    WHERE org_id = p_org_id
      AND created_at >= DATE_TRUNC('month', p_billing_month)
      AND created_at < DATE_TRUNC('month', p_billing_month) + INTERVAL '1 month'
    GROUP BY event_type, event_subtype
  )
  SELECT jsonb_agg(
    jsonb_build_object(
      'service', event_type || COALESCE('/' || event_subtype, ''),
      'quantity', total_tokens,
      'unit_price', ROUND(cost / total_tokens * 1000, 6),
      'total', cost
    )
  ), SUM(cost)
  INTO line_items, total_cost
  FROM monthly_usage;

  -- åˆ›å»ºå‘ç¥¨
  INSERT INTO invoices (
    org_id,
    invoice_number,
    billing_period_start,
    billing_period_end,
    subtotal,
    total_amount,
    line_items,
    due_date
  ) VALUES (
    p_org_id,
    'INV-' || TO_CHAR(p_billing_month, 'YYYY-MM') || '-' || p_org_id,
    DATE_TRUNC('month', p_billing_month),
    DATE_TRUNC('month', p_billing_month) + INTERVAL '1 month' - INTERVAL '1 day',
    total_cost,
    total_cost,
    line_items,
    DATE_TRUNC('month', p_billing_month) + INTERVAL '1 month' + INTERVAL '15 days'
  ) RETURNING id INTO invoice_id;

  RETURN invoice_id;
END;
$$ LANGUAGE plpgsql;
```

è¿™ä¸ªç”¨é‡ç»Ÿè®¡ä¸é…é¢ç³»ç»Ÿæä¾›äº†ï¼š
- **ç²¾ç¡®è®¡è´¹**ï¼šåŸºäºå®é™…ä½¿ç”¨é‡çš„ç²¾ç¡®æˆæœ¬è®¡ç®—
- **çµæ´»é…é¢**ï¼šå¤šçº§é…é¢æ§åˆ¶ï¼Œæ”¯æŒå„ç§é™æµç­–ç•¥
- **å®æ—¶ç›‘æ§**ï¼šä½¿ç”¨é‡å’Œé…é¢çš„å®æ—¶ç›‘æ§ä¸å‘Šè­¦
- **è´¢åŠ¡é›†æˆ**ï¼šå®Œæ•´çš„å‘ç¥¨ç”Ÿæˆå’Œè®¡è´¹æµç¨‹

## ä¹ã€æ•°æ®æ¨¡å‹è®¾è®¡è¦ç‚¹

è®¾è®¡è‰¯å¥½çš„æ•°æ®æ¨¡å‹æ˜¯ AI åº”ç”¨æˆåŠŸçš„åŸºç¡€ã€‚åœ¨ Supabase ç¯å¢ƒä¸­ï¼Œéœ€è¦å¹³è¡¡å…³ç³»æ•°æ®åº“çš„ ACID ç‰¹æ€§ä¸å‘é‡æ£€ç´¢çš„æ€§èƒ½éœ€æ±‚ï¼ŒåŒæ—¶è€ƒè™‘å¤šç§Ÿæˆ·å®‰å…¨å’Œæ‰©å±•æ€§ã€‚

### 1ã€æ ¸å¿ƒå®ä½“å…³ç³»

#### 1.1ã€ç§Ÿæˆ·ä¸æƒé™å±‚æ¬¡
```sql
-- ç§Ÿæˆ·å±‚æ¬¡ï¼šOrganization â†’ Project â†’ User
-- æ”¯æŒä¼ä¸šçº§å¤šç§Ÿæˆ·å’Œé¡¹ç›®çº§éš”ç¦»

-- æ‰©å±• auth.users è¡¨
CREATE TABLE user_profiles (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  display_name TEXT,
  avatar_url TEXT,
  timezone TEXT DEFAULT 'UTC',
  preferences JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç»„ç»‡è¡¨ï¼šé¡¶çº§ç§Ÿæˆ·
CREATE TABLE organizations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  domain TEXT, -- ä¼ä¸šé‚®ç®±åŸŸåï¼Œç”¨äºè‡ªåŠ¨é‚€è¯·
  settings JSONB DEFAULT '{}',
  subscription_plan TEXT DEFAULT 'free',
  subscription_status TEXT DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é¡¹ç›®è¡¨ï¼šäºŒçº§ç§Ÿæˆ·
CREATE TABLE projects (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  settings JSONB DEFAULT '{}', -- AI æ¨¡å‹é…ç½®ã€é»˜è®¤å‚æ•°ç­‰
  is_archived BOOLEAN DEFAULT FALSE,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_project_name_per_org UNIQUE(org_id, name)
);

-- æˆå‘˜å…³ç³»è¡¨ï¼šçµæ´»çš„è§’è‰²æƒé™
CREATE TABLE memberships (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  -- è§’è‰²æƒé™
  role TEXT NOT NULL CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
  permissions JSONB DEFAULT '[]', -- é¢å¤–çš„ç»†ç²’åº¦æƒé™

  -- é‚€è¯·æµç¨‹
  invited_by UUID REFERENCES auth.users(id),
  invited_at TIMESTAMPTZ,
  joined_at TIMESTAMPTZ,
  status TEXT DEFAULT 'active' CHECK (status IN ('pending', 'active', 'suspended')),

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_user_org UNIQUE(user_id, org_id)
);

-- é¡¹ç›®æƒé™è¡¨ï¼šé¡¹ç›®çº§ç»†ç²’åº¦æ§åˆ¶
CREATE TABLE project_memberships (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,

  permission_level TEXT NOT NULL CHECK (permission_level IN ('read', 'write', 'admin')),
  granted_by UUID REFERENCES auth.users(id),

  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_user_project UNIQUE(user_id, project_id)
);
```

#### 1.2ã€çŸ¥è¯†åº“ä¸å†…å®¹ç®¡ç†
```sql
-- çŸ¥è¯†åº“ï¼šæ–‡æ¡£ â†’ åˆ†å— â†’ å‘é‡çš„ä¸‰å±‚æ¶æ„

-- æ–‡æ¡£é›†åˆè¡¨ï¼ˆå¯é€‰ï¼Œç”¨äºç»„ç»‡æ–‡æ¡£ï¼‰
CREATE TABLE document_collections (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,

  name TEXT NOT NULL,
  description TEXT,
  metadata JSONB DEFAULT '{}',

  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ–‡æ¡£è¡¨ï¼šå¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒç‰ˆæœ¬æ§åˆ¶
CREATE TABLE documents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  collection_id UUID REFERENCES document_collections(id) ON DELETE SET NULL,

  -- æ–‡æ¡£ä¿¡æ¯
  title TEXT NOT NULL,
  content TEXT, -- æå–åçš„çº¯æ–‡æœ¬
  content_hash TEXT, -- å†…å®¹å“ˆå¸Œï¼Œç”¨äºå»é‡å’Œå˜æ›´æ£€æµ‹

  -- æ–‡ä»¶ä¿¡æ¯
  file_path TEXT, -- Storage è·¯å¾„
  file_name TEXT,
  file_type TEXT,
  file_size BIGINT,
  mime_type TEXT,

  -- ç‰ˆæœ¬æ§åˆ¶
  version INTEGER DEFAULT 1,
  parent_document_id UUID REFERENCES documents(id),

  -- å¤„ç†çŠ¶æ€
  processing_status TEXT DEFAULT 'pending' CHECK (
    processing_status IN ('pending', 'processing', 'completed', 'failed', 'archived')
  ),
  processing_started_at TIMESTAMPTZ,
  processing_completed_at TIMESTAMPTZ,
  error_details JSONB,

  -- ç»Ÿè®¡ä¿¡æ¯
  chunk_count INTEGER DEFAULT 0,
  total_tokens INTEGER DEFAULT 0,

  -- å…ƒæ•°æ®
  metadata JSONB DEFAULT '{}',
  tags TEXT[] DEFAULT '{}',

  -- å®¡è®¡å­—æ®µ
  uploaded_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- ç´¢å¼•
  CONSTRAINT unique_content_hash_per_project UNIQUE(project_id, content_hash)
);

-- æ–‡æ¡£è®¿é—®æ—¥å¿—ï¼ˆå¯é€‰ï¼Œç”¨äºåˆ†æï¼‰
CREATE TABLE document_access_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  access_type TEXT NOT NULL CHECK (access_type IN ('view', 'search', 'download')),
  accessed_at TIMESTAMPTZ DEFAULT NOW(),

  -- åˆ†åŒºé”®
  log_date DATE GENERATED ALWAYS AS (DATE(accessed_at)) STORED
) PARTITION BY RANGE (log_date);

-- ä¸ºæ—¥å¿—è¡¨åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE document_access_logs_y2024m01 PARTITION OF document_access_logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

#### 1.3ã€å¯¹è¯ä¸æ¶ˆæ¯ç³»ç»Ÿ
```sql
-- å¯¹è¯è¡¨ï¼šæ”¯æŒå¤šæ¨¡æ€å’Œå¤æ‚äº¤äº’
CREATE TABLE conversations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- å¯¹è¯å…ƒä¿¡æ¯
  title TEXT,
  description TEXT,

  -- AI é…ç½®
  system_prompt TEXT,
  model_config JSONB DEFAULT '{}', -- æ¨¡å‹å‚æ•°ã€æ¸©åº¦ç­‰
  context_window INTEGER DEFAULT 4000, -- ä¸Šä¸‹æ–‡çª—å£å¤§å°

  -- çŠ¶æ€ç®¡ç†
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deleted')),
  is_shared BOOLEAN DEFAULT FALSE, -- æ˜¯å¦å…±äº«ç»™å›¢é˜Ÿ

  -- ç»Ÿè®¡ä¿¡æ¯
  message_count INTEGER DEFAULT 0,
  total_input_tokens INTEGER DEFAULT 0,
  total_output_tokens INTEGER DEFAULT 0,
  total_cost DECIMAL(10,6) DEFAULT 0,

  -- å…³è”ä¿¡æ¯
  parent_conversation_id UUID REFERENCES conversations(id), -- æ”¯æŒå¯¹è¯åˆ†æ”¯
  tags TEXT[] DEFAULT '{}',

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ¶ˆæ¯è¡¨ï¼šæ”¯æŒå¤šæ¨¡æ€å†…å®¹å’Œå¤æ‚çŠ¶æ€
CREATE TABLE messages (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,

  -- æ¶ˆæ¯åŸºæœ¬ä¿¡æ¯
  role TEXT NOT NULL CHECK (role IN ('system', 'user', 'assistant', 'tool')),
  content TEXT NOT NULL,
  content_type TEXT DEFAULT 'text' CHECK (content_type IN ('text', 'image', 'audio', 'file', 'multimodal')),

  -- å¤šæ¨¡æ€æ”¯æŒ
  attachments JSONB DEFAULT '[]', -- é™„ä»¶åˆ—è¡¨ï¼šå›¾ç‰‡ã€æ–‡ä»¶ç­‰

  -- æµå¼çŠ¶æ€
  status TEXT DEFAULT 'completed' CHECK (status IN ('pending', 'streaming', 'completed', 'failed', 'cancelled')),
  stream_position INTEGER DEFAULT 0,

  -- AI å…ƒæ•°æ®
  model_name TEXT,
  model_version TEXT,
  token_count INTEGER,
  finish_reason TEXT, -- 'stop', 'length', 'content_filter'

  -- å·¥å…·è°ƒç”¨æ”¯æŒ
  tool_calls JSONB, -- OpenAI æ ¼å¼çš„å·¥å…·è°ƒç”¨
  tool_call_id TEXT, -- å·¥å…·è°ƒç”¨çš„å“åº” ID

  -- å¼•ç”¨ä¸ä¸Šä¸‹æ–‡
  parent_message_id UUID REFERENCES messages(id), -- æ”¯æŒæ¶ˆæ¯å›å¤
  references JSONB DEFAULT '[]', -- å¼•ç”¨çš„æ–‡æ¡£ã€ä»£ç ç‰‡æ®µç­‰
  context_sources JSONB DEFAULT '[]', -- RAG æ£€ç´¢çš„æ¥æº

  -- è´¨é‡è¯„ä¼°
  rating INTEGER CHECK (rating BETWEEN 1 AND 5),
  feedback TEXT,
  flagged BOOLEAN DEFAULT FALSE,
  flag_reason TEXT,

  -- æˆæœ¬è¿½è¸ª
  input_cost DECIMAL(10,6) DEFAULT 0,
  output_cost DECIMAL(10,6) DEFAULT 0,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ¶ˆæ¯ç¼–è¾‘å†å²ï¼ˆå¯é€‰ï¼‰
CREATE TABLE message_edit_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  message_id UUID REFERENCES messages(id) ON DELETE CASCADE,

  previous_content TEXT NOT NULL,
  edit_type TEXT CHECK (edit_type IN ('user_edit', 'regenerate', 'system_update')),
  edited_by UUID REFERENCES auth.users(id),

  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 2ã€ç´¢å¼•ç­–ç•¥ä¸æ€§èƒ½ä¼˜åŒ–

#### 2.1ã€å…³é”®ä¸šåŠ¡ç´¢å¼•
```sql
-- ç§Ÿæˆ·éš”ç¦»æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_documents_org_project_status ON documents(org_id, project_id, processing_status);
CREATE INDEX idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
CREATE INDEX idx_messages_conversation_created ON messages(conversation_id, created_at);

-- å‘é‡æ£€ç´¢ä¼˜åŒ–
CREATE INDEX idx_embeddings_vector_cosine ON embeddings
USING ivfflat (vector vector_cosine_ops) WITH (lists = 100);

-- å…¨æ–‡æœç´¢æ”¯æŒ
CREATE INDEX idx_documents_content_fts ON documents
USING gin(to_tsvector('english', title || ' ' || COALESCE(content, '')));

-- ç”¨é‡æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_usage_events_org_time ON usage_events(org_id, created_at DESC);
CREATE INDEX idx_usage_events_user_time ON usage_events(user_id, created_at DESC);

-- å¤åˆç´¢å¼•ï¼šå¤šç»´åº¦æŸ¥è¯¢
CREATE INDEX idx_documents_project_tags ON documents USING gin(project_id, tags);
CREATE INDEX idx_conversations_shared_active ON conversations(is_shared, status) WHERE status = 'active';
```

#### 2.2ã€åˆ†åŒºè¡¨ç­–ç•¥
```sql
-- æŒ‰æ—¶é—´åˆ†åŒºçš„å¤§è¡¨
-- ç”¨é‡äº‹ä»¶æŒ‰æœˆåˆ†åŒº
CREATE TABLE usage_events (
  -- ... åˆ—å®šä¹‰
  created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- åˆ›å»ºåˆ†åŒºå‡½æ•°
CREATE OR REPLACE FUNCTION create_monthly_partition(
  table_name TEXT,
  start_date DATE
) RETURNS VOID AS $$
DECLARE
  partition_name TEXT;
  end_date DATE;
BEGIN
  end_date := start_date + INTERVAL '1 month';
  partition_name := table_name || '_y' || EXTRACT(YEAR FROM start_date) || 'm' || LPAD(EXTRACT(MONTH FROM start_date)::TEXT, 2, '0');

  EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
    partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;

-- è‡ªåŠ¨åˆ›å»ºæœªæ¥ 6 ä¸ªæœˆçš„åˆ†åŒº
DO $$
DECLARE
  current_month DATE := DATE_TRUNC('month', NOW());
  i INTEGER;
BEGIN
  FOR i IN 0..5 LOOP
    PERFORM create_monthly_partition('usage_events', current_month + (i * INTERVAL '1 month'));
  END LOOP;
END $$;
```

### 3ã€æ•°æ®å®Œæ•´æ€§ä¸çº¦æŸ

#### 3.1ã€ä¸šåŠ¡è§„åˆ™çº¦æŸ
```sql
-- å‘é‡ç»´åº¦ä¸€è‡´æ€§æ£€æŸ¥
ALTER TABLE embeddings ADD CONSTRAINT check_vector_dimension
CHECK (array_length(vector, 1) = 1536);

-- ç”¨é‡äº‹ä»¶æ•°æ®æœ‰æ•ˆæ€§
ALTER TABLE usage_events ADD CONSTRAINT check_positive_tokens
CHECK (input_tokens >= 0 AND output_tokens >= 0);

ALTER TABLE usage_events ADD CONSTRAINT check_positive_cost
CHECK (input_cost >= 0 AND output_cost >= 0);

-- æ¶ˆæ¯é¡ºåºçº¦æŸ
CREATE UNIQUE INDEX idx_messages_conversation_created_unique
ON messages(conversation_id, created_at);

-- ç»„ç»‡ slug æ ¼å¼çº¦æŸ
ALTER TABLE organizations ADD CONSTRAINT check_slug_format
CHECK (slug ~ '^[a-z0-9][a-z0-9-]*[a-z0-9]$' AND length(slug) BETWEEN 3 AND 63);
```

#### 3.2ã€çº§è”åˆ é™¤ç­–ç•¥
```sql
-- è½¯åˆ é™¤æ”¯æŒ
ALTER TABLE documents ADD COLUMN deleted_at TIMESTAMPTZ;
ALTER TABLE conversations ADD COLUMN deleted_at TIMESTAMPTZ;

-- åˆ›å»ºè½¯åˆ é™¤è§†å›¾
CREATE VIEW active_documents AS
SELECT * FROM documents WHERE deleted_at IS NULL;

CREATE VIEW active_conversations AS
SELECT * FROM conversations WHERE deleted_at IS NULL AND status != 'deleted';

-- çº§è”å½’æ¡£å‡½æ•°
CREATE OR REPLACE FUNCTION archive_project_data(p_project_id UUID)
RETURNS VOID AS $$
BEGIN
  -- å½’æ¡£æ–‡æ¡£
  UPDATE documents SET processing_status = 'archived'
  WHERE project_id = p_project_id AND processing_status != 'failed';

  -- å½’æ¡£å¯¹è¯
  UPDATE conversations SET status = 'archived'
  WHERE project_id = p_project_id AND status = 'active';

  -- è®°å½•å½’æ¡£äº‹ä»¶
  INSERT INTO audit_logs (event_type, resource_type, resource_id, details)
  VALUES ('archive', 'project', p_project_id, jsonb_build_object('archived_at', NOW()));
END;
$$ LANGUAGE plpgsql;
```

### 4ã€æ‰©å±•æ€§è®¾è®¡æ¨¡å¼

#### 4.1ã€JSONB çµæ´»å­—æ®µ
```sql
-- å…ƒæ•°æ®å­—æ®µçš„æ ‡å‡†åŒ–ç»“æ„
-- documents.metadata å­—æ®µç¤ºä¾‹ï¼š
{
  "source": "upload|api|sync",
  "language": "en|zh|auto",
  "processing_options": {
    "chunk_size": 1000,
    "overlap": 200,
    "extract_tables": true
  },
  "quality_metrics": {
    "readability_score": 0.8,
    "content_type": "technical|marketing|legal"
  },
  "custom_fields": {
    "department": "engineering",
    "confidentiality": "internal"
  }
}

-- ä¸º JSONB å­—æ®µåˆ›å»º GIN ç´¢å¼•
CREATE INDEX idx_documents_metadata ON documents USING gin(metadata);

-- JSONB æŸ¥è¯¢ç¤ºä¾‹
-- æŸ¥æ‰¾ç‰¹å®šéƒ¨é—¨çš„æ–‡æ¡£
SELECT * FROM documents
WHERE metadata->>'department' = 'engineering';

-- æŸ¥æ‰¾åŒ…å«ç‰¹å®šå¤„ç†é€‰é¡¹çš„æ–‡æ¡£
SELECT * FROM documents
WHERE metadata @> '{"processing_options": {"extract_tables": true}}';
```

#### 4.2ã€æ‰©å±•è¡¨æ¨¡å¼
```sql
-- ä¸ºä¸åŒç±»å‹çš„æ–‡æ¡£åˆ›å»ºæ‰©å±•è¡¨
CREATE TABLE document_extensions (
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE PRIMARY KEY,
  extension_type TEXT NOT NULL, -- 'code', 'legal', 'medical'
  extension_data JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ä»£ç æ–‡æ¡£æ‰©å±•
-- extension_data ç¤ºä¾‹ï¼š
{
  "language": "python",
  "framework": "django",
  "complexity_score": 0.7,
  "dependencies": ["requests", "pandas"],
  "functions": [
    {"name": "process_data", "line_start": 10, "line_end": 50}
  ]
}

-- æ³•å¾‹æ–‡æ¡£æ‰©å±•
{
  "document_type": "contract",
  "jurisdiction": "california",
  "parties": ["company_a", "company_b"],
  "clauses": [
    {"type": "confidentiality", "section": "5.1"}
  ]
}
```

è¿™ä¸ªæ•°æ®æ¨¡å‹è®¾è®¡æä¾›äº†ï¼š
- **å¯æ‰©å±•æ€§**ï¼šé€šè¿‡ JSONB å’Œæ‰©å±•è¡¨æ”¯æŒçµæ´»çš„ä¸šåŠ¡éœ€æ±‚
- **é«˜æ€§èƒ½**ï¼šåˆç†çš„ç´¢å¼•ç­–ç•¥å’Œåˆ†åŒºè®¾è®¡
- **æ•°æ®å®Œæ•´æ€§**ï¼šå®Œå–„çš„çº¦æŸå’Œçº§è”è§„åˆ™
- **å¤šç§Ÿæˆ·å®‰å…¨**ï¼šä¸¥æ ¼çš„ç§Ÿæˆ·éš”ç¦»å’Œæƒé™æ§åˆ¶

## åã€å®‰å…¨ä¸åˆè§„

AI åº”ç”¨å¤„ç†çš„æ•°æ®å¾€å¾€åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼Œä»ä¸ªäººå¯¹è¯è®°å½•åˆ°ä¼ä¸šæœºå¯†æ–‡æ¡£ï¼Œå®‰å…¨ä¸åˆè§„ä¸ä»…æ˜¯æŠ€æœ¯è¦æ±‚ï¼Œæ›´æ˜¯ä¸šåŠ¡ç”Ÿå­˜çš„åŸºç¡€ã€‚Supabase çš„å¤šå±‚å®‰å…¨æœºåˆ¶ä¸ºæ„å»ºåˆè§„çš„ AI åº”ç”¨æä¾›äº†åšå®ä¿éšœã€‚

### 1ã€å¤šå±‚æ¬¡ RLS å®‰å…¨ç­–ç•¥

#### 1.1ã€ç»„ç»‡çº§åŸºç¡€éš”ç¦»
ç¡®ä¿ä¸åŒç»„ç»‡çš„æ•°æ®å®Œå…¨éš”ç¦»ï¼Œé˜²æ­¢ä»»ä½•å½¢å¼çš„æ•°æ®æ³„éœ²ï¼š

```sql
-- åŸºç¡€ç»„ç»‡éš”ç¦»ç­–ç•¥æ¨¡æ¿
CREATE OR REPLACE FUNCTION create_org_isolation_policy(
  table_name TEXT,
  org_column TEXT DEFAULT 'org_id'
) RETURNS VOID AS $$
BEGIN
  EXECUTE format('
    CREATE POLICY "%s_org_isolation" ON %I
    FOR ALL USING (
      %I = ANY(
        SELECT org_id FROM memberships
        WHERE user_id = auth.uid()
        AND status = ''active''
      )
    )', table_name, table_name, org_column);
END;
$$ LANGUAGE plpgsql;

-- åº”ç”¨åˆ°æ‰€æœ‰ä¸šåŠ¡è¡¨
SELECT create_org_isolation_policy('documents');
SELECT create_org_isolation_policy('conversations');
SELECT create_org_isolation_policy('usage_events');
```

#### 1.2ã€é¡¹ç›®çº§ç»†ç²’åº¦æ§åˆ¶
åœ¨ç»„ç»‡å†…éƒ¨æŒ‰é¡¹ç›®è¿›è¡Œæ›´ç»†è‡´çš„æƒé™ç®¡ç†ï¼š

```sql
-- é¡¹ç›®çº§è®¿é—®æ§åˆ¶ç­–ç•¥
CREATE POLICY "project_based_access" ON documents
FOR ALL USING (
  -- ç»„ç»‡æˆå‘˜èº«ä»½éªŒè¯
  EXISTS (
    SELECT 1 FROM memberships m
    WHERE m.user_id = auth.uid()
    AND m.org_id = documents.org_id
    AND m.status = 'active'
  )
  AND
  -- é¡¹ç›®æƒé™éªŒè¯
  (
    -- ç»„ç»‡ç®¡ç†å‘˜å¯è®¿é—®æ‰€æœ‰é¡¹ç›®
    EXISTS (
      SELECT 1 FROM memberships m
      WHERE m.user_id = auth.uid()
      AND m.org_id = documents.org_id
      AND m.role IN ('owner', 'admin')
    )
    OR
    -- é¡¹ç›®æˆå‘˜è®¿é—®æƒé™
    EXISTS (
      SELECT 1 FROM project_memberships pm
      WHERE pm.user_id = auth.uid()
      AND pm.project_id = documents.project_id
      AND pm.permission_level IN ('read', 'write', 'admin')
    )
  )
);
```

#### 1.3ã€èµ„æºçº§æƒé™æ§åˆ¶
å¯¹ç‰¹å®šèµ„æºå®æ–½æ›´ç²¾ç»†çš„è®¿é—®æ§åˆ¶ï¼š

```sql
-- æ–‡æ¡£çº§æƒé™æ§åˆ¶
CREATE TABLE document_permissions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  permission_type TEXT NOT NULL CHECK (permission_type IN ('read', 'write', 'admin')),
  granted_by UUID REFERENCES auth.users(id),
  expires_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ–‡æ¡£çº§ RLS ç­–ç•¥
CREATE POLICY "document_level_permissions" ON documents
FOR SELECT USING (
  -- åŸºç¡€é¡¹ç›®æƒé™ OR ç‰¹å®šæ–‡æ¡£æƒé™
  (
    EXISTS (
      SELECT 1 FROM project_memberships pm
      WHERE pm.user_id = auth.uid()
      AND pm.project_id = documents.project_id
    )
  )
  OR
  (
    EXISTS (
      SELECT 1 FROM document_permissions dp
      WHERE dp.document_id = documents.id
      AND dp.user_id = auth.uid()
      AND dp.permission_type IN ('read', 'write', 'admin')
      AND (dp.expires_at IS NULL OR dp.expires_at > NOW())
    )
  )
);
```

### 2ã€æ•æ„Ÿæ•°æ®ä¿æŠ¤ï¼ˆPII ç®¡ç†ï¼‰

#### 2.1ã€æ•°æ®åˆ†ç±»ä¸æ ‡è®°
```sql
-- æ•°æ®æ•æ„Ÿåº¦åˆ†ç±»è¡¨
CREATE TABLE data_classifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  resource_type TEXT NOT NULL, -- 'document', 'conversation', 'message'
  resource_id UUID NOT NULL,

  classification_level TEXT NOT NULL CHECK (
    classification_level IN ('public', 'internal', 'confidential', 'restricted')
  ),

  pii_types TEXT[] DEFAULT '{}', -- ['email', 'phone', 'ssn', 'credit_card']
  compliance_requirements TEXT[] DEFAULT '{}', -- ['gdpr', 'hipaa', 'pci']

  classified_by UUID REFERENCES auth.users(id),
  classification_reason TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- è‡ªåŠ¨ PII æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION detect_pii_in_content(content TEXT)
RETURNS TEXT[] AS $$
DECLARE
  pii_types TEXT[] := '{}';
BEGIN
  -- é‚®ç®±æ£€æµ‹
  IF content ~* '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b' THEN
    pii_types := array_append(pii_types, 'email');
  END IF;

  -- ç”µè¯å·ç æ£€æµ‹
  IF content ~* '\b\d{3}[-.]?\d{3}[-.]?\d{4}\b' THEN
    pii_types := array_append(pii_types, 'phone');
  END IF;

  -- ä¿¡ç”¨å¡å·æ£€æµ‹ï¼ˆç®€åŒ–ç‰ˆï¼‰
  IF content ~* '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b' THEN
    pii_types := array_append(pii_types, 'credit_card');
  END IF;

  RETURN pii_types;
END;
$$ LANGUAGE plpgsql;

-- è‡ªåŠ¨åˆ†ç±»è§¦å‘å™¨
CREATE OR REPLACE FUNCTION auto_classify_content()
RETURNS TRIGGER AS $$
DECLARE
  detected_pii TEXT[];
  classification TEXT := 'internal';
BEGIN
  -- æ£€æµ‹ PII
  detected_pii := detect_pii_in_content(NEW.content);

  -- æ ¹æ® PII ç±»å‹ç¡®å®šåˆ†ç±»çº§åˆ«
  IF array_length(detected_pii, 1) > 0 THEN
    classification := 'confidential';
  END IF;

  -- æ’å…¥æˆ–æ›´æ–°åˆ†ç±»
  INSERT INTO data_classifications (
    resource_type, resource_id, classification_level, pii_types, classified_by
  ) VALUES (
    TG_TABLE_NAME, NEW.id, classification, detected_pii, auth.uid()
  ) ON CONFLICT (resource_type, resource_id) DO UPDATE SET
    classification_level = EXCLUDED.classification_level,
    pii_types = EXCLUDED.pii_types,
    updated_at = NOW();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ä¸ºç›¸å…³è¡¨æ·»åŠ è§¦å‘å™¨
CREATE TRIGGER auto_classify_documents
  AFTER INSERT OR UPDATE OF content ON documents
  FOR EACH ROW EXECUTE FUNCTION auto_classify_content();

CREATE TRIGGER auto_classify_messages
  AFTER INSERT OR UPDATE OF content ON messages
  FOR EACH ROW EXECUTE FUNCTION auto_classify_content();
```

#### 2.2ã€æ•°æ®è„±æ•ä¸æ©ç 
```sql
-- æ•°æ®è„±æ•å‡½æ•°
CREATE OR REPLACE FUNCTION mask_sensitive_data(
  content TEXT,
  mask_level TEXT DEFAULT 'partial'
) RETURNS TEXT AS $$
BEGIN
  CASE mask_level
    WHEN 'full' THEN
      -- å®Œå…¨æ©ç ï¼šç”¨ [REDACTED] æ›¿æ¢
      RETURN regexp_replace(content, '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', '[EMAIL_REDACTED]', 'g');
    WHEN 'partial' THEN
      -- éƒ¨åˆ†æ©ç ï¼šä¿ç•™éƒ¨åˆ†å­—ç¬¦
      RETURN regexp_replace(content, '\b([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b', '\1***@***.\2', 'g');
    ELSE
      RETURN content;
  END CASE;
END;
$$ LANGUAGE plpgsql;

-- åŸºäºè§’è‰²çš„å†…å®¹è§†å›¾
CREATE VIEW documents_masked AS
SELECT
  d.*,
  CASE
    WHEN dc.classification_level IN ('confidential', 'restricted')
         AND NOT check_user_role(d.org_id, 'admin') THEN
      mask_sensitive_data(d.content, 'partial')
    ELSE d.content
  END as content_masked
FROM documents d
LEFT JOIN data_classifications dc ON dc.resource_type = 'documents' AND dc.resource_id = d.id;
```

### 3ã€å®¡è®¡ä¸æ—¥å¿—è®°å½•

#### 3.1ã€å…¨é¢å®¡è®¡æ—¥å¿—
```sql
-- å®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE audit_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- äº‹ä»¶ä¿¡æ¯
  event_type TEXT NOT NULL, -- 'create', 'read', 'update', 'delete', 'access'
  event_subtype TEXT, -- 'document_view', 'message_send', 'search_query'

  -- èµ„æºä¿¡æ¯
  resource_type TEXT NOT NULL, -- 'document', 'conversation', 'user'
  resource_id UUID,

  -- ç”¨æˆ·ä¿¡æ¯
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  user_email TEXT,
  user_ip INET,
  user_agent TEXT,

  -- ä¼šè¯ä¿¡æ¯
  session_id TEXT,
  org_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
  project_id UUID REFERENCES projects(id) ON DELETE SET NULL,

  -- äº‹ä»¶è¯¦æƒ…
  details JSONB DEFAULT '{}',

  -- å®‰å…¨ç›¸å…³
  risk_level TEXT DEFAULT 'low' CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
  flagged BOOLEAN DEFAULT FALSE,

  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- åˆ†åŒºé”®
  log_date DATE GENERATED ALWAYS AS (DATE(created_at)) STORED
) PARTITION BY RANGE (log_date);

-- å®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION log_audit_event()
RETURNS TRIGGER AS $$
DECLARE
  user_info RECORD;
  risk_level TEXT := 'low';
BEGIN
  -- è·å–ç”¨æˆ·ä¿¡æ¯
  SELECT email INTO user_info FROM auth.users WHERE id = auth.uid();

  -- è¯„ä¼°é£é™©çº§åˆ«
  IF TG_OP = 'DELETE' THEN
    risk_level := 'medium';
  ELSIF TG_TABLE_NAME IN ('documents', 'conversations') AND TG_OP = 'UPDATE' THEN
    risk_level := 'medium';
  END IF;

  -- è®°å½•å®¡è®¡æ—¥å¿—
  INSERT INTO audit_logs (
    event_type, resource_type, resource_id, user_id, user_email,
    org_id, details, risk_level
  ) VALUES (
    lower(TG_OP), TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    auth.uid(), user_info.email,
    COALESCE(NEW.org_id, OLD.org_id),
    jsonb_build_object(
      'table', TG_TABLE_NAME,
      'operation', TG_OP,
      'changed_columns',
      CASE WHEN TG_OP = 'UPDATE' THEN
        (SELECT array_agg(key) FROM jsonb_each(to_jsonb(NEW)) WHERE value != to_jsonb(OLD) -> key)
      ELSE NULL END
    ),
    risk_level
  );

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- ä¸ºå…³é”®è¡¨æ·»åŠ å®¡è®¡è§¦å‘å™¨
CREATE TRIGGER audit_documents
  AFTER INSERT OR UPDATE OR DELETE ON documents
  FOR EACH ROW EXECUTE FUNCTION log_audit_event();

CREATE TRIGGER audit_conversations
  AFTER INSERT OR UPDATE OR DELETE ON conversations
  FOR EACH ROW EXECUTE FUNCTION log_audit_event();
```

#### 3.2ã€API è®¿é—®æ—¥å¿—
```sql
-- API è®¿é—®æ—¥å¿—è¡¨
CREATE TABLE api_access_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

  -- è¯·æ±‚ä¿¡æ¯
  request_id TEXT UNIQUE,
  method TEXT NOT NULL,
  path TEXT NOT NULL,
  query_params JSONB,

  -- è®¤è¯ä¿¡æ¯
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  api_key_id UUID REFERENCES api_keys(id) ON DELETE SET NULL,
  auth_method TEXT CHECK (auth_method IN ('jwt', 'api_key', 'anonymous')),

  -- ç½‘ç»œä¿¡æ¯
  client_ip INET,
  user_agent TEXT,
  referer TEXT,

  -- å“åº”ä¿¡æ¯
  status_code INTEGER,
  response_time_ms INTEGER,
  response_size BIGINT,

  -- ä¸šåŠ¡ä¿¡æ¯
  org_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
  project_id UUID REFERENCES projects(id) ON DELETE SET NULL,

  -- å®‰å…¨æ ‡è®°
  is_suspicious BOOLEAN DEFAULT FALSE,
  rate_limited BOOLEAN DEFAULT FALSE,

  created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- Edge Functions ä¸­çš„æ—¥å¿—è®°å½•
-- åœ¨æ¯ä¸ª Edge Function ä¸­æ·»åŠ ï¼š
export async function logApiAccess(request: Request, response: Response, metadata: any) {
  const startTime = Date.now();

  const logData = {
    request_id: crypto.randomUUID(),
    method: request.method,
    path: new URL(request.url).pathname,
    query_params: Object.fromEntries(new URL(request.url).searchParams),
    client_ip: request.headers.get('x-forwarded-for'),
    user_agent: request.headers.get('user-agent'),
    status_code: response.status,
    response_time_ms: Date.now() - startTime,
    org_id: metadata.orgId,
    project_id: metadata.projectId
  };

  await supabase
    .from('api_access_logs')
    .insert(logData);
}
```

### 4ã€åˆè§„æ¡†æ¶æ”¯æŒ

#### 4.1ã€GDPR åˆè§„
```sql
-- GDPR ç”¨æˆ·æƒåˆ©æ”¯æŒ
-- æ•°æ®å¯æºå¸¦æ€§ï¼šå¯¼å‡ºç”¨æˆ·æ‰€æœ‰æ•°æ®
CREATE OR REPLACE FUNCTION export_user_data(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
  user_data JSONB := '{}';
BEGIN
  -- åŸºç¡€ç”¨æˆ·ä¿¡æ¯
  SELECT jsonb_build_object(
    'profile', to_jsonb(up.*),
    'memberships', (
      SELECT jsonb_agg(to_jsonb(m.*)) FROM memberships m WHERE m.user_id = p_user_id
    ),
    'conversations', (
      SELECT jsonb_agg(to_jsonb(c.*)) FROM conversations c WHERE c.user_id = p_user_id
    ),
    'messages', (
      SELECT jsonb_agg(to_jsonb(msg.*))
      FROM messages msg
      JOIN conversations c ON msg.conversation_id = c.id
      WHERE c.user_id = p_user_id
    ),
    'documents', (
      SELECT jsonb_agg(to_jsonb(d.*)) FROM documents d WHERE d.uploaded_by = p_user_id
    )
  ) INTO user_data
  FROM user_profiles up WHERE up.id = p_user_id;

  RETURN user_data;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- è¢«é—å¿˜æƒï¼šå®‰å…¨åˆ é™¤ç”¨æˆ·æ•°æ®
CREATE OR REPLACE FUNCTION forget_user(p_user_id UUID)
RETURNS VOID AS $$
BEGIN
  -- è½¯åˆ é™¤ç”¨æˆ·å†…å®¹ï¼ˆä¿ç•™å®¡è®¡éœ€è¦ï¼‰
  UPDATE conversations SET
    user_id = NULL,
    title = '[USER_DELETED]',
    updated_at = NOW()
  WHERE user_id = p_user_id;

  UPDATE messages SET
    content = '[CONTENT_DELETED]',
    updated_at = NOW()
  WHERE conversation_id IN (
    SELECT id FROM conversations WHERE user_id = p_user_id
  );

  -- åŒ¿ååŒ–å®¡è®¡æ—¥å¿—
  UPDATE audit_logs SET
    user_email = '[DELETED]',
    details = details || '{"user_forgotten": true}'
  WHERE user_id = p_user_id;

  -- åˆ é™¤ä¸ªäººèµ„æ–™
  DELETE FROM user_profiles WHERE id = p_user_id;
  DELETE FROM memberships WHERE user_id = p_user_id;

  -- è®°å½•åˆ é™¤æ“ä½œ
  INSERT INTO audit_logs (
    event_type, resource_type, resource_id, details
  ) VALUES (
    'gdpr_forget', 'user', p_user_id,
    jsonb_build_object('forgotten_at', NOW(), 'reason', 'gdpr_request')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### 4.2ã€SOC 2 Type II åˆè§„
```sql
-- è®¿é—®æ§åˆ¶å®¡è®¡
CREATE VIEW access_control_audit AS
SELECT
  u.email as user_email,
  o.name as organization,
  m.role as org_role,
  p.name as project,
  pm.permission_level as project_permission,
  m.created_at as access_granted_at,
  m.status
FROM memberships m
JOIN auth.users u ON m.user_id = u.id
JOIN organizations o ON m.org_id = o.id
LEFT JOIN project_memberships pm ON pm.user_id = m.user_id
LEFT JOIN projects p ON pm.project_id = p.id
WHERE m.status = 'active'
ORDER BY o.name, u.email;

-- å¼‚å¸¸è®¿é—®æ£€æµ‹
CREATE OR REPLACE FUNCTION detect_suspicious_activity()
RETURNS TABLE (
  user_id UUID,
  user_email TEXT,
  suspicious_activity TEXT,
  risk_score INTEGER
) AS $$
BEGIN
  RETURN QUERY
  WITH user_activity AS (
    SELECT
      al.user_id,
      al.user_email,
      COUNT(*) as activity_count,
      COUNT(DISTINCT al.user_ip) as ip_count,
      COUNT(*) FILTER (WHERE al.event_type = 'delete') as delete_count,
      COUNT(*) FILTER (WHERE al.created_at > NOW() - INTERVAL '1 hour') as recent_activity
    FROM audit_logs al
    WHERE al.created_at > NOW() - INTERVAL '24 hours'
    GROUP BY al.user_id, al.user_email
  )
  SELECT
    ua.user_id,
    ua.user_email,
    CASE
      WHEN ua.ip_count > 5 THEN 'Multiple IP addresses'
      WHEN ua.delete_count > 10 THEN 'Excessive deletions'
      WHEN ua.recent_activity > 100 THEN 'High frequency activity'
      ELSE 'Unknown'
    END as suspicious_activity,
    CASE
      WHEN ua.ip_count > 5 THEN 3
      WHEN ua.delete_count > 10 THEN 4
      WHEN ua.recent_activity > 100 THEN 2
      ELSE 1
    END as risk_score
  FROM user_activity ua
  WHERE ua.ip_count > 5 OR ua.delete_count > 10 OR ua.recent_activity > 100;
END;
$$ LANGUAGE plpgsql;
```

### 5ã€å¯†é’¥ç®¡ç†ä¸è½®æ¢

#### 5.1ã€API å¯†é’¥å®‰å…¨ç®¡ç†
```sql
-- å¯†é’¥è½®æ¢å‡½æ•°
CREATE OR REPLACE FUNCTION rotate_api_key(p_key_id UUID)
RETURNS TEXT AS $$
DECLARE
  new_key TEXT;
  new_key_hash TEXT;
BEGIN
  -- ç”Ÿæˆæ–°å¯†é’¥
  new_key := 'sk_' || encode(gen_random_bytes(32), 'hex');
  new_key_hash := encode(digest(new_key, 'sha256'), 'hex');

  -- æ›´æ–°å¯†é’¥è®°å½•
  UPDATE api_keys SET
    key_hash = new_key_hash,
    updated_at = NOW(),
    last_rotated_at = NOW()
  WHERE id = p_key_id;

  -- è®°å½•è½®æ¢äº‹ä»¶
  INSERT INTO audit_logs (
    event_type, resource_type, resource_id, details
  ) VALUES (
    'key_rotation', 'api_key', p_key_id,
    jsonb_build_object('rotated_at', NOW())
  );

  RETURN new_key;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- è‡ªåŠ¨å¯†é’¥è½®æ¢ï¼ˆå®šæœŸä»»åŠ¡ï¼‰
CREATE OR REPLACE FUNCTION auto_rotate_expired_keys()
RETURNS INTEGER AS $$
DECLARE
  rotated_count INTEGER := 0;
  key_record RECORD;
BEGIN
  FOR key_record IN
    SELECT id FROM api_keys
    WHERE last_rotated_at < NOW() - INTERVAL '90 days'
    OR created_at < NOW() - INTERVAL '90 days'
  LOOP
    PERFORM rotate_api_key(key_record.id);
    rotated_count := rotated_count + 1;
  END LOOP;

  RETURN rotated_count;
END;
$$ LANGUAGE plpgsql;
```

#### 5.2ã€åŠ å¯†æ•°æ®å­˜å‚¨
```sql
-- æ•æ„Ÿæ•°æ®åŠ å¯†æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- æ•æ„Ÿå­—æ®µåŠ å¯†
CREATE TABLE encrypted_user_data (
  user_id UUID REFERENCES auth.users(id) PRIMARY KEY,
  encrypted_data TEXT, -- PGP åŠ å¯†çš„æ•æ„Ÿæ•°æ®
  encryption_key_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åŠ å¯†/è§£å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(
  data TEXT,
  encryption_key TEXT
) RETURNS TEXT AS $$
BEGIN
  RETURN pgp_sym_encrypt(data, encryption_key);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrypt_sensitive_data(
  encrypted_data TEXT,
  encryption_key TEXT
) RETURNS TEXT AS $$
BEGIN
  RETURN pgp_sym_decrypt(encrypted_data, encryption_key);
EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL; -- è§£å¯†å¤±è´¥è¿”å› NULL
END;
$$ LANGUAGE plpgsql;
```

è¿™å¥—å®‰å…¨ä¸åˆè§„æ¡†æ¶æä¾›äº†ï¼š
- **çºµæ·±é˜²å¾¡**ï¼šå¤šå±‚æ¬¡çš„æƒé™æ§åˆ¶å’Œæ•°æ®ä¿æŠ¤
- **åˆè§„æ”¯æŒ**ï¼šGDPRã€SOC 2 ç­‰ä¸»æµåˆè§„æ¡†æ¶çš„æŠ€æœ¯å®ç°
- **å®æ—¶ç›‘æ§**ï¼šå…¨é¢çš„å®¡è®¡æ—¥å¿—å’Œå¼‚å¸¸æ£€æµ‹
- **æ•°æ®ä¿æŠ¤**ï¼šPII æ£€æµ‹ã€æ•°æ®è„±æ•å’ŒåŠ å¯†å­˜å‚¨

## åä¸€ã€å·¥ç¨‹åŒ–ä¸è¿ç»´

AI åº”ç”¨çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†éœ€è¦ç‰¹æ®Šè€ƒè™‘ï¼šæ¨¡å‹ç‰ˆæœ¬å˜æ›´ã€å‘é‡ç´¢å¼•é‡å»ºã€ç”¨é‡çªå¢ç­‰éƒ½å¯¹è¿ç»´æå‡ºäº†æ›´é«˜è¦æ±‚ã€‚åŸºäº Supabase çš„å·¥ç¨‹åŒ–å®è·µéœ€è¦åœ¨æ•æ·å¼€å‘ä¸ç¨³å®šè¿è¡Œä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚

### 1ã€ç¯å¢ƒåˆ†å±‚ä¸é…ç½®ç®¡ç†

**å¤šç¯å¢ƒæ¶æ„**ï¼š
- **æœ¬åœ°ç¯å¢ƒ**ï¼šå®Œæ•´åŠŸèƒ½çš„æœ¬åœ° Supabase å®ä¾‹ï¼Œæ”¯æŒç¦»çº¿å¼€å‘
- **é¢„å‘ç¯å¢ƒ**ï¼šä¸ç”Ÿäº§ç¯å¢ƒé…ç½®ä¸€è‡´çš„æµ‹è¯•ç¯å¢ƒ
- **ç”Ÿäº§ç¯å¢ƒ**ï¼šé«˜å¯ç”¨é…ç½®ï¼Œå®Œæ•´ç›‘æ§å’Œå¤‡ä»½ç­–ç•¥

**é…ç½®ç®¡ç†æœ€ä½³å®è·µ**ï¼š
- ä½¿ç”¨ç¯å¢ƒå˜é‡ç®¡ç†ä¸åŒç¯å¢ƒçš„é…ç½®
- å¯†é’¥é€šè¿‡ä¸“ç”¨çš„å¯†é’¥ç®¡ç†æœåŠ¡æ³¨å…¥
- æ•°æ®åº“è¿æ¥ä¸²ã€API Key ç­‰æ•æ„Ÿä¿¡æ¯ä¸å†™å…¥ä»£ç 

### 2ã€æ•°æ®åº“è¿ç§»ä¸ç§å­æ•°æ®

**è¿ç§»ç­–ç•¥**ï¼š
- ä½¿ç”¨ Supabase CLI ç®¡ç†æ•°æ®åº“ schema å˜æ›´
- æ¯ä¸ªè¿ç§»éƒ½åŒ…å«å‰å‘å’Œå›æ»šè„šæœ¬
- å¤§å‹æ•°æ®è¿ç§»åˆ†æ‰¹æ‰§è¡Œï¼Œé¿å…é•¿æ—¶é—´é”è¡¨

**ç§å­æ•°æ®ç®¡ç†**ï¼š
- å¼€å‘ç¯å¢ƒä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œä¾¿äºåŠŸèƒ½æµ‹è¯•
- é¢„å‘ç¯å¢ƒä½¿ç”¨è„±æ•çš„ç”Ÿäº§æ•°æ®ï¼Œä¿è¯æµ‹è¯•çœŸå®æ€§
- ç”Ÿäº§ç¯å¢ƒçš„åˆå§‹æ•°æ®é€šè¿‡ä¸“é—¨çš„ç§å­è„šæœ¬ç®¡ç†

### 3ã€ç›‘æ§ä¸è§‚æµ‹

**å…³é”®ç›‘æ§æŒ‡æ ‡**ï¼š
- **æ•°æ®åº“æ€§èƒ½**ï¼šæ…¢æŸ¥è¯¢ã€è¿æ¥æ± ä½¿ç”¨ç‡ã€é”ç­‰å¾…æ—¶é—´
- **å‘é‡æ£€ç´¢è´¨é‡**ï¼šå¬å›ç‡ã€æ£€ç´¢å»¶è¿Ÿã€ç´¢å¼•å‘½ä¸­ç‡
- **AI æœåŠ¡å¯ç”¨æ€§**ï¼šAPI å“åº”æ—¶é—´ã€é”™è¯¯ç‡ã€token æ¶ˆè€—é€Ÿç‡
- **ç”¨æˆ·ä½“éªŒæŒ‡æ ‡**ï¼šé¡µé¢åŠ è½½æ—¶é—´ã€å¯¹è¯å“åº”é€Ÿåº¦ã€åŠŸèƒ½å¯ç”¨æ€§

**æ—¥å¿—ç®¡ç†**ï¼š
- ç»“æ„åŒ–æ—¥å¿—è¾“å‡ºï¼Œä¾¿äºè‡ªåŠ¨åŒ–åˆ†æ
- é”™è¯¯æ—¥å¿—å®æ—¶å‘Šè­¦ï¼Œå…³é”®ä¸šåŠ¡å¼‚å¸¸ç«‹å³é€šçŸ¥
- å®¡è®¡æ—¥å¿—é•¿æœŸä¿å­˜ï¼Œæ»¡è¶³åˆè§„è¦æ±‚

## åäºŒã€æ€§èƒ½ä¸æˆæœ¬ä¼˜åŒ–

### 1ã€æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–

**è¿æ¥ç®¡ç†**ï¼š
- ä½¿ç”¨è¿æ¥æ± é¿å…é¢‘ç¹å»ºç«‹è¿æ¥çš„å¼€é”€
- åˆç†é…ç½®è¿æ¥è¶…æ—¶æ—¶é—´ï¼Œé˜²æ­¢è¿æ¥æ³„éœ²
- è¯»å†™åˆ†ç¦»ï¼šåªè¯»æŸ¥è¯¢ä½¿ç”¨åªè¯»å‰¯æœ¬ï¼Œå‡å°‘ä¸»åº“å‹åŠ›

**ç´¢å¼•ç­–ç•¥**ï¼š
- ä¸ºé«˜é¢‘æŸ¥è¯¢å­—æ®µå»ºç«‹åˆé€‚çš„ç´¢å¼•
- å®šæœŸåˆ†æç´¢å¼•ä½¿ç”¨æƒ…å†µï¼Œæ¸…ç†æ— æ•ˆç´¢å¼•
- å‘é‡ç´¢å¼•å‚æ•°æ ¹æ®æ•°æ®è§„æ¨¡åŠ¨æ€è°ƒæ•´

**æŸ¥è¯¢ä¼˜åŒ–**ï¼š
- é¿å… N+1 æŸ¥è¯¢é—®é¢˜ï¼Œä½¿ç”¨åˆé€‚çš„å…³è”æŸ¥è¯¢
- å¤§ç»“æœé›†åˆ†é¡µå¤„ç†ï¼Œé¿å…ä¸€æ¬¡æ€§åŠ è½½è¿‡å¤šæ•°æ®
- å¤æ‚èšåˆæŸ¥è¯¢ä½¿ç”¨ç‰©åŒ–è§†å›¾é¢„è®¡ç®—

### 2ã€å‘é‡æ£€ç´¢æ€§èƒ½

**ç´¢å¼•é€‰æ‹©ç­–ç•¥**ï¼š
- æ•°æ®é‡ < 10ä¸‡ï¼šä½¿ç”¨ `ivfflat` ç´¢å¼•ï¼ŒæŸ¥è¯¢é€Ÿåº¦å¿«
- æ•°æ®é‡ > 10ä¸‡ï¼šä½¿ç”¨ `hnsw` ç´¢å¼•ï¼Œå†…å­˜æ•ˆç‡é«˜
- å®šæœŸé‡å»ºç´¢å¼•ï¼Œä¿æŒæœ€ä¼˜æ€§èƒ½

**æŸ¥è¯¢ä¼˜åŒ–**ï¼š
- åˆç†è®¾ç½®ç›¸ä¼¼åº¦é˜ˆå€¼ï¼Œå¹³è¡¡å¬å›ç‡å’Œç²¾ç¡®åº¦
- ä½¿ç”¨æ··åˆæ£€ç´¢ï¼ˆå‘é‡ + å…³é”®è¯ï¼‰ï¼Œæå‡æ£€ç´¢æ•ˆæœ
- ç¼“å­˜çƒ­é—¨æŸ¥è¯¢ç»“æœï¼Œå‡å°‘é‡å¤è®¡ç®—

### 3ã€æˆæœ¬æ§åˆ¶ç­–ç•¥

**å­˜å‚¨æˆæœ¬ä¼˜åŒ–**ï¼š
- å†·çƒ­æ•°æ®åˆ†å±‚ï¼šå†å²å¯¹è¯å½’æ¡£åˆ°ä½æˆæœ¬å­˜å‚¨
- æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼šå®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
- å‹ç¼©ç­–ç•¥ï¼šæ–‡æ¡£å†…å®¹å’Œå‘é‡æ•°æ®ä½¿ç”¨åˆé€‚çš„å‹ç¼©ç®—æ³•

**è®¡ç®—æˆæœ¬æ§åˆ¶**ï¼š
- AI æ¨ç†æˆæœ¬é¢„ç®—ç®¡ç†ï¼Œé˜²æ­¢å¼‚å¸¸æ¶ˆè€—
- ç¼“å­˜ç­–ç•¥å‡å°‘é‡å¤çš„ AI è°ƒç”¨
- åˆç†çš„è¯·æ±‚é™æµï¼Œé¿å…æ¶æ„ä½¿ç”¨

## åä¸‰ã€é€‰å‹å¯¹æ¯”åˆ†æ

### 1ã€vs Firebase

| ç»´åº¦ | Supabase | Firebase |
|------|----------|----------|
| **æ•°æ®åº“** | PostgreSQLï¼Œæ”¯æŒå¤æ‚æŸ¥è¯¢ | NoSQLï¼Œç®€å•æŸ¥è¯¢å‹å¥½ |
| **å‘é‡æ”¯æŒ** | åŸç”Ÿ pgvector æ”¯æŒ | éœ€è¦å¤–éƒ¨å‘é‡æ•°æ®åº“ |
| **æƒé™æ§åˆ¶** | RLS è¡Œçº§å®‰å…¨ | Security Rules |
| **è‡ªæ‰˜ç®¡** | å®Œå…¨å¼€æºï¼Œå¯è‡ªæ‰˜ç®¡ | ä»…äº‘æœåŠ¡ |
| **å­¦ä¹ æ›²çº¿** | éœ€è¦ SQL åŸºç¡€ | ç›¸å¯¹ç®€å• |
| **AI é›†æˆ** | ä¸€ä½“åŒ–è§£å†³æ–¹æ¡ˆ | éœ€è¦å¤šä¸ªæœåŠ¡é›†æˆ |

### 2ã€ä½•æ—¶é€‰æ‹©å…¶ä»–æ–¹æ¡ˆ

**é€‰æ‹©ä¼ ç»ŸæŠ€æœ¯æ ˆçš„åœºæ™¯**ï¼š
- å›¢é˜Ÿæœ‰ä¸°å¯Œçš„å¾®æœåŠ¡æ¶æ„ç»éªŒ
- éœ€è¦æåº¦å®šåˆ¶åŒ–çš„ä¸šåŠ¡é€»è¾‘
- å¯¹ç‰¹å®šæŠ€æœ¯æ ˆæœ‰å¼ºä¾èµ–

**é€‰æ‹©ä¸“ç”¨å‘é‡æ•°æ®åº“çš„åœºæ™¯**ï¼š
- å‘é‡æ•°æ®è§„æ¨¡è¶…è¿‡ 1000ä¸‡æ¡
- éœ€è¦ç‰¹æ®Šçš„å‘é‡ç®—æ³•æ”¯æŒ
- å¯¹æ£€ç´¢å»¶è¿Ÿæœ‰æé«˜è¦æ±‚ï¼ˆ< 10msï¼‰

## åå››ã€å®æˆ˜è·¯çº¿å›¾

### 1ã€é˜¶æ®µä¸€ï¼šMVP éªŒè¯ï¼ˆ2-4 å‘¨ï¼‰

**ç›®æ ‡**ï¼šå¿«é€ŸéªŒè¯æ ¸å¿ƒåŠŸèƒ½ï¼Œè·å¾—ç”¨æˆ·åé¦ˆ

**å…³é”®é‡Œç¨‹ç¢‘**ï¼š
- **Week 1-2**ï¼šåŸºç¡€æ¶æ„æ­å»º
  - Supabase é¡¹ç›®åˆå§‹åŒ–
  - ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
  - åŸºç¡€æ•°æ®æ¨¡å‹è®¾è®¡
- **Week 3-4**ï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°
  - æ–‡æ¡£ä¸Šä¼ ä¸å‘é‡åŒ–
  - ç®€å•çš„é—®ç­”åŠŸèƒ½
  - åŸºç¡€çš„ç”¨æˆ·ç•Œé¢

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] ç”¨æˆ·å¯ä»¥æ³¨å†Œç™»å½•
- [ ] å¯ä»¥ä¸Šä¼ æ–‡æ¡£å¹¶è¿›è¡ŒåŸºç¡€é—®ç­”
- [ ] å¤šç§Ÿæˆ·æ•°æ®éš”ç¦»æ­£å¸¸å·¥ä½œ
- [ ] åŸºç¡€çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ

### 2ã€é˜¶æ®µäºŒï¼šäº§å“åŒ–ï¼ˆ4-6 å‘¨ï¼‰

**ç›®æ ‡**ï¼šå®Œå–„åŠŸèƒ½ï¼Œæå‡ç”¨æˆ·ä½“éªŒï¼Œå‡†å¤‡å•†ä¸šåŒ–

**å…³é”®é‡Œç¨‹ç¢‘**ï¼š
- **Week 1-2**ï¼šé«˜çº§åŠŸèƒ½å¼€å‘
  - æµå¼å¯¹è¯å®ç°
  - å¯¹è¯å†å²ç®¡ç†
  - é«˜çº§æƒé™æ§åˆ¶
- **Week 3-4**ï¼šæ€§èƒ½ä¼˜åŒ–
  - å‘é‡æ£€ç´¢ä¼˜åŒ–
  - æ•°æ®åº“æ€§èƒ½è°ƒä¼˜
  - ç¼“å­˜ç­–ç•¥å®ç°
- **Week 5-6**ï¼šå•†ä¸šåŒ–å‡†å¤‡
  - ç”¨é‡ç»Ÿè®¡ä¸è®¡è´¹
  - é…é¢ç®¡ç†
  - è®¢é˜…ç³»ç»Ÿ

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] æµå¼å¯¹è¯ä½“éªŒæµç•…
- [ ] æ£€ç´¢æ€§èƒ½æ»¡è¶³ç”¨æˆ·æœŸæœ›
- [ ] å®Œæ•´çš„è®¡è´¹å’Œé…é¢ç³»ç»Ÿ
- [ ] ç”¨æˆ·å¯ä»¥è‡ªåŠ©ç®¡ç†è´¦æˆ·

### 3ã€é˜¶æ®µä¸‰ï¼šè§„æ¨¡åŒ–ï¼ˆ6-8 å‘¨ï¼‰

**ç›®æ ‡**ï¼šæ”¯æŒå¤§è§„æ¨¡ç”¨æˆ·ï¼Œå®Œå–„è¿ç»´ä½“ç³»

**å…³é”®é‡Œç¨‹ç¢‘**ï¼š
- **Week 1-3**ï¼šæ‰©å±•æ€§æ”¹è¿›
  - æ•°æ®åº“åˆ†åŒºç­–ç•¥
  - è¯»å†™åˆ†ç¦»å®ç°
  - ç¼“å­˜å±‚æ¶æ„
- **Week 4-5**ï¼šå®‰å…¨ä¸åˆè§„
  - å®¡è®¡æ—¥å¿—å®Œå–„
  - æ•°æ®åŠ å¯†å’Œè„±æ•
  - åˆè§„æ€§æ£€æŸ¥
- **Week 6-8**ï¼šè¿ç»´è‡ªåŠ¨åŒ–
  - CI/CD æµæ°´çº¿
  - ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
  - è‡ªåŠ¨åŒ–æµ‹è¯•

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] æ”¯æŒ 10ä¸‡+ å¹¶å‘ç”¨æˆ·
- [ ] å®Œæ•´çš„ç›‘æ§å’Œå‘Šè­¦ä½“ç³»
- [ ] è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œå›æ»š
- [ ] é€šè¿‡å®‰å…¨åˆè§„å®¡è®¡

## åäº”ã€ç»“è¯­ä¸æ‰©å±•é˜…è¯»

åœ¨ AI ç¼–ç¨‹æ—¶ä»£ï¼Œ**Supabase** ä¸ºæ„å»ºæ™ºèƒ½åº”ç”¨æä¾›äº†ä¸€ä¸ªç‹¬ç‰¹çš„ä»·å€¼ä¸»å¼ ï¼šå®ƒä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ•°æ®åº“ï¼Œè€Œæ˜¯ä¸€ä¸ªå®Œæ•´çš„åç«¯ç”Ÿæ€ç³»ç»Ÿï¼Œç‰¹åˆ«é€‚åˆéœ€è¦å¿«é€Ÿè¿­ä»£å’ŒéªŒè¯æƒ³æ³•çš„ AI åº”ç”¨åœºæ™¯ã€‚

### 1ã€æ ¸å¿ƒä»·å€¼æ€»ç»“

1. **å¼€å‘æ•ˆç‡**ï¼šæ˜¾è‘—ç¼©çŸ­ä»æƒ³æ³•åˆ°äº§å“çš„å¼€å‘å‘¨æœŸ
2. **AI åŸç”Ÿ**ï¼šå‘é‡æ£€ç´¢å’Œæƒé™æ§åˆ¶çš„å®Œç¾ç»“åˆ
3. **ä¼ä¸šå°±ç»ª**ï¼šå†…ç½®çš„å®‰å…¨å’Œåˆè§„èƒ½åŠ›
4. **æˆæœ¬å¯æ§**ï¼šä»å…è´¹å¼€å§‹ï¼ŒæŒ‰éœ€æ‰©å±•

### 2ã€æŠ€æœ¯è¶‹åŠ¿å±•æœ›

- **å‘é‡æ•°æ®åº“æ™®åŠ**ï¼šæœªæ¥æ¯ä¸ªåº”ç”¨éƒ½éœ€è¦è¯­ä¹‰æœç´¢èƒ½åŠ›
- **è¾¹ç¼˜ AI è®¡ç®—**ï¼šæ¨ç†èƒ½åŠ›å‘è¾¹ç¼˜èŠ‚ç‚¹ä¸‹æ²‰
- **å¤šæ¨¡æ€èåˆ**ï¼šæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘çš„ç»Ÿä¸€å¤„ç†
- **AI å®‰å…¨**ï¼šä¸“é—¨é’ˆå¯¹ AI åº”ç”¨çš„å®‰å…¨é˜²æŠ¤

### 3ã€æ‰©å±•é˜…è¯»

**å®˜æ–¹èµ„æº**ï¼š
- [Supabase å®˜æ–¹æ–‡æ¡£](https://supabase.com/docs)
- [pgvector ä½¿ç”¨æŒ‡å—](https://github.com/pgvector/pgvector)
- [Edge Functions å¼€å‘æŒ‡å—](https://supabase.com/docs/guides/functions)

**æŠ€æœ¯æ·±åº¦**ï¼š
- ã€ŠPostgreSQL å‘é‡æ£€ç´¢æ€§èƒ½ä¼˜åŒ–å®æˆ˜ã€‹
- ã€ŠRow Level Security ä¼ä¸šçº§æƒé™è®¾è®¡ã€‹
- ã€ŠAI åº”ç”¨æˆæœ¬ä¼˜åŒ–å®Œå…¨æŒ‡å—ã€‹

**ç¤¾åŒºèµ„æº**ï¼š
- Supabase Discord ç¤¾åŒº
- GitHub Discussions æŠ€æœ¯è®¨è®º
- å®šæœŸçš„å¼€å‘è€… Office Hours

æ— è®ºä½ æ˜¯ç‹¬ç«‹å¼€å‘è€…è¿˜æ˜¯ä¼ä¸šå›¢é˜Ÿï¼Œé‡è¦çš„æ˜¯å…ˆåŠ¨æ‰‹å®è·µï¼Œåœ¨å®é™…é¡¹ç›®ä¸­æ„Ÿå— Supabase çš„å¼ºå¤§åŠŸèƒ½ã€‚AI ç¼–ç¨‹æ—¶ä»£æ‰åˆšåˆšå¼€å§‹ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æ„å»ºæ›´æ™ºèƒ½çš„åº”ç”¨ï¼

**ç¥ä½ å˜å¾—æ›´å¼º!**
