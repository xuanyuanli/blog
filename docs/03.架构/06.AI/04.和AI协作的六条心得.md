---
title: 和 AI 协作的六条心得（个人实践）
date: 2025-09-11 11:30:00
permalink: /pages/ai-collab-6-notes/
categories:
  - 架构
  - AI
tags:
  - 协作
  - 开发流程
author:
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

这几年我和 AI 编程工具一起干活的时间越来越多。我不觉得它是“替代品”，更像一个反应快、力气大、但容易想当然的实习生。配合好了，省两倍时间；配合不好，来回拉扯还不如手写。

下面这六条，是我在项目里反复验证过的做法。不是大道理，都是实操。希望你能少踩点坑。

<!-- more -->

## 1) 先认清工具的性格差异

不同 AI 助手，长处不一样。别一股脑儿全塞给一个。

- 我把 Codex 当“开路先锋”：在终端里把事情拆小、跑命令复现、打最小补丁，并且自己核对结果。它节奏快，闭环强。
- 我把 Claude Code 当“细作工匠”：在 IDE 里顺着上下文，把重构、边界条件、测试和文档一并铺平。它耐心、稳。

一快一稳，搭起来用，速度和质量都更好。更详细的分工参考这篇：[Claude Code 与 Codex 的协同工作](/pages/487069/)。

我的做法：上线前的“能跑起来”，优先交给 Codex；准备合并前的“打磨到位”，交给 Claude Code。

再补一条“口袋口诀”：
- 先开路，后铺平；
- 仓库外看事实、要命令脚本与批量改动，用 Codex；
- 仓库内重构、统一命名、补测试与文档，用 Claude Code；
- 需要跨文件查证和输出可复现步骤时，先走 Codex；需要把边界用例和说明写清楚时，让 Claude Code 收尾。

## 2) 深入理解产品需求（这是核心）

> 能比 AI 更懂产品，是产出好产品的前提。

写代码和做产品，是两件事。AI 很会“把东西做出来”，但“做对什么东西、做到什么程度”，只能靠你来判断。新任务来时，直接把大段描述丢给 AI，它也能给你一堆看似完美的实现，但常常偏题或过度设计。

我现在把“理解需求”当成硬门槛，先过这一关再写一行代码：

- 六个问题先想透：
  1) 给谁用（用户/角色）？在什么场景/心智下？
  2) 具体要完成什么（核心路径是什么）？
  3) 成功的标准是什么（可被验证的验收标准）？
  4) 这次明确不做什么（非目标），避免范围飘。
  5) 约束是什么（时间/成本、技术栈、兼容性、性能/安全/合规）？
  6) 度量什么（关键指标、可观测点、回滚条件）？

- 一页“产品卡”固定下来：
  - 用户与场景：谁、何时、为啥来；
  - 核心用例：主路径 3～5 步；
  - 验收标准：输入/输出、边界与异常；
  - 非目标：这次不解决什么；
  - 约束与风险：时间盒、依赖、合规点；
  - 指标与回滚：成功/失败怎么衡量、何时撤回。

- 和 AI 的沟通也更“产品向”：
  “先帮我复述需求并列出主路径与非目标；按约束给两到三个实现策略，标出取舍与影响面；最后给出‘最小可行版本’和可验证的验收步骤。不要引新依赖，不改变既有接口行为。”

一个小例子：我们想在“支付成功页”里做推荐。AI 第一反应是要做个半成品推荐系统，参数可调、A/B 模型齐活；但业务真的需要的，是“先用静态榜单把曝光盘起来，时机成熟再做个可替换的策略层”。如果你没把“阶段性目标与非目标”讲清楚，AI 会按最炫的实现去跑，代价高、见效慢、还不好回退。

## 3) 每一步都要“过关”——及时修正

一个朴素的算术：假设 AI 每一步 90% 正确，连续 10 步后整体正确率大概只有 0.9^10 ≈ 34%。不是模型不行，是复杂工作本来就这样。解法只有一个：每一步都过关。

我的节奏是这样的：

- 小步前进：把任务切成 10～20 分钟能完成并验证的小块。
- 事实驱动：用日志、命令、最小复现说话，少用“感觉应该对”。
- 能跑就跑：有命令就跑，有脚本就执行；别口头评审。
- 允许小瑕疵：产品逻辑先对，小的程序 bug 可以在下一步修；别为了“完美一次成型”拖慢节奏。

再给一个“验证三件套”：

- 一条命令：跑起来（构建/测试/脚本/服务）。
- 一份最小数据：输入样例或最小请求。
- 一段期望输出：日志片段/返回体/指标变化。

示例（按你项目替换命令）：
```
rg -n "retry" src/handlers/
npm test -t "payment idempotency"
curl -s http://localhost:3000/health | jq
```

如果单步卡住超过 20 分钟：换方法（缩小范围/造更小的复现），或回滚到上一稳态再分更小的步子。

特别是新项目，别指望 AI 帮你把上下文都学会。你要学的，一点不比它少。

## 4) 先用你最熟悉的语言，把路打通

每种语言/生态都有擅长和短板。遇到新需求，我先用自己最熟悉的栈把“产品逻辑”跑通：

- 熟悉的工具链，能让你把注意力放在业务而不是语法/工具上；
- 熟悉的调试方式，问题能快定位；
- AI 在“你熟的领域”里，也更容易跟上你的节奏。

不熟的栈也要学，但先别把“学习成本”和“交付压力”绑在同一次任务里。把路打通以后，再考虑换栈或抽象沉淀。

“快跑/慢收”的两段式做法：
- 第 1 段（快跑）：用最熟悉的栈做 MVP，把关键路径通了，有监控可回退。
- 第 2 段（慢收）：评估是否需要换栈/抽象，按收益与成本排期做。

换栈前三问：
1) 不换真的不行吗（硬约束/团队一致性/生态能力）？
2) 学习与切换成本，是否被性能/维护性收益覆盖？
3) 有降级与回滚路径吗？

## 5) 质量要前置，别等集成再补

我尽量把“质量关”放到前面：

- 规范与检查：统一格式和 Linter，小 PR、小范围、可复现；
- 测试要覆盖关键路径：哪怕只有冒烟+边界+回归三类最小集；
- 可观测性：关键日志、指标和告警，便于回放和回滚；
- 变更说明：每次都写“怎么验证”，最好一键跑通；
- 安全/合规：输入校验、脱敏、依赖审计，不为以后埋雷。

这不“繁琐”，这是让后面的工作更轻的唯一办法。

PR 描述我一般这样写，简洁但够复现：
```
【动机】为什么改、关联 issue/告警链接
【范围】改了哪些模块/文件（不改哪些）
【验证】命令/脚本/用例（复制即可复现）
【风险】影响面、兼容性、旁路假设
【回滚】如何快速撤回/关闭开关
```

可观测性基线：
- 关键路径有可读日志（含关键参数、请求 id）；
- 至少 1 个指标可观测（QPS/延迟/错误率），并设置阈值告警；
- 出错能定位（trace id/链路），能复现。

## 6) 去繁为简，能删就删

做事要讲究“轻”。

- 能不引依赖就别引，能脚本化就别手工，能延后就先不做；
- 接口别一口气设计到“未来十年”，先满足眼前最小需求；
- 命名、结构、文档都越清爽越好。代码是写给未来的自己（和同事）看的。

复杂度是利息，一旦借了就要还。越早降，越轻松。

我常用的“删减三问”：
1) 这东西现在不用会怎样？
2) 两周后我们还需要它吗？
3) 有更便宜的替代吗（删除/延后/脚本化）？

以及一个取舍原则：当你在“抽象一个通用框架”和“先打一个能满足 80% 场景的补丁”之间犹豫，优先后者。抽象留到出现第三个强需求时再做，届时证据更充分、设计更简单。

---

最后，留两句话当提醒：

- 你来定目标、边界和取舍；AI 来干活、给证据、按事实修正。
- 别追求“一次完美”，追求“步步可验、随时能退”。

只要节奏握在你手里，AI 就是好用的加速器，而不是随机数发生器。
