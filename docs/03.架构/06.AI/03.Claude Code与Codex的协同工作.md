先说下 Codex。它的核心是 GPT‑5：规划力强、跨文件理解到位、执行闭环稳定。对开发的直接价值有三点：

- 大局规划：能把复杂需求拆成可执行的步骤与里程碑，先定方向再落笔。
- 执行与验证：自动生成补丁、运行命令并校验结果，形成“计划—执行—验证—复盘”的闭环。
- 搜索与文档：在大仓库里快速定位影响面（配合 `rg`/`git`），同时产出变更说明、迁移指南、README 片段。

CLI 本身开源、贴近本地环境，这些都是加分项，但真正拉开差距的，是 GPT‑5 带来的稳健推理与长链路执行力。

关于 Claude Code 的安装与最佳实践，我已经单独写过，更系统也更细：[Claude Code 最佳实践](/pages/claude-code-best-practices/)。

这篇文章主要讲两者怎么配合把效率拉满。

<!-- more -->

小小的环境建议：在 Windows 下，用 Codex 尽量在 WSL2 里安装和运行。PowerShell 下目前体验一般，尤其是写文件时会频繁弹确认，节奏容易被打断。组合推荐是 WSL2 + 常用开发环境（Node/Go/Python）+ 你熟悉的包管理器。

至于 Codex 和 Claude Code 的分工，我更愿意用“互补”来形容。先把他们各自的自我评价放上来，作为一个参考。

我给 Codex 的提示词是：
> 你与 claude code，你们两个各自特点是什么？你的优势是？他的优势是？

他的回答是：
```markdown
- 我：偏执行与验证导向。在你本地仓库里改文件、跑命令、写补丁、分步计划与复盘，快速把想法落到可运行的变更。
- Claude Code：偏解释与稳健重构。长文本讲解、代码走读、风格统一与大范围重构提案更细致，输出往往更保守、说明更充分。

我的优势

- 工具链实操：直接改动仓库、运行脚本/测试、给出最小可行补丁并迭代。
- 任务规划清晰：用可视化步骤推进，便于对齐与回滚。
- 快速原型与修复：小步快跑，尽快把问题复现→修正→验证闭环。
- 上下文贴合当前环境：以你提供的项目与命令结果为准，减少臆测。

他的优势

- 解释与文档化：对复杂代码/架构给出更长、更条理的说明与评审意见。
- 稳健的大改动思路：跨文件的重构规划、风格统一、测试建议更全面。
- 自然语言推理强：需求澄清、边界与权衡的文字化分析细腻。
- 对长上下文友好：大段代码与讨论整合成一致的设计/重构方案。

怎么选

- 需要立即在仓库里改代码并验证结果 → 选我。
- 需要成体系的重构方案、代码评审长文、风格把关 → 选他。
- 既要执行又要评审：先用他出方案，再由我落地验证与微调。
```

给 Claude Code 的提示词是：
> openai 新出了 codex cli，也是面向终端的 AI 编码工具，你们两个各自特点是什么？你的优势是？他的优势是？

他的回答是：
```markdown
OpenAI Codex CLI 的优势：

1. 开源免费 - Apache-2.0 许可，完全开源
2. 隐私保护 - 代码完全在本地处理
3. 性能优秀 - Rust 实现，内存安全，启动快
4. 成本低 - 使用现有 ChatGPT 订阅即可

Claude Code 的优势：

1. SWE-bench 表现更好 - 72.7% vs 69.1% 准确率
2. 长上下文处理 - 更适合大型代码库分析
3. 中文支持 - 在中文环境下表现更好
4. IDE 集成 - 与 JetBrains 等深度集成
5. 复杂推理 - 在架构设计等复杂任务上表现更好
```

我的亲身体验：Codex 在“铺路搭桥、统筹规划”上很有劲儿，Claude Code 在“细致落地、稳健重构”上更稳。两者配合，效率和质量都能明显上一个台阶。

下面是我在实际项目里摸索出来的一套协同打法，能在多数团队里落地，简单有效。

## 定位与互补

- 一句话概括：Codex 擅长“把抽象落为具体”，Claude Code 擅长“把具体做得漂亮”。
- 典型分工：
  - 规划与验证闭环：Codex 拉出任务拆解、生成补丁、跑命令验证；
  - 解释与重构：Claude Code 给出详细评审意见、代码走读、统一风格与接口；
  - 交接节奏：先方案后落地，先粗后细，先稳后快。

## 推荐协同工作流

用在新功能、Bug 修复、重构上都顺手，核心就是“交接清晰 + 小步快跑 + 每轮有验证”。

1) 需求与约束澄清（Codex 发起）
- 明确目标、输入输出、边界与非目标；
- 列出风险点和未知数，给出调研与验证计划；
- 产出：任务拆解、目录/模块草图、验收标准清单。

2) 方案细化与实现（Claude Code 承接）
- 逐步实现每个任务，先写骨架再补细节；
- 写必要的测试/脚手架/文档注释；
- 保持提交粒度小、信息充分。

3) 验证与复盘（Codex 回看）
- 跑构建与测试，做端到端校验；
- 给出问题清单、性能/安全建议与必要的补丁；
- 对关键变更做一次“可回滚”评估。

4) 修正与打磨（Claude Code 收尾）
- 根据问题清单逐项修正；
- 统一命名风格、接口一致性与文档；
- 合并前最后一次自检。

为了减少来回沟通，建议用一个固定的“交接模板”。我常用下面这份：

```markdown
【背景】
—— 这次改动的动机与上下文（相关 issue/PR/业务目标）

【目标与非目标】
—— 这次要达成什么，不做什么（避免范围蔓延）

【输入/输出】
—— 输入文件/接口/数据；期望输出与验收标准

【约束】
—— 技术栈/兼容性/性能/安全/合规/交付时间

【实现思路】
—— 目录结构、模块划分、关键接口草图

【验证方式】
—— 如何验证功能正确（测试/脚本/命令/手工步骤）

【风险与回滚】
—— 潜在风险、监控点、回滚方案

【提交说明】
—— 预期提交粒度与信息格式（例如 conventional commits）
```

## 常见场景的配方

1) 新项目/新功能
- Codex：写 PRD 要点、系统边界、时序/依赖、目录结构草案；
- Claude Code：按草案实现最小可用版本（MVP），同时起单元测试与示例；
- Codex：跑一轮构建与测试，收敛问题清单；
- Claude Code：对清单逐项修复与优化，完善文档。

2) Bug 修复
- Codex：复现问题、最小化例子、定位根因，提出修复方案与影响面；
- Claude Code：评审方案、补充边界测试，提交最小修复补丁；
- Codex：验证回归风险，建议守护性监控或特性开关；
- Claude Code：合并前打磨，补充变更记录。

3) 大范围重构/风格统一
- Claude Code：先出重构提案（目标、边界、迁移路径、风险控制）；
- Codex：以脚本+命令的方式批量验证与改造（rg/awk/jq 等组合拳）；
- Claude Code：逐模块走读、统一命名与接口、清理坏味道；
- Codex：最后一轮性能/安全扫描与基准对比。

## 协作细节与落地技巧

- 粒度控制：把任务拆到“十几分钟内能完成并验证”的粒度，避免两边同时改动同一批文件。
- 明确输入：指向具体路径与文件，不要给“泛泛而谈”的目标。比如“重构 utils/formatters/ 下所有日期函数，要求兼容现有单测”。
- 小步提交：每个提交写清楚动机、范围与验证方式，最好附带可重放的命令。
- 上下文共享：
  - 项目级约定写在 `README/CLAUDE.md`；
  - 临时协作上下文放在 `docs/dev/handovers/<topic>.md`；
  - 大改造前开分支，避免干扰主线。
- 指令模板：
  - 给 Codex 的：“请先给出任务拆解与验证计划，再分步生成补丁并执行命令验证。”
  - 给 Claude Code 的：“请基于以下变更目标给出稳健的重构方案与代码走读，最后附上回滚与测试建议。”

## 本地环境与工程习惯

- 使用 WSL2：仓库放在 Linux 文件系统，避免 `/mnt/c` 带来的 I/O 与权限问题。
- 行尾与权限：`git config core.autocrlf input`，避免 CRLF；脚本文件注意可执行位。
- 忽略大目录：用 `.claudeignore`/工具自带忽略配置排除 `node_modules/、dist/、.git/、logs/`，提升响应。
- 终端与 IDE：终端里用 Codex 跑命令、生成补丁；IDE 里用 Claude Code 走读与重构，互相补位。
- 验证闭环：无论谁改动，最终都要“可构建、可测试、可回滚”。

## 一个小例子：给服务加健康检查

目标：现有服务缺少 `/health` 接口，需要加一个返回依赖状态的健康检查，纳入现有监控。

步骤：
1) Codex：梳理现有路由/依赖、确认需要检查的组件（DB/Cache/第三方 API），产出接口约定与返回格式；
2) Claude Code：实现 `/health` 路由与依赖探活逻辑，补上单元测试与 README 中的 API 文档；
3) Codex：本地启动服务，跑一轮 `curl`/集成测试，生成问题清单（例如超时处理、降级策略）；
4) Claude Code：修正问题、统一日志与错误码，提交变更；
5) Codex：建议加简单的基准测试与告警阈值设置，最终合并。

这类“需求清楚、影响面可控”的任务非常适合双人协同：效率高、质量稳定。

## 常见坑与避坑建议

- 同步困难：一次只开一个明确主题，交接时用固定模板，避免话题漂移。
- 冲突频繁：大改前先拉分支并约定修改范围，尽量避免并行改同一模块。
- 输出冗长：限定目录与文件，带上明确的验收标准与可运行命令。
- 环境不一致：都在 WSL2 下工作，固定 Node/Java 版本，脚本里打印版本号。
- 验证缺失：任何改动都要有“怎么验证”的说明，最好是可重放的脚本或命令。
- 安全与合规：不要把密钥、内网地址、客户数据放进对话或提交；必要时做脱敏。

## 总结

工具各有锋芒，但真正决定效率的，是协作方式。把 Codex 当成“快速把事做成”的执行手，把 Claude Code 当成“把事做漂亮”的打磨手，中间用清晰的交接与小步验证串起来，基本就不会跑偏。

当然，实际环境千差万别，你可以把上面的流程当作骨架，结合团队惯例去调整。只要坚持“交接清楚、粒度可控、每轮有验证”，让 Codex 和 Claude Code 搭班子，一般都能拿到又快又稳的结果。
