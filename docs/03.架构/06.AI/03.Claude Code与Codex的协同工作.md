---
title: Claude Code与Codex的协同工作
date: 2025-09-01 22:31:49
permalink: /pages/487069/
categories:
  - 架构
  - AI
tags:
  - 
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

下班前 30 分钟，线上冒了个小火苗。日志一片红，大家都在看。我开了两个窗口：左边是 Codex，在终端里把问题拆成几步、跑命令复现、给出最小补丁；右边是 Claude Code，在 IDE 里顺手把边界条件补上，单测也跟着写齐。二十多分钟，告警消失，PR 合上。那一刻我意识到——这俩工具不该单打独斗。

一句话版：Codex 负责“开路”（GPT‑5：拆—做—验—写），Claude Code 负责“铺平”（长上下文、稳重构、好解释）。把它们绑在一起，节奏就顺了。

<!-- more -->

先说 Codex。它的底层是 GPT‑5，能把复杂事拆成可执行的小步，自己改文件、跑命令、打补丁，还会对结果做核对。它在大仓里找东西也很快（配合 `rg`/`git`），并且能顺手把变更说明、迁移指南、README 片段整理出来。CLI 开源、本地贴身是加分项，但真正强在“闭环能力”：计划—执行—验证—复盘。

Claude Code 就别展开了，装配与细作这块，它是熟手。安装与最佳实践看这里：[Claude Code 最佳实践](/pages/claude-code-best-practices/)。

你可能会问：这俩不都是写代码的？为什么要两个？
- 因为“开路”和“铺平”是两件事。一个人可以都做，但不一定快；两个人搭着来，速度和质量更稳。
- 因为节奏不同。Codex 擅长快拆快试，Claude Code 擅长慢想慢收尾。把节奏排好，就不会互相拖拽。

下面是我总结出来的一套“开路—铺平”的协作法，简单耐用。

## 怎么搭档

三件事记住就够了：交接清楚、小步快跑、每轮都验证。

1) 需求与约束（Codex 开场）
- 把目标、输入输出、边界和非目标说清楚；
- 列出风险和未知数，定验证方式；
- 产出任务拆解、目录草图、验收清单。

2) 方案到实现（Claude Code 接力）
- 先搭骨架，再补细节；
- 必要的测试、脚手架、注释一起上；
- 提交尽量小且可复现。

3) 验证与复盘（Codex 回看）
- 跑构建与测试，端到端走一遍；
- 列问题清单，带上性能/安全建议和必要补丁；
- 关键变更给出回滚思路。

4) 修正与打磨（Claude Code 收尾）
- 按清单逐条修；
- 统一命名、接口和文档；
- 合并前最后自检。

交接就用这张小卡片：

```markdown
【背景】动机与上下文（相关 issue/PR/业务目标）
【目标/非目标】做什么、不做什么
【输入/输出】文件/接口/数据与验收标准
【约束】技术栈/兼容性/性能/安全/时间
【思路】目录结构、模块划分、关键接口
【验证】测试/脚本/命令/手工步骤
【风险/回滚】潜在风险、监控点、回滚方案
```

## 三个高频场景

1) 新功能上线
- Codex：定边界、列依赖、画目录草案；
- Claude Code：做个最小可用版本（MVP），顺手起单测和示例；
- Codex：跑构建与测试，收敛问题清单；
- Claude Code：逐项修复与优化，补上文档。

2) 修 Bug
- Codex：复现、做最小案例、查根因，给修复方案和影响面；
- Claude Code：评审方案、补边界测试，提交最小补丁；
- Codex：看回归风险，建议监控或特性开关；
- Claude Code：合并前打磨，补变更记录。

3) 大范围重构
- Claude Code：先给重构提案（目标、边界、迁移路径、风控）；
- Codex：用脚本和命令批量改（`rg`/`awk`/`jq` 组合拳）；
- Claude Code：逐模块走读，统一命名与接口，清理坏味道；
- Codex：最后一轮性能/安全扫描与基准对比。

## 细节与习惯

- 粒度要小：单次任务控制在十几分钟内能做完并验证。
- 说得具体：给清晰路径和文件，别“泛泛而谈”。
- 小步提交：写明动机、范围和验证方式，最好能一键复现。
- 同步上下文：
  - 约定放在 `README/CLAUDE.md`；
  - 临时上下文放 `docs/dev/handovers/<topic>.md`；
  - 大改先开分支，别影响主线。
- 给工具的“话术”：
  - 对 Codex：先拆解与验证，再分步补丁+命令验证。
  - 对 Claude Code：给稳健重构方案和走读，附回滚与测试建议。

## 一个 30 分钟的现场

场景：支付回调偶发 500。

怎么配合：
1) Codex：用日志片段和请求样本复现问题，定位到重试逻辑的竞态；
2) Claude Code：把重试变幂等，补上锁粒度与异常分流，单测覆盖边界；
3) Codex：本地与测试环境全走一遍，补充压力测试脚本；
4) Claude Code：统一错误码与告警文案，补 README 的“运维须知”。

半小时收工。关键不是“谁更强”，而是“谁先上、谁后补”，步子小且有验证。

## 常见坑

- 一次搞太多：一个主题干到底，交接用固定模板。
- 并行撞车：大改先拉分支，提前说好边界。
- 话多事少：限定目录和文件，配清晰的验收与命令。
- 环境打架：统一在 WSL2，下定版本，脚本里打印版本号。
- 没有闭环：每次改动都写清楚“怎么验证”，最好能一键复现。
- 合规要紧：密钥、内网、客户数据不要进对话或提交，必要时脱敏。

## 落地小贴士（Windows）

用 Codex，直接上 WSL2。PowerShell 写文件会弹确认，节奏会断。把仓库放到 WSL2 的 Linux 盘（比如 `/home/<user>/code`），配好 Node/Go/Python 和常用包管理器，就顺了。

## 收个尾

工具只是工具。真让人提速的，是“开路—铺平—闭环”这套机制。从下个任务开始试试：先让 Codex 把路铺出来，再交给 Claude Code 把路铺平，最后一起把验证补牢。
