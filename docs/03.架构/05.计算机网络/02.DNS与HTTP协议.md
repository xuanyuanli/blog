---
title: DNS与HTTP协议
date: 2023-08-27 17:10:00
permalink: /pages/20d997/
categories:
  - 架构
  - 计算机网络
tags:
  - DNS
  - HTTP
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

在日常的网络使用中，我们习惯性地在浏览器地址栏输入网址，比如 `www.google.com`，然后就能访问到对应的网站。这个看似简单的过程背后，其实涉及了两个重要的网络协议：`DNS` 和 `HTTP`。

`DNS`（Domain Name System，域名系统）负责将我们输入的域名转换为计算机能够理解的 `IP` 地址，相当于互联网的"电话簿"。而 `HTTP`（Hypertext Transfer Protocol，超文本传输协议）则负责在客户端和服务器之间传输网页内容，是万维网数据交换的基础。

这两个协议都属于网络体系结构中的应用层，在互联网通信中发挥着至关重要的作用。本文将深入探讨它们的工作原理、技术特性以及安全机制，帮助你更好地理解现代网络通信的底层逻辑。
<!-- more -->

## 一、DNS协议详解

想象一下，如果没有 `DNS`，我们每次想访问百度就得记住它的 `IP` 地址 `110.242.68.66`，想访问淘宝就得记住另一个复杂的数字组合。显然，这对用户来说是极不友好的。

`DNS` 的核心价值就在于解决了这个痛点。每台联网设备都有一个独一无二的 `IP` 地址作为网络身份标识，但人类的大脑更适合记忆有意义的词汇而非数字串。`DNS` 就像是一个巨大的通讯录，当你输入 `www.baidu.com` 时，它会告诉你对应的 `IP` 地址是多少。

### 1、DNS查询的完整流程

`DNS` 查询看起来很简单，但背后的机制相当精妙。让我们以访问 `www.example.com` 为例，看看这个过程是怎么进行的：

**第一步：本地查询**
当你在浏览器输入域名并按下回车，系统首先会检查本地是否有缓存记录。如果最近访问过这个网站，可能直接就能拿到结果，整个过程几乎是瞬间完成的。

**第二步：递归查询开始**
如果本地没有缓存，浏览器会向配置的 `DNS` 解析器发送查询请求。这个解析器通常是你的网络运营商提供的，也可能是你手动设置的公共 `DNS`（比如 Google 的 `8.8.8.8` 或 Cloudflare 的 `1.1.1.1`）。

**第三步：根域名服务器**
如果递归解析器也没有缓存，它会向全球 13 台根域名服务器中的一台发起查询。根服务器不会直接告诉你 `www.example.com` 的 `IP` 地址，但它会告诉你："要查询 `.com` 域名，请去找 `.com` 的顶级域名服务器"。

**第四步：顶级域名服务器**
递归解析器接着向 `.com` 顶级域名服务器查询。这台服务器管理着所有 `.com` 域名的信息，它会回复："要查询 `example.com`，请去找 `example.com` 的权威域名服务器"。

**第五步：权威域名服务器**
最后，递归解析器向 `example.com` 的权威域名服务器查询。这台服务器掌握着 `example.com` 及其所有子域名的准确 `IP` 地址信息，它会返回 `www.example.com` 对应的 `IP` 地址。

**第六步：返回结果**
递归解析器收到权威答案后，会将结果缓存起来（通常缓存几小时到几天），然后把 `IP` 地址返回给你的浏览器。浏览器拿到 `IP` 地址后，就可以直接与目标服务器建立连接了。

这整个过程看起来复杂，但实际上通常在几十毫秒内就能完成。而且由于缓存机制的存在，后续的查询会更快。

### 2、DNS配置与优化

在实际使用中，有几个关于 `DNS` 的实用知识点值得了解：

**DNS服务器的获取方式**
当你的设备通过 `DHCP` 获取 `IP` 地址时，路由器不仅会分配 `IP` 地址和网关信息，还会一并推送默认的 `DNS` 服务器地址。这就是为什么大部分时候你不需要手动配置 `DNS` 就能正常上网的原因。

**手动配置DNS的好处**
不过，手动配置 `DNS` 服务器往往能带来更好的体验。比如在 `Linux` 系统中，你可以编辑 `/etc/resolv.conf` 文件，添加 `nameserver 8.8.8.8` 这样的配置，然后通过 `sudo systemctl restart networking` 重启网络服务生效。

**DNS冗余机制**
为了保证服务的可靠性，通常会配置主备两个 `DNS` 服务器。当主 `DNS` 无法响应时，系统会自动切换到备用 `DNS`，这样能避免因为单点故障导致的网络中断。

**公共DNS服务器的选择**
目前比较知名的公共 `DNS` 服务器包括：
- Cloudflare：`1.1.1.1`（号称最快的公共DNS）
- Google：`8.8.8.8`（覆盖范围最广）
- 阿里云：`223.5.5.5`（国内访问较优）
- 腾讯云：`119.29.29.29`（游戏优化较好）

选择哪个主要看你的网络环境和具体需求，一般来说，地理位置越近的 `DNS` 服务器响应速度越快。

## 二、HTTP协议深度解析

### 1、HTTP协议的本质

如果说 `DNS` 解决的是"找到谁"的问题，那么 `HTTP` 解决的就是"怎么说话"的问题。当浏览器通过 `DNS` 拿到服务器的 `IP` 地址后，接下来就需要与服务器进行对话，获取网页内容，这时候就轮到 `HTTP` 协议上场了。

`HTTP`（Hypertext Transfer Protocol，超文本传输协议）定义了客户端和服务器之间交流的"语言规则"。就像我们人与人交流需要遵循语法一样，网络设备之间的通信也需要遵循特定的协议格式。

### 2、HTTP的工作机制

`HTTP` 采用的是典型的请求-响应模式，整个过程可以用一个简单的比喻来理解：

**客户端发起请求**
就像你去餐厅点餐，你会告诉服务员："我要一份宫保鸡丁"。在 `HTTP` 中，浏览器会向服务器发送类似的请求："我要获取首页的HTML内容"。

**服务器处理请求**
餐厅的厨师收到订单后，会根据菜谱制作对应的菜品。同样，Web服务器收到请求后，会根据请求的路径和参数，找到对应的资源或执行相应的逻辑。

**服务器返回响应**
厨师做好菜后，服务员会把菜端给你，并告诉你菜品的相关信息。Web服务器也会把请求的内容（比如HTML页面）连同一些元信息（比如内容类型、状态码等）一起返回给浏览器。

**客户端处理响应**
你收到菜品后会品尝享用。浏览器收到响应后，会解析HTML内容，渲染成我们看到的网页界面。

### 3、HTTP的无状态特性

`HTTP` 有一个重要特性：无状态。这意味着每次请求都是独立的，服务器不会记住之前的交互内容。

这就像每次你去餐厅，服务员都不记得你之前点过什么菜一样。虽然这种设计让服务器的实现变得简单、可扩展，但也带来了一个问题：如何识别用户身份？

为了解决这个问题，业界发明了 `Cookie` 和 `Session` 机制。`Cookie` 就像是一张会员卡，服务器第一次响应时会给你一张卡片，之后你每次来都带着这张卡，这样服务器就能识别你的身份了。

### 4、HTTP协议的演进历史

`HTTP` 协议的发展历程就像是互联网技术进步的一个缩影，每个版本的升级都解决了当时面临的实际问题：

**HTTP/0.9（1991年）：万事开头难**
最初的 `HTTP` 版本极其简陋，由万维网之父蒂姆·伯纳斯-李设计。它只支持 `GET` 请求，没有头部信息，只能传输 `HTML` 文档。就像是远古时代的通信方式，功能有限但足以证明概念的可行性。

**HTTP/1.0（1996年）：功能初现**
这个版本可以说是真正实用的 `HTTP` 协议。它增加了 `POST`、`HEAD` 等请求方法，引入了状态码和头部字段，可以传输各种类型的文件。不过，每个请求都需要建立新的连接，效率还不够高。

**HTTP/1.1（1997年）：成熟稳定**
这是目前使用最广泛的版本，解决了 `HTTP/1.0` 的很多问题。最重要的改进是引入了持久连接，一个 `TCP` 连接可以发送多个请求，大大提高了效率。同时，`Host` 头部的引入让一台服务器可以托管多个网站。

**HTTP/2（2015年）：性能飞跃**
这个版本着重解决性能问题。采用二进制格式传输，支持多路复用（一个连接同时处理多个请求），头部压缩减少了带宽消耗，服务器推送功能让页面加载更快。可以说是对传统 `HTTP` 的一次革命性改进。

**HTTP/3（2019年）：面向未来**
最新的版本基于 `QUIC` 协议，将传输层从 `TCP` 改为 `UDP`，进一步减少了延迟。特别是在移动网络环境下，`HTTP/3` 的优势更加明显。虽然还在推广阶段，但已经有不少网站开始支持。

每个版本的升级都保持了向后兼容，这也是 `HTTP` 协议能够平滑演进的重要原因。

### 5、HTTP协议的核心价值

`HTTP` 协议之所以能成为互联网的基石，主要体现在以下几个方面：

**统一的数据传输标准**
`HTTP` 为各种类型的数据传输提供了统一的格式规范。无论是网页的 `HTML` 内容、API 的 `JSON` 数据，还是图片、视频等多媒体资源，都可以通过 `HTTP` 协议进行传输。这种标准化大大简化了应用程序的开发。

**灵活的资源访问方式**
通过不同的 `HTTP` 方法（GET、POST、PUT、DELETE等），客户端可以对服务器资源进行各种操作。这种设计模式被广泛应用于 `RESTful API` 的设计中，让不同系统之间的集成变得更加简单。

**高效的缓存机制**
`HTTP` 协议内置了强大的缓存控制功能。浏览器可以将常用资源缓存到本地，减少网络请求，提升用户体验。这对于改善网站性能、减轻服务器压力都有很大帮助。

**云计算的技术基础**
现代的云服务几乎都是基于 `HTTP/HTTPS` 协议提供的。从文件存储到容器编排，从数据库访问到人工智能服务，`HTTP` 协议的简单性和可扩展性为云计算的蓬勃发展提供了技术保障。


## 三、HTTP协议的工作原理

### 1、请求-响应的完整过程

要深入理解 `HTTP` 协议，我们需要拆解一次完整的网页访问过程。假设你要访问 `https://www.example.com/article/123`：

**第一阶段：建立连接**
浏览器首先需要与服务器建立 `TCP` 连接。对于 `HTTP`，默认使用80端口；对于 `HTTPS`，默认使用443端口。如果是 `HTTPS`，还需要进行 `TLS` 握手来建立加密通道。

**第二阶段：构造请求**
连接建立后，浏览器会构造一个 `HTTP` 请求消息，这个消息包含三个部分：

```
GET /article/123 HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml
Accept-Language: zh-CN,zh;q=0.9
Connection: keep-alive

```

- **请求行**：说明请求方法（GET）、资源路径（/article/123）和协议版本
- **请求头**：提供额外信息，如主机名、浏览器类型、接受的内容类型等
- **请求体**：在这个例子中为空，但在 POST 请求中会包含要提交的数据

**第三阶段：服务器处理**
服务器收到请求后，会进行一系列处理：
1. 解析请求行，确定要访问的资源
2. 检查请求头，了解客户端的能力和偏好
3. 根据路径查找对应的处理逻辑（可能是静态文件，也可能是动态生成的内容）
4. 执行业务逻辑，准备响应数据

**第四阶段：返回响应**
服务器处理完成后，会返回一个 `HTTP` 响应：

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 1024
Cache-Control: max-age=3600
Set-Cookie: sessionid=abc123; HttpOnly

<!DOCTYPE html>
<html>
<head><title>文章标题</title></head>
<body>文章内容...</body>
</html>
```

- **状态行**：包含协议版本、状态码（200表示成功）和状态消息
- **响应头**：描述响应的特性，如内容类型、长度、缓存策略等
- **响应体**：实际的内容数据

**第五阶段：客户端渲染**
浏览器收到响应后，会根据内容类型进行相应处理。如果是 `HTML`，就会解析DOM、加载CSS和JavaScript，最终渲染出用户看到的网页。

### 2、HTTP请求方法详解

`HTTP` 方法定义了客户端想要对服务器资源执行的操作类型。可以把它们理解为对资源的不同"动作"：

**GET - 获取资源**
这是最常用的方法，用于从服务器获取数据。就像是去图书馆借书，你只是想要看到内容，不会对书本身造成任何改变。GET 请求应该是"安全"的，不会修改服务器上的数据。

```
GET /users/123 HTTP/1.1  // 获取ID为123的用户信息
```

**POST - 创建资源**
用于向服务器提交数据，通常用来创建新资源。比如注册新用户、发布文章、上传文件等。POST 请求可能会改变服务器状态。

```
POST /users HTTP/1.1      // 创建新用户
Content-Type: application/json

{"name": "张三", "email": "zhangsan@example.com"}
```

**PUT - 更新资源**
用于更新或替换现有资源。如果资源不存在，有时也会创建新资源。PUT 操作是"幂等"的，多次执行同样的PUT请求结果应该一致。

```
PUT /users/123 HTTP/1.1   // 更新ID为123的用户信息
Content-Type: application/json

{"name": "李四", "email": "lisi@example.com"}
```

**DELETE - 删除资源**
用于删除指定资源。这个操作需要谨慎使用，因为删除操作通常是不可逆的。

```
DELETE /users/123 HTTP/1.1  // 删除ID为123的用户
```

**HEAD - 获取元信息**
与 GET 类似，但只返回响应头，不返回响应体。常用于检查资源是否存在、获取资源大小等场景。

**OPTIONS - 查询支持的方法**
用于查询服务器支持哪些HTTP方法，常见于跨域请求的预检（preflight）阶段。

**PATCH - 部分更新**
与 PUT 不同，PATCH 只更新资源的部分字段，而不是替换整个资源。

这些方法的设计遵循了 `RESTful` 架构风格，让API接口更加语义化和易于理解。

### 3、HTTP状态码解读

状态码是服务器告诉客户端请求处理结果的"暗号"。通过三位数字的组合，我们可以快速了解发生了什么：

**1xx - 信息提示（少见但重要）**
这类状态码比较少见，主要用于协议层面的通信：
- `100 Continue`：告诉客户端可以继续发送请求体，常用于大文件上传场景

**2xx - 成功响应（皆大欢喜）**
- `200 OK`：最常见的成功状态，表示请求被正确处理
- `201 Created`：资源创建成功，通常用于POST请求的响应
- `204 No Content`：请求成功但没有返回内容，常见于DELETE操作

**3xx - 重定向（换个地方）**
- `301 Moved Permanently`：资源永久性迁移，搜索引擎会更新索引
- `302 Found`：临时重定向，搜索引擎不会更新索引
- `304 Not Modified`：资源未修改，可以使用缓存版本，大大提升访问速度

**4xx - 客户端错误（你的问题）**
- `400 Bad Request`：请求格式有误，服务器无法理解
- `401 Unauthorized`：需要身份认证，通常要求登录
- `403 Forbidden`：有权限认证但无访问权限，比如访问管理员页面
- `404 Not Found`：资源不存在，最为人熟知的错误码
- `429 Too Many Requests`：请求过于频繁，被限流了

**5xx - 服务器错误（不是你的错）**
- `500 Internal Server Error`：服务器内部错误，通常是代码bug导致
- `502 Bad Gateway`：网关错误，常见于负载均衡器或代理服务器
- `503 Service Unavailable`：服务暂时不可用，可能是维护或过载

理解这些状态码对于前端开发和接口调试非常重要。当你看到某个状态码时，就能快速判断问题出在哪个环节。

### 4、HTTP头部信息详解

`HTTP` 头部就像是信件的信封，虽然不是主要内容，但包含了很多重要的元信息。它们以键值对的形式出现：

```
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
```

常见的头部信息可以分为几大类：

**内容相关头部**
- `Content-Type`：告诉接收方内容的类型，如 `text/html`、`application/json`
- `Content-Length`：内容的字节长度，用于确定何时接收完毕
- `Content-Encoding`：内容的压缩方式，如 `gzip`

**缓存控制头部**
- `Cache-Control`：缓存策略，如 `max-age=3600` 表示缓存1小时
- `ETag`：资源的版本标识，用于判断资源是否发生变化
- `Last-Modified`：资源的最后修改时间

**安全相关头部**
- `Authorization`：身份认证信息，如 `Bearer token` 或 `Basic credentials`
- `Set-Cookie`：设置浏览器Cookie
- `X-Frame-Options`：防止页面被嵌入iframe，预防点击劫持

**客户端信息头部**
- `User-Agent`：浏览器/客户端的详细信息
- `Accept`：客户端能接受的内容类型
- `Accept-Language`：客户端偏好的语言

**连接管理头部**
- `Connection`：连接选项，如 `keep-alive` 保持连接
- `Host`：目标主机名，HTTP/1.1的必需头部

现代Web开发中，自定义头部也很常见，通常以 `X-` 开头，如 `X-Request-ID` 用于请求追踪，`X-API-Version` 用于API版本控制。

这些头部信息的合理使用，能让HTTP通信更加高效、安全和灵活。详细的头部规范可以参考 [MDN HTTP Headers文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)。

## 四、HTTP协议的核心特性

### 1、无状态性的设计哲学

`HTTP` 的无状态性是一个经过深思熟虑的设计决策。每个请求都是独立的，服务器不会记住任何关于客户端的历史信息。

这种设计带来了明显的好处：
- **简化服务器设计**：服务器不需要维护复杂的状态信息，实现更加简洁
- **良好的可扩展性**：请求可以被分发到任意服务器处理，便于负载均衡
- **容错能力强**：单个请求失败不会影响后续请求的处理

当然，无状态也带来了挑战：如何识别用户身份？这就催生了 `Cookie` 和 `Session` 等状态管理机制。

### 2、连接管理的演进

**HTTP/1.0：一次性连接**
早期的HTTP每次请求都要建立新的TCP连接，就像每次打电话都要重新拨号一样，效率很低。

**HTTP/1.1：持久连接**
引入了 `keep-alive` 机制，一个连接可以发送多个请求，大大提高了效率。默认情况下，HTTP/1.1就使用持久连接。

```
Connection: keep-alive  // 保持连接
Connection: close       // 关闭连接
```

**现代HTTP：更智能的连接管理**
现代浏览器会根据情况智能地管理连接池，对同一个域名保持多个并发连接，在性能和资源消耗之间找到平衡。

### 3、协议版本的性能突破

虽然前面已经介绍过HTTP的发展历程，但值得再次强调 `HTTP/2` 和 `HTTP/3` 在性能方面的革命性改进：

**HTTP/2的突破**
- **多路复用**：一个连接同时处理多个请求，告别了HTTP/1.1的队头阻塞问题
- **二进制协议**：更高效的数据传输格式
- **头部压缩**：减少冗余数据传输
- **服务器推送**：主动推送客户端可能需要的资源

**HTTP/3的创新**
- **基于QUIC协议**：使用UDP替代TCP，减少握手延迟
- **更好的移动网络适应性**：在网络切换时能快速恢复连接
- **内置加密**：安全性得到进一步提升

这些特性的演进反映了互联网应用对性能要求的不断提高，从简单的文档传输发展到复杂的实时应用。

## 五、HTTP安全机制

网络安全始终是互联网发展的重要议题。随着网络攻击手段的不断升级，HTTP协议在安全方面也在持续演进。

### 1、HTTPS：加密传输的基石

`HTTPS` 本质上就是"HTTP over SSL/TLS"，它在HTTP的基础上增加了一层加密保护。

**HTTPS的握手过程**

想象你要给朋友寄一封重要信件，但担心被人偷看：

1. **发送请求**：你向邮局（服务器）表明想要安全邮寄
2. **验证身份**：邮局出示营业执照（数字证书）证明自己的身份
3. **检查证件**：你核实营业执照的真实性（证书验证）
4. **协商密码**：你们约定一个只有彼此知道的暗号（对称密钥）
5. **加密通信**：之后的所有通信都用这个暗号加密

**HTTPS的安全保障**
- **机密性**：通过加密保证数据不被窃听
- **完整性**：通过数字签名保证数据不被篡改
- **身份认证**：通过证书保证服务器身份的真实性

### 2、现代HTTP的安全特性

**强制HTTPS的趋势**
现代的HTTP/2和HTTP/3都强烈建议（HTTP/2）或强制要求（HTTP/3）使用TLS加密。这意味着未来的Web基本上就是HTTPS的天下。

**0-RTT握手的权衡**
HTTP/3引入的0-RTT握手虽然提升了性能，但也带来了重放攻击的风险。这是性能与安全之间的经典权衡案例。

### 3、内容安全策略（CSP）

`CSP` 是一种强大的安全机制，通过声明式的方式控制网页可以加载哪些资源：

```http
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' https://trusted-cdn.com; 
  style-src 'self' 'unsafe-inline'; 
  img-src *; 
  connect-src 'self' https://api.example.com;
```

**常用CSP指令解析**
- `default-src 'self'`：默认只允许同源资源
- `script-src`：控制JavaScript的来源
- `style-src`：控制CSS的来源  
- `img-src *`：允许任意来源的图片
- `connect-src`：控制XHR/WebSocket等连接的目标

**CSP的防护效果**
- **防XSS攻击**：限制内联脚本执行
- **防数据泄露**：控制资源请求的目标
- **防点击劫持**：配合frame-ancestors指令

### 4、其他重要的安全头部

除了CSP，还有其他重要的安全头部：

**HSTS（HTTP Strict Transport Security）**
```http
Strict-Transport-Security: max-age=31536000; includeSubDomains
```
强制浏览器在指定时间内只能通过HTTPS访问网站。

**X-Frame-Options**
```http
X-Frame-Options: DENY
```
防止页面被嵌入iframe，预防点击劫持攻击。

**X-Content-Type-Options**
```http
X-Content-Type-Options: nosniff
```
防止浏览器猜测内容类型，避免MIME类型混淆攻击。

这些安全机制的组合使用，能够为现代Web应用提供多层次的安全防护。更多安全头部的详细信息可以参考 [MDN安全相关头部文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security)。

## 六、总结

通过这篇文章，我们深入探讨了互联网通信的两大基石：`DNS` 和 `HTTP` 协议。

**DNS：互联网的导航系统**
`DNS` 就像是互联网世界的GPS，将人类友好的域名转换为机器能理解的IP地址。从递归查询到缓存优化，从根域名服务器到权威服务器，这套分层体系设计精妙，既保证了全球域名的统一管理，又实现了高效的分布式解析。

**HTTP：数据传输的通用语言**
`HTTP` 协议经过30多年的发展，从简单的文档传输演进为支撑整个现代Web的基础设施。它的请求-响应模型、丰富的方法定义、灵活的头部机制，为各种复杂的网络应用提供了标准化的通信方式。

**技术演进的启示**
两个协议的发展历程都体现了技术演进的一般规律：从简单到复杂，从功能实现到性能优化，从基础通信到安全保障。HTTP从1.0到3.0的升级路径，特别是HTTP/2的多路复用和HTTP/3的QUIC协议，展现了在保持向后兼容的前提下如何实现性能突破。

**安全性的重要地位**
现代网络环境下，安全不再是可选项，而是必需品。HTTPS的普及、CSP等安全机制的引入，都说明了在协议设计中安全考虑的重要性。

**实践意义**
对于开发者而言，深入理解这两个协议不仅有助于排查网络问题、优化应用性能，更能帮助我们设计出更好的网络架构。毕竟，只有理解了底层的工作原理，才能在上层构建出更优雅的解决方案。

无论你是前端开发者、后端工程师，还是系统架构师，DNS和HTTP都是你必须掌握的基础知识。它们不仅是技术工具，更是理解现代互联网工作原理的重要窗口。

**祝你变得更强!**
