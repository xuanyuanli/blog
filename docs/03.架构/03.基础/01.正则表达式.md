---
title: 正则表达式
date: 2022-06-01 23:09:55
permalink: /pages/fb4fe9/
categories: 
  - 架构
  - 基础
tags: 
  - 正则表达式
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

## 一、引言

正则表达式（Regular Expression，简称 `Regex` 或 `RegExp`）是一种强大而灵活的文本模式匹配工具。它的理论基础可以追溯到20世纪50年代，由数学家斯蒂芬·科尔·克莱尼（Stephen Cole Kleene）提出的正则集合概念。1968年，肯·汤普逊（Ken Thompson）将正则表达式引入到 `Unix` 的文本编辑器 `ed` 中，从此正则表达式成为了计算机科学和编程领域中不可或缺的工具。

凭借其强大的功能和高效性能，正则表达式在文本处理、数据提取、数据验证等多个领域发挥着至关重要的作用。

随着大数据时代的到来，对于信息检索和处理的需求越来越大，学习并掌握正则表达式成为了计算机专业人士和软件开发者必备的技能之一。

<!-- more -->
在本文中，我们将全面介绍正则表达式的基本知识和高级技巧，以及在各种实际场景中的应用方法。

我们相信，掌握正则表达式对于提高您的编程和数据处理能力是非常有帮助的。接下来，让我们开始学习正则表达式的奥秘吧！

## 二、正则表达式基础

### 1、字符类

字符类是正则表达式中用于匹配特定字符集的元素。字符类分为预定义字符类和自定义字符类两种。

#### 1.1、预定义字符类

预定义字符类是正则表达式中的预设元字符，用于表示常见的字符集。以下是一些常用的预定义字符类：

- `\d`：匹配数字字符（0-9），等价于 `[0-9]`
- `\D`：匹配非数字字符，等价于 `[^0-9]`
- `\w`：匹配单词字符（字母、数字和下划线），等价于 `[A-Za-z0-9_]`
- `\W`：匹配非单词字符，等价于 `[^A-Za-z0-9_]`
- `\s`：匹配空白字符（空格、制表符、换行符、回车符等），等价于 `[ \t\n\r\f\v]`
- `\S`：匹配非空白字符，等价于 `[^ \t\n\r\f\v]`
- `.`：匹配除换行符外的任意单个字符（在 `DOTALL` 模式下可匹配换行符）

#### 1.2、自定义字符类

自定义字符类允许您根据需要创建自己的字符集。自定义字符类使用方括号（`[]`）表示，例如：

- `[aeiou]`：匹配任意一个元音字母（a, e, i, o, u）
- `[A-Za-z]`：匹配任意一个英文字母（大写或小写）
- `[0-9a-fA-F]`：匹配任意一个十六进制数字字符
- `[^0-9]`：匹配任意非数字字符（`^` 在方括号内表示取反）
- `[a-z&&[^aeiou]]`：匹配辅音字母（某些引擎支持交集运算）

### 2、量词

量词用于指定字符或字符类的出现次数。正则表达式中常用的量词有：

- `*`：匹配前面的元素零次或多次
- `+`：匹配前面的元素一次或多次
- `?`：匹配前面的元素零次或一次
- `{n}`：匹配前面的元素恰好 n 次
- `{n,}`：匹配前面的元素至少 n 次
- `{n,m}`：匹配前面的元素至少 n 次，但不超过 m 次

#### 2.1、贪婪量词（模式）

贪婪量词总是尽可能多地匹配字符。例如：

```javascript
const text = "aabbcc";
const regex = /a.*b/;
console.log(text.match(regex)); // ["aabb"]
```

在这个例子中，`.*` 会匹配尽可能多的字符，直到最后一个 `b`。

#### 2.2、懒惰量词（模式）

懒惰量词（也称为非贪婪量词）尽可能少地匹配字符。通过在贪婪量词后加一个问号（`?`）将其转换为懒惰量词。例如：

```javascript
const text = "aabbcc";
const regex = /a.*?b/;
console.log(text.match(regex)); // ["aab"]
```

在这个例子中，`.*?` 会匹配尽可能少的字符，遇到第一个 `b` 就停止。

#### 2.3、独占量词（模式）

独占量词（Possessive Quantifiers）是一种不允许回溯的量词，主要在 `Java`、`PHP` 等语言中支持。使用 `*+`、`++`、`?+`、`{n,m}+` 等形式表示。

```java
// Java 示例
Pattern pattern = Pattern.compile("ab{1,3}+bc");
Matcher matcher = pattern.matcher("abbc");
System.out.println(matcher.find()); // false
```

在这个例子中，`b{1,3}+` 会贪婪地匹配所有的 `b`，但不会回溯，导致后面的 `bc` 无法匹配。

**注意**：JavaScript 不支持独占量词，但可以使用原子组 `(?>...)` 达到类似效果（需要特定引擎支持）。

### 3、边界匹配符

边界匹配符用于指定要匹配的字符串的位置。以下是一些常用的边界匹配符：

- `^`：匹配字符串的开头
- `$`：匹配字符串的结尾
- `\b`：匹配单词边界
- `\B`：匹配非单词边界

例如：

```javascript
// 匹配字符串开头
const regex1 = /^Hello/;
console.log(regex1.test("Hello World")); // true
console.log(regex1.test("Say Hello")); // false

// 匹配字符串结尾
const regex2 = /world$/;
console.log(regex2.test("Hello world")); // true
console.log(regex2.test("world peace")); // false

// 匹配单词边界
const regex3 = /\bcat\b/;
console.log(regex3.test("The cat sat")); // true
console.log(regex3.test("concatenate")); // false
```

### 4、分组和捕获

分组允许您将正则表达式的一部分组合在一起，并对其应用量词和其他操作。分组使用圆括号（`()`）表示。

```javascript
// 基本分组
const regex1 = /(ab)+/;
console.log("ababab".match(regex1)); // ["ababab", "ab"]

// 捕获分组
const regex2 = /(\d{4})-(\d{2})-(\d{2})/;
const match = "2024-03-15".match(regex2);
console.log(match[0]); // "2024-03-15" (完整匹配)
console.log(match[1]); // "2024" (第一个捕获组)
console.log(match[2]); // "03" (第二个捕获组)
console.log(match[3]); // "15" (第三个捕获组)
```

捕获分组按照左括号出现的顺序编号，从 1 开始（0 表示整个匹配）。

### 5、反向引用

反向引用允许您在正则表达式中引用之前捕获的子字符串。反向引用使用反斜杠（`\`）后跟捕获分组的编号表示。

```javascript
// 匹配重复的数字
const regex1 = /(\d)\1/;
console.log(regex1.test("11")); // true
console.log(regex1.test("12")); // false

// 匹配 HTML 标签对
const regex2 = /<([a-z]+)>.*?<\/\1>/i;
console.log(regex2.test("<div>content</div>")); // true
console.log(regex2.test("<div>content</span>")); // false

// 匹配引号内的内容（同类引号）
const regex3 = /(["'])(.*?)\1/;
console.log('"hello"'.match(regex3)); // ['"hello"', '"', 'hello']
console.log("'world'".match(regex3)); // ["'world'", "'", 'world']
```

### 6、回溯
在正则表达式中，回溯（Backtracking）是指在匹配过程中，当某个匹配尝试失败时，回退到之前的位置重新尝试其他可能的匹配方式。

正则表达式的匹配过程通常是从左到右进行的，尝试匹配每个字符。当遇到量词（如`*`、`+`、`?`、`{n,m}`等）时，可能会导致回溯的出现。

回溯是通过尝试不同的匹配方式来实现的。当匹配失败时，正则引擎会回溯到上一个位置，并尝试其他可能的匹配方式。这种回溯过程会消耗更多的时间和资源，特别是当正则表达式的模式复杂且匹配的文本较长时。

例如，考虑正则表达式 `a+b+` 和文本 `aaabbb`：

```javascript
const regex = /a+b+/;
const text = "aaabbb";
// 匹配过程：
// 1. a+ 贪婪地匹配所有的 'a'："aaa"
// 2. b+ 贪婪地匹配所有的 'b'："bbb"
// 3. 成功匹配："aaabbb"
console.log(text.match(regex)); // ["aaabbb"]
```

但如果是 `a+b+c` 匹配 `aaabbbb`：

```javascript
const regex = /a+b+c/;
const text = "aaabbbb";
// 匹配过程：
// 1. a+ 匹配 "aaa"
// 2. b+ 匹配 "bbbb"
// 3. 尝试匹配 'c' 失败
// 4. 回溯：b+ 释放一个 'b'，匹配 "bbb"
// 5. 再次尝试匹配 'c' 失败
// 6. 继续回溯直到整体匹配失败
console.log(text.match(regex)); // null
```

回溯的出现可能会导致正则表达式的性能下降，特别是在复杂的模式和长文本的情况下。为了避免不必要的回溯，可以使用懒惰模式或独占模式来指定匹配方式，或者使用更精确的匹配模式来优化正则表达式的性能。

## 三、正则表达式高级特性

在掌握了正则表达式的基本概念之后，我们将继续深入探讨一些高级特性。这些特性可以帮助我们编写更强大、更灵活的正则表达式，以应对复杂的文本处理任务。

### 1、前瞻断言（Lookahead）

前瞻断言是一种零宽度断言，它允许我们在不消耗字符的情况下查找匹配项的前面部分。有两种前瞻断言：

- 正向前瞻断言：使用 `(?=...)` 表示，表示所查找的内容必须满足括号内的正则表达式。

  示例：`/\w+(?=\.com)/` 可以匹配以 `.com` 结尾的域名（不包括 `.com` 部分）。

- 负向前瞻断言：使用 `(?!...)` 表示，表示所查找的内容不满足括号内的正则表达式。

  示例：`/\w+(?!\.com)/` 可以匹配不以 `.com` 结尾的域名。

### 2、后瞻断言（Lookbehind）

后瞻断言与前瞻断言类似，也是一种零宽度断言，但它是在匹配项的后面进行查找。有两种后瞻断言：

- 正向后瞻断言：使用 `(?<=...)` 表示，表示所查找的内容必须满足括号内的正则表达式。

  示例：`/(?<=\$)\d+/` 可以匹配美元符号（$）后面的数字。

- 负向后瞻断言：使用 `(?<!...)` 表示，表示所查找的内容不满足括号内的正则表达式。

  示例：`/(?<!\$)\d+/` 可以匹配不在美元符号（$）后面的数字。

### 3、非捕获分组

非捕获分组允许我们对表达式进行分组，但不会捕获匹配的内容。使用 `(?:...)` 表示非捕获分组。

示例：`/(?:\d{3}-){2}\d{4}/` 可以匹配美国电话号码的格式（例如：123-456-7890），但不会捕获分组内的内容。

### 4、命名分组

命名分组允许我们为捕获分组指定一个名称，以便在后续操作中引用。使用 `(?<name>...)` 表示命名分组。

示例：`/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/` 可以匹配日期格式（例如：2022-01-01），并为年、月、日分别命名为 `year`、`month` 和 `day`。

### 5、条件表达式

条件表达式允许我们根据正则表达式的某个部分是否匹配来选择不同的分支。使用 `(?(condition)yes-pattern|no-pattern)` 表示条件表达式。

示例：`/(?(?=.*\d)(?=.*[a-zA-Z]))\w+/` 可以匹配同时包含数字和字母的字符串。

### 6、注释

在正则表达式中添加注释可以帮助我们理解和维护复杂的表达式。使用 `(?#comment)` 表示注释。

示例：`/(?#匹配年份)\d{4}-(?#匹配月份)\d{2}-(?#匹配日期)\d{2}/` 可以匹配日期格式（例如：2022-01-01），并在表达式中添加了关于各部分功能的注释。

### 7、递归匹配

递归匹配允许我们匹配嵌套结构，例如括号、标签等。使用 `(?R)` 表示递归匹配。

示例：`/\(([^()]+|(?R))*\)/` 可以匹配任意深度的嵌套括号。

通过掌握这些高级特性，我们可以编写更强大和灵活的正则表达式，以应对各种复杂的文本处理任务。在实际使用中，我们可以根据需求灵活组合这些特性，以实现更精确的匹配和提取。

## 四、常见正则表达式应用场景

正则表达式在许多场景中都有广泛的应用，以下是一些典型的应用场景：

### 1、电子邮件验证

电子邮件地址验证是正则表达式的一个常见用途。通过编写正则表达式，我们可以检查输入的字符串是否符合电子邮件地址的基本格式。以下是一个简单的电子邮件验证正则表达式示例：

```javascript
const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

// 测试示例
console.log(emailRegex.test("user@example.com")); // true
console.log(emailRegex.test("admin.name@company.org")); // true
console.log(emailRegex.test("invalid@")); // false
console.log(emailRegex.test("@example.com")); // false
```

**注意**：这是一个简化版本的邮箱验证，完整的 RFC 5322 规范邮箱验证非常复杂。

### 2、密码复杂度检查

正则表达式也可以用于检查密码的复杂度。例如，我们可以创建一个正则表达式来确保密码包含至少一个大写字母、一个小写字母、一个数字和一个特殊字符，长度在8到20个字符之间。示例正则表达式如下：

```javascript
const passwordRegex = /^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,20}$/;

// 测试示例
console.log(passwordRegex.test("Pass123!")); // true
console.log(passwordRegex.test("StrongP@ss2024")); // true
console.log(passwordRegex.test("weak")); // false (太短)
console.log(passwordRegex.test("NoNumbers!")); // false (缺少数字)
console.log(passwordRegex.test("nouppercas3!")); // false (缺少大写字母)

// 分解说明：
// (?=.*[A-Z]) - 至少包含一个大写字母
// (?=.*[a-z]) - 至少包含一个小写字母
// (?=.*\d) - 至少包含一个数字
// (?=.*[@$!%*?&]) - 至少包含一个特殊字符
// [A-Za-z\d@$!%*?&]{8,20} - 总长度为8-20个字符
```

### 3、URL 解析

正则表达式可用于提取和解析URL中的各个部分，例如协议、域名、路径等。以下是一个简单的URL解析正则表达式示例：

```javascript
// 简单 URL 验证
const urlRegex = /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/;

// 更详细的 URL 解析
const detailedUrlRegex = /^(https?):\/\/([\w.-]+)(:\d+)?(\/[^\s]*)?$/;

const url = "https://example.com:8080/path/to/page?query=123";
const match = url.match(detailedUrlRegex);
if (match) {
    console.log("协议:", match[1]); // "https"
    console.log("域名:", match[2]); // "example.com"
    console.log("端口:", match[3]); // ":8080"
    console.log("路径:", match[4]); // "/path/to/page?query=123"
}
```

### 4、日期和时间格式验证

正则表达式也可以用于验证不同格式的日期和时间。例如，我们可以创建一个正则表达式来检查输入的日期是否符合 `yyyy-mm-dd` 格式：

```javascript
// yyyy-mm-dd 格式
const dateRegex = /^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;

console.log(dateRegex.test("2024-03-15")); // true
console.log(dateRegex.test("2024/03/15")); // true
console.log(dateRegex.test("2024.03.15")); // true
console.log(dateRegex.test("2024-13-01")); // false (月份错误)
console.log(dateRegex.test("2024-03-32")); // false (日期错误)

// 中国身份证号码验证（18位）
const idCardRegex = /^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/;

// 中国手机号码验证
const phoneRegex = /^1[3-9]\d{9}$/;

console.log(phoneRegex.test("13812345678")); // true
console.log(phoneRegex.test("12812345678")); // false (号段错误)
```

### 5、HTML/XML 标签匹配

正则表达式可以用于从HTML或XML文本中提取标签和属性。例如，我们可以创建一个正则表达式来查找所有的`<a>`标签，并提取其 `href` 属性：

```regex
<a\s+(?:[^>]*?\s+)?href="([^"]*)"
```

然而，请注意，正则表达式可能不是处理HTML或XML的最佳工具。许多编程语言提供了专门的库和工具来处理这些类型的文本。

总之，正则表达式在许多常见的文本处理场景中都发挥着重要作用。掌握这些实际应用将有助于你充分利用正则表达式的强大功能。

## 五、常见陷阱与最佳实践

### 1、常见陷阱

#### 1.1、灾难性回溯

某些正则表达式模式可能导致指数级的回溯，造成性能问题：

```javascript
// 危险模式 - 可能导致灾难性回溯
const badRegex = /^(a+)+$/;
const text = "aaaaaaaaaaaaaaaaaaaaaaaaaab"; // 会导致严重性能问题

// 优化后的模式
const goodRegex = /^a+$/;
```

#### 1.2、贪婪匹配的误用

```javascript
// 问题：贪婪匹配可能匹配过多内容
const html = '<div>content1</div><div>content2</div>';
const badRegex = /<div>.*<\/div>/;
console.log(html.match(badRegex)); // 匹配整个字符串

// 解决：使用懒惰匹配
const goodRegex = /<div>.*?<\/div>/;
console.log(html.match(goodRegex)); // 只匹配第一个 div
```

#### 1.3、忘记转义特殊字符

```javascript
// 错误：点号匹配任意字符
const badRegex = /example.com/;
console.log(badRegex.test("exampleXcom")); // true (错误匹配)

// 正确：转义点号
const goodRegex = /example\.com/;
console.log(goodRegex.test("example.com")); // true
console.log(goodRegex.test("exampleXcom")); // false
```

### 2、最佳实践

#### 2.1、使用原始字符串（在支持的语言中）

```python
# Python 示例
import re

# 使用原始字符串避免双重转义
pattern = r'\d+\.\d+'  # 匹配小数
# 而不是 '\\d+\\.\\d+'
```

#### 2.2、合理使用锚点提高性能

```javascript
// 使用锚点限制搜索范围
const withAnchor = /^[A-Z]/;     // 更快
const withoutAnchor = /[A-Z]/;   // 需要搜索整个字符串
```

#### 2.3、优先使用非捕获组

```javascript
// 如果不需要捕获，使用非捕获组
const nonCapturing = /(?:abc)+/;  // 更高效
const capturing = /(abc)+/;       // 会保存捕获结果，占用内存
```

#### 2.4、编译和缓存正则表达式

```javascript
// JavaScript - 缓存编译后的正则
const regexCache = {};

function getRegex(pattern, flags) {
    const key = `${pattern}_${flags}`;
    if (!regexCache[key]) {
        regexCache[key] = new RegExp(pattern, flags);
    }
    return regexCache[key];
}
```

## 六、正则表达式的优化与性能

虽然正则表达式功能强大，但在实际使用中需要注意性能和可读性问题。本章将介绍如何优化正则表达式以提高性能和可读性。

### 1、简化正则表达式

使用简洁的正则表达式可以提高性能。以下是一些建议：

- 优先使用字符类（如 `\d`、`\w`）而非字符范围（如 `[0-9]`、`[a-zA-Z0-9_]`）
- 使用非捕获组 `(?:)` 而非捕获组 `()`，除非确实需要捕获子表达式的匹配结果
- 使用量词 `{n,m}` 限制匹配次数，以避免过多的回溯

### 2、避免贪婪匹配

贪婪匹配可能导致性能问题，尤其是在处理大量文本时。尽量使用非贪婪匹配（例如 `*?`、`+?`、`{n,m}?`）来避免不必要的回溯。

### 3、利用锚点

使用锚点（如 `^`、`$`、`\b`）可以限制匹配的位置，从而提高性能。

### 4、使用预编译的正则表达式

许多编程语言支持预编译正则表达式。预编译的正则表达式在第一次编译后会被缓存，后续匹配时无需重新编译，从而提高性能。在需要多次使用同一个正则表达式时，应考虑使用预编译。

### 5、可读性和维护性

正则表达式的可读性和维护性对于复杂表达式尤为重要。以下是一些建议：

- 使用注释来解释正则表达式的各部分功能
- 将复杂的正则表达式拆分成多个简单的子表达式
- 在可能的情况下，使用具名捕获组来提高可读性

### 6、使用专业工具

使用专业的正则表达式工具（如在线正则表达式测试器、调试器）可以帮助你编写、测试和优化正则表达式。

总之，优化正则表达式以提高性能和可读性是一个重要的技能。在编写正则表达式时，务必关注这些方面，以确保你的代码高效且易于维护。

## 七、正则表达式在不同编程语言中的应用

正则表达式在许多编程语言中都有广泛的应用。本章将介绍如何在 JavaScript、Java 和 Python 中使用正则表达式。

### 1、JavaScript

在 JavaScript 中，可以使用 RegExp 对象或字面量语法创建正则表达式。以下是一些常见操作：

```javascript
// 创建正则表达式
const regex1 = /pattern/gi;  // 字面量语法
const regex2 = new RegExp("pattern", "gi");  // 构造函数

// test() - 测试是否匹配
const emailRegex = /^\w+@\w+\.\w+$/;
console.log(emailRegex.test("user@example.com")); // true

// match() - 返回匹配结果
const text = "The year 2024 and 2025";
const matches = text.match(/\d{4}/g);
console.log(matches); // ["2024", "2025"]

// replace() - 替换匹配内容
const result = text.replace(/\d{4}/g, (match) => `[${match}]`);
console.log(result); // "The year [2024] and [2025]"

// split() - 按模式分割字符串
const csv = "apple,banana;orange|grape";
const fruits = csv.split(/[,;|]/);
console.log(fruits); // ["apple", "banana", "orange", "grape"]

// exec() - 逐个查找匹配项
const regex = /\d+/g;
let match;
while ((match = regex.exec("123 456 789")) !== null) {
    console.log(`Found ${match[0]} at index ${match.index}`);
}
```

### 2、Java

在 Java 中，可以使用 `java.util.regex` 包中的 `Pattern` 和 `Matcher` 类来处理正则表达式。以下是一些常见操作：

```java
import java.util.regex.*;

public class RegexExample {
    public static void main(String[] args) {
        // 创建正则表达式
        Pattern pattern = Pattern.compile("\\d{4}", Pattern.CASE_INSENSITIVE);
        
        // 完整匹配
        Pattern emailPattern = Pattern.compile("^\\w+@\\w+\\.\\w+$");
        Matcher emailMatcher = emailPattern.matcher("user@example.com");
        System.out.println(emailMatcher.matches()); // true
        
        // 查找所有匹配项
        String text = "The years 2024 and 2025";
        Matcher matcher = pattern.matcher(text);
        while (matcher.find()) {
            System.out.println("Found: " + matcher.group() + 
                             " at position " + matcher.start());
        }
        
        // 替换匹配项
        String replaced = matcher.replaceAll("[$0]");
        System.out.println(replaced); // "The years [2024] and [2025]"
        
        // 分组捕获
        Pattern datePattern = Pattern.compile("(\\d{4})-(\\d{2})-(\\d{2})");
        Matcher dateMatcher = datePattern.matcher("2024-03-15");
        if (dateMatcher.find()) {
            System.out.println("Year: " + dateMatcher.group(1));  // 2024
            System.out.println("Month: " + dateMatcher.group(2)); // 03
            System.out.println("Day: " + dateMatcher.group(3));   // 15
        }
        
        // 分割字符串
        String csv = "apple,banana;orange|grape";
        String[] fruits = csv.split("[,;|]");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
    }
}
```

### 3、Python

在 Python 中，可以使用 `re` 模块处理正则表达式。以下是一些常见操作：

```python
import re

# 创建正则表达式（推荐使用原始字符串 r''）
pattern = re.compile(r'\d{4}', re.IGNORECASE)

# match() - 从字符串开头匹配
email_pattern = re.compile(r'^\w+@\w+\.\w+$')
match = email_pattern.match("user@example.com")
print(bool(match))  # True

# search() - 搜索第一个匹配
text = "The year 2024 and 2025"
search_result = re.search(r'\d{4}', text)
if search_result:
    print(f"Found: {search_result.group()} at position {search_result.start()}")

# findall() - 查找所有匹配项
matches = re.findall(r'\d{4}', text)
print(matches)  # ['2024', '2025']

# finditer() - 返回匹配对象的迭代器
for match in re.finditer(r'\d{4}', text):
    print(f"Found {match.group()} at {match.span()}")

# sub() - 替换匹配项
replaced = re.sub(r'\d{4}', r'[\g<0>]', text)
print(replaced)  # "The year [2024] and [2025]"

# 使用函数作为替换
def replace_func(match):
    year = int(match.group())
    return f"[{year + 1}]"

result = re.sub(r'\d{4}', replace_func, text)
print(result)  # "The year [2025] and [2026]"

# 分组捕获
date_pattern = re.compile(r'(\d{4})-(\d{2})-(\d{2})')
match = date_pattern.match("2024-03-15")
if match:
    print(f"Year: {match.group(1)}")   # 2024
    print(f"Month: {match.group(2)}")  # 03
    print(f"Day: {match.group(3)}")    # 15
    print(f"All groups: {match.groups()}")  # ('2024', '03', '15')

# 命名分组
named_pattern = re.compile(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})')
match = named_pattern.match("2024-03-15")
if match:
    print(match.group('year'))   # 2024
    print(match.groupdict())     # {'year': '2024', 'month': '03', 'day': '15'}

# split() - 分割字符串
csv = "apple,banana;orange|grape"
fruits = re.split(r'[,;|]', csv)
print(fruits)  # ['apple', 'banana', 'orange', 'grape']
```

### 4、Go

在 Go 中，可以使用 `regexp` 包处理正则表达式：

```go
package main

import (
    "fmt"
    "regexp"
)

func main() {
    // 编译正则表达式
    re := regexp.MustCompile(`\d{4}`)
    
    // 测试匹配
    matched := re.MatchString("The year 2024")
    fmt.Println(matched) // true
    
    // 查找第一个匹配
    text := "The years 2024 and 2025"
    match := re.FindString(text)
    fmt.Println(match) // "2024"
    
    // 查找所有匹配
    matches := re.FindAllString(text, -1)
    fmt.Println(matches) // [2024 2025]
    
    // 替换匹配项
    replaced := re.ReplaceAllString(text, "[$0]")
    fmt.Println(replaced) // "The years [2024] and [2025]"
    
    // 分组捕获
    dateRe := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2})`)
    dateMatch := dateRe.FindStringSubmatch("2024-03-15")
    if len(dateMatch) > 0 {
        fmt.Printf("Full match: %s\n", dateMatch[0])  // 2024-03-15
        fmt.Printf("Year: %s\n", dateMatch[1])        // 2024
        fmt.Printf("Month: %s\n", dateMatch[2])       // 03
        fmt.Printf("Day: %s\n", dateMatch[3])         // 15
    }
    
    // 命名分组
    namedRe := regexp.MustCompile(`(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})`)
    namedMatch := namedRe.FindStringSubmatch("2024-03-15")
    for i, name := range namedRe.SubexpNames() {
        if i > 0 && name != "" {
            fmt.Printf("%s: %s\n", name, namedMatch[i])
        }
    }
}
```

总之，正则表达式在 JavaScript、Java、Python 和 Go 等编程语言中都有广泛应用。虽然语法细节有所不同，但核心概念是相通的。掌握在不同语言中使用正则表达式的方法，将帮助你更好地处理各种文本处理任务。

## 八、工具和资源

在学习和使用正则表达式过程中，以下工具和资源可能对你非常有帮助。在每个子章节中，我们都提供了至少一个中文的工具和资源网站。

### 1、在线正则表达式测试工具

- 正则表达式在线测试：[https://tool.oschina.net/regex](https://tool.oschina.net/regex)

### 2、可视化正则表达式生成工具

- 可视化正则表达式生成工具：Regexper  
  网址：[https://regexper.com/](https://regexper.com/)  
  说明：Regexper 是一个可视化正则表达式生成工具，可以将正则表达式转换为易于理解的图表。尽管该网站不提供中文界面，但它对于帮助用户更好地理解和学习正则表达式仍然非常有用。

### 3、正则表达式库和代码片段

- 正则表达式大全：any-rule  
  网址：[any-rule](https://github.com/any86/any-rule)  
  说明：any-rule 是一个 GitHub 仓库，收集了大量常用的正则表达式规则，如手机号、邮箱、身份证号等。这些规则可以帮助你快速完成各种验证任务。

### 4、学习资源和教程

- 正则表达式教程：MDN Regular Expressions Guide  
  网址：[MDN Regular Expressions Guide](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)  
  说明：以 JavaScript 为例，详细介绍正则表达式的基础知识和高级特性。

这些工具和资源将有助于你更轻松地学习和使用正则表达式。请尝试使用这些工具，并深入研究提供的教程和资料，以便更好地掌握正则表达式。

## 九、快速参考

### 1、常用元字符速查表

| 元字符 | 说明 | 示例 |
|--------|------|------|
| `\d` | 数字 `[0-9]` | `\d{3}` 匹配 `123` |
| `\D` | 非数字 `[^0-9]` | `\D+` 匹配 `abc` |
| `\w` | 单词字符 `[A-Za-z0-9_]` | `\w+` 匹配 `hello_123` |
| `\W` | 非单词字符 | `\W` 匹配 `!@#` |
| `\s` | 空白字符 | `\s+` 匹配空格、制表符 |
| `\S` | 非空白字符 | `\S+` 匹配非空白文本 |
| `.` | 任意字符（除换行符） | `a.b` 匹配 `a1b`, `a@b` |
| `^` | 字符串开头 | `^Hello` 匹配开头的 Hello |
| `$` | 字符串结尾 | `world$` 匹配结尾的 world |
| `\b` | 单词边界 | `\bcat\b` 匹配独立的 cat |

### 2、常用量词速查表

| 量词 | 说明 | 示例 |
|------|------|------|
| `*` | 0次或多次 | `ab*` 匹配 `a`, `ab`, `abb` |
| `+` | 1次或多次 | `ab+` 匹配 `ab`, `abb` |
| `?` | 0次或1次 | `ab?` 匹配 `a`, `ab` |
| `{n}` | 恰好n次 | `a{3}` 匹配 `aaa` |
| `{n,}` | 至少n次 | `a{2,}` 匹配 `aa`, `aaa` |
| `{n,m}` | n到m次 | `a{2,4}` 匹配 `aa`, `aaa`, `aaaa` |
| `*?` | 懒惰匹配0次或多次 | `a.*?b` 最短匹配 |
| `+?` | 懒惰匹配1次或多次 | `a.+?b` 最短匹配 |

### 3、常用正则表达式模板

```javascript
// 常用验证模式
const patterns = {
    // 邮箱
    email: /^[\w._%+-]+@[\w.-]+\.[A-Za-z]{2,}$/,
    
    // 手机号（中国）
    phone: /^1[3-9]\d{9}$/,
    
    // URL
    url: /^https?:\/\/([\w.-]+)(:\d+)?(\/.*)?$/,
    
    // IPv4 地址
    ipv4: /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    
    // 日期 yyyy-mm-dd
    date: /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/,
    
    // 时间 HH:MM:SS
    time: /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/,
    
    // 十六进制颜色
    hexColor: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
    
    // 用户名（字母开头，允许字母数字下划线，长度3-16）
    username: /^[a-zA-Z][a-zA-Z0-9_]{2,15}$/,
    
    // 密码强度（至少8位，包含大小写字母和数字）
    password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/,
    
    // 中文字符
    chinese: /[\u4e00-\u9fa5]/,
    
    // 身份证号（简单版）
    idCard: /^\d{17}[\dXx]$/,
    
    // 金额（支持小数点后两位）
    money: /^\d+(\.\d{1,2})?$/
};
```

## 十、总结

在本文中，我们详细介绍了正则表达式的基本概念、语法、使用方法和技巧。通过阅读本文，你应该已经对正则表达式有了一个全面的了解。

### 1、关键要点回顾

1. **基础知识**：掌握字符类、量词、边界匹配符、分组和反向引用等核心概念
2. **高级特性**：了解前瞻/后瞻断言、非捕获分组、命名分组等高级用法
3. **性能优化**：避免灾难性回溯，合理使用贪婪/懒惰匹配，编译和缓存正则表达式
4. **实际应用**：熟练运用正则表达式进行数据验证、文本提取、字符串替换等任务
5. **跨语言使用**：掌握在 JavaScript、Java、Python、Go 等不同语言中使用正则表达式的方法

### 2、学习建议

- **循序渐进**：从简单的模式开始，逐步掌握复杂的表达式
- **多做练习**：使用在线工具进行实践，加深理解
- **阅读文档**：不同语言的正则实现有细微差异，需要查阅相应文档
- **注重性能**：在处理大量数据时，要特别注意正则表达式的性能影响
- **保持可读性**：复杂的正则表达式要添加注释，便于维护

掌握正则表达式将极大提升你的文本处理能力和开发效率。希望本文能帮助你建立扎实的正则表达式基础，并在实际应用中发挥其强大功能。

不断学习和实践，你将成为正则表达式领域的高手。

**祝你变得更强！**
