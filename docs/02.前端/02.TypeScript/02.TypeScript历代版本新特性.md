---
title: TypeScript历代版本新特性
date: 2025-02-12 22:00:00
permalink: /pages/ts-versions/
categories:
  - 前端
  - TypeScript
tags:
  - TypeScript版本新特性
  - 类型系统
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

## 前言

TypeScript 由微软开发，于2012年首次发布。它是 JavaScript 的超集，添加了可选的静态类型系统和其他高级特性。TypeScript 代码最终会被编译为纯 JavaScript 代码，可以在任何支持 JavaScript 的环境中运行。

自发布以来，TypeScript 经历了持续的演进，类型系统不断完善，工具链日益强大。每个版本都在保持向后兼容的同时，引入新的语言特性和编译器优化，使得大规模 JavaScript 应用的开发变得更加安全和高效。

本文系统梳理了 TypeScript 各个版本的核心特性和发展历程，帮助你了解 TypeScript 是如何一步步演变成今天这个强大的类型化 JavaScript 语言的。

<!-- more -->

**阅读建议**：
- 标记为 **粗体** 的特性通常是该版本最重要的改进
- TypeScript 1.0、2.0、3.0、4.0、5.0 是重要的里程碑版本
- 代码示例可以帮助你快速理解新特性的用法

##版本发布流程

TypeScript 采用开放的开发模式，所有开发工作都在 GitHub 上进行，社区可以参与讨论和贡献。

### 关键特点
- 大约每2-3个月发布一个小版本
- 遵循语义化版本控制（主版本.次版本.修订版本）
- 通过 GitHub Issues 和 Pull Requests 收集反馈
- 严格的向后兼容性保证

### 发布周期
1. **开发阶段**：在 GitHub 主分支进行开发
2. **Beta 版本**：功能冻结，进入测试阶段
3. **RC 版本**（候选版本）：最终测试，准备发布
4. **正式版本**：稳定发布，推送到 npm

### 治理模型
- 主导者：微软 TypeScript 团队
- 社区驱动：接受社区贡献和反馈
- 开放透明：所有设计讨论公开进行

## 0.8（2012）

2012年10月发布，是 TypeScript 的首个公开预览版本。

### 核心特性
- **静态类型检查**：为 JavaScript 添加类型注解
- **类（Classes）**：支持面向对象编程
- **接口（Interfaces）**：定义对象结构
- **模块（Modules）**：代码组织和命名空间
- **编译到 JavaScript**：生成纯净的 JavaScript 代码

示例：
```typescript
// 类型注解
function greet(name: string): string {
    return "Hello, " + name;
}

// 接口
interface Person {
    name: string;
    age: number;
}

// 类
class Student implements Person {
    name: string;
    age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
}
```

## 1.0（2014）

2014年4月发布，标志着 TypeScript 正式发布。

### 主要特性
- **稳定的语言规范**：完善的类型系统
- **泛型（Generics）**：类型参数化
  ```typescript
  function identity<T>(arg: T): T {
      return arg;
  }
  
  // 泛型类
  class GenericNumber<T> {
      zeroValue: T;
      add: (x: T, y: T) => T;
  }
  ```

- **枚举（Enums）**：定义常量集合
  ```typescript
  enum Color {
      Red,
      Green,
      Blue
  }
  let c: Color = Color.Green;
  ```

## 1.4（2015）

2015年1月发布。

### 核心特性
- **联合类型（Union Types）**：值可以是多种类型之一
  ```typescript
  function format(value: string | number): string {
      if (typeof value === "string") {
          return value.toUpperCase();
      }
      return value.toFixed(2);
  }
  ```

- **类型别名（Type Aliases）**：为类型定义新名称
  ```typescript
  type StringOrNumber = string | number;
  type Point = { x: number; y: number; };
  ```

- **`const enum`**：编译时内联的枚举

## 1.5（2015）

2015年7月发布。

### 重要特性
- **ES6 模块语法**：支持 `import/export`
  ```typescript
  // math.ts
  export function add(a: number, b: number): number {
      return a + b;
  }
  
  // app.ts
  import { add } from './math';
  ```

- **`for...of` 循环**：迭代可迭代对象
- **装饰器（Decorators）**：实验性支持元编程
  ```typescript
  function sealed(constructor: Function) {
      Object.seal(constructor);
      Object.seal(constructor.prototype);
  }
  
  @sealed
  class Greeter {
      greeting: string;
  }
  ```

## 1.6（2015）

2015年9月发布。

### 核心特性
- **类表达式**：支持匿名类和命名类表达式
- **抽象类（Abstract Classes）**：定义基类
  ```typescript
  abstract class Animal {
      abstract makeSound(): void;
      
      move(): void {
          console.log("移动中...");
      }
  }
  
  class Dog extends Animal {
      makeSound(): void {
          console.log("汪汪!");
      }
  }
  ```

- **合并的交叉类型（Intersection Types）**：组合多个类型
  ```typescript
  interface HasName {
      name: string;
  }
  
  interface HasAge {
      age: number;
  }
  
  type Person = HasName & HasAge;
  ```

## 1.8（2016）

2016年2月发布。

### 主要特性
- **字符串字面量类型**：精确的字符串类型
  ```typescript
  type EventType = "click" | "scroll" | "mousemove";
  
  function handleEvent(event: EventType): void {
      // ...
  }
  ```

- **F-Bounded Polymorphism**：`this` 类型
  ```typescript
  class Calculator {
      add(x: number): this {
          // ...
          return this;
      }
      
      subtract(x: number): this {
          // ...
          return this;
      }
  }
  ```

- **模块增强**：扩展现有模块

## 2.0（2016）

2016年9月发布，是一个重要的里程碑版本。

### 革命性特性

#### 1. 非空类型检查
- **`--strictNullChecks`**：`null` 和 `undefined` 不再是所有类型的子类型
  ```typescript
  let name: string = "Alice";
  // name = null; // 错误
  
  let nullableName: string | null = "Bob";
  nullableName = null; // 正确
  ```

#### 2. 只读属性
- **`readonly` 修饰符**：防止属性被修改
  ```typescript
  interface Point {
      readonly x: number;
      readonly y: number;
  }
  
  let p: Point = { x: 10, y: 20 };
  // p.x = 5; // 错误
  ```

#### 3. 标记联合类型（Tagged Union Types）
- **可辨识联合**：类型安全的模式匹配
  ```typescript
  interface Square {
      kind: "square";
      size: number;
  }
  
  interface Rectangle {
      kind: "rectangle";
      width: number;
      height: number;
  }
  
  type Shape = Square | Rectangle;
  
  function area(s: Shape): number {
      switch (s.kind) {
          case "square":
              return s.size * s.size;
          case "rectangle":
              return s.width * s.height;
      }
  }
  ```

#### 4. 控制流分析
- **类型守卫**：更智能的类型推断
  ```typescript
  function process(x: string | number) {
      if (typeof x === "string") {
          // x 在这里是 string 类型
          return x.toUpperCase();
      }
      // x 在这里是 number 类型
      return x.toFixed(2);
  }
  ```

## 2.1（2016）

2016年12月发布。

### 核心特性
- **`keyof` 和查找类型**：映射类型的基础
  ```typescript
  interface Person {
      name: string;
      age: number;
  }
  
  type PersonKeys = keyof Person; // "name" | "age"
  
  function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
      return obj[key];
  }
  ```

- **映射类型（Mapped Types）**：转换对象类型
  ```typescript
  type Readonly<T> = {
      readonly [P in keyof T]: T[P];
  };
  
  type Partial<T> = {
      [P in keyof T]?: T[P];
  };
  ```

- **对象展开和剩余操作符**：支持 ES2018 对象扩展

## 2.2（2017）

2017年2月发布。

### 主要特性
- **`object` 类型**：表示非原始类型
  ```typescript
  function create(o: object | null): void {
      // ...
  }
  
  create({ prop: 0 }); // 正确
  create(null);        // 正确
  // create(42);       // 错误
  ```

- **支持混入（Mixin）类**：更好的类组合模式
- **改进的 JSX 支持**：`--jsx react-native`

## 2.3（2017）

2017年4月发布。

### 核心特性
- **`--strict` 模式**：启用所有严格检查选项
  ```json
  {
    "compilerOptions": {
      "strict": true
    }
  }
  ```

- **泛型参数默认值**：简化泛型使用
  ```typescript
  function create<T = string>(): T {
      // ...
  }
  
  let a = create();     // T 为 string
  let b = create<number>(); // T 为 number
  ```

- **迭代器和生成器支持**：目标 ES3/ES5

## 2.4（2017）

2017年6月发布。

### 主要特性
- **字符串枚举**：可读性更好的枚举
  ```typescript
  enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT"
  }
  ```

- **弱类型检测**：捕获可能的拼写错误
- **改进的回调参数推断**

## 2.8（2018）

2018年3月发布。

### 革命性特性
- **条件类型（Conditional Types）**：类型级别的条件表达式
  ```typescript
  type NonNullable<T> = T extends null | undefined ? never : T;
  
  type TypeName<T> =
      T extends string ? "string" :
      T extends number ? "number" :
      T extends boolean ? "boolean" :
      "object";
  ```

- **`infer` 关键字**：在条件类型中推断类型
  ```typescript
  type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
  
  function f(): number {
      return 42;
  }
  
  type F = ReturnType<typeof f>; // number
  ```

- **预定义的条件类型**：`Exclude`、`Extract`、`NonNullable`、`ReturnType` 等

## 3.0（2018）

2018年7月发布，是另一个重要的里程碑。

### 核心特性

#### 1. 元组类型改进
- **剩余参数元组**：更灵活的元组操作
  ```typescript
  function tuple<T extends any[]>(...args: T): T {
      return args;
  }
  
  const numbers = tuple(1, 2, 3, 4);
  const mixed = tuple("hello", true, 42);
  ```

#### 2. unknown 类型
- **顶层类型**：类型安全的 `any`
  ```typescript
  let value: unknown;
  
  value = 42;
  value = "hello";
  value = true;
  
  // 使用前必须进行类型检查
  if (typeof value === "string") {
      console.log(value.toUpperCase());
  }
  ```

#### 3. 项目引用
- **`--build` 模式**：支持大型项目的增量构建
  ```json
  {
    "references": [
      { "path": "../core" },
      { "path": "../utils" }
    ]
  }
  ```

## 3.4（2019）

2019年3月发布。

### 主要特性
- **`const` 断言**：更精确的字面量类型
  ```typescript
  let x = "hello" as const; // 类型为 "hello"
  
  let arr = [1, 2, 3] as const; // 类型为 readonly [1, 2, 3]
  
  let config = {
      name: "App",
      version: 1
  } as const; // 所有属性为 readonly
  ```

- **只读数组和元组**：`readonly T[]` 语法改进
- **全局 `this` 类型**：更好的全局脚本支持

## 3.7（2019）

2019年11月发布。

### 革命性特性

#### 1. 可选链（Optional Chaining）
- **`?.` 操作符**：安全访问嵌套属性
  ```typescript
  let x = foo?.bar?.baz;
  
  // 等同于
  let x = (foo === null || foo === undefined) 
      ? undefined 
      : (foo.bar === null || foo.bar === undefined) 
          ? undefined 
          : foo.bar.baz;
  ```

#### 2. 空值合并（Nullish Coalescing）
- **`??` 操作符**：处理 `null` 和 `undefined`
  ```typescript
  let x = foo ?? "default";
  
  // 等同于
  let x = (foo !== null && foo !== undefined) ? foo : "default";
  ```

#### 3. 断言函数（Assertion Functions）
- **类型断言**：自定义类型守卫
  ```typescript
  function assert(condition: any, msg?: string): asserts condition {
      if (!condition) {
          throw new AssertionError(msg);
      }
  }
  
  function yell(str: any) {
      assert(typeof str === "string");
      // str 在这里是 string 类型
      return str.toUpperCase();
  }
  ```

## 4.0（2020）

2020年8月发布，又一个重要里程碑。

### 核心特性

#### 1. 可变元组类型（Variadic Tuple Types）
- **泛型展开**：更强大的元组操作
  ```typescript
  type Strings = [string, string];
  type Numbers = [number, number];
  
  type StrStrNumNum = [...Strings, ...Numbers]; // [string, string, number, number]
  
  function concat<T extends any[], U extends any[]>(
      arr1: T,
      arr2: U
  ): [...T, ...U] {
      return [...arr1, ...arr2];
  }
  ```

#### 2. 标记元组元素
- **命名元组**：提高可读性
  ```typescript
  type Range = [start: number, end: number];
  type Foo = [first: number, second?: string, ...rest: any[]];
  ```

#### 3. 类属性推断
- **构造函数推断**：从初始化推断属性类型
  ```typescript
  class Person {
      name; // 从构造函数推断为 string
      age;  // 从构造函数推断为 number
      
      constructor(name: string, age: number) {
          this.name = name;
          this.age = age;
      }
  }
  ```

#### 4. 短路赋值运算符
- **`&&=`、`||=`、`??=`**：复合赋值
  ```typescript
  a ||= b; // a = a || b
  a &&= b; // a = a && b
  a ??= b; // a = a ?? b
  ```

## 4.1（2020）

2020年11月发布。

### 主要特性

#### 1. 模板字面量类型
- **字符串操作**：类型级别的字符串处理
  ```typescript
  type World = "world";
  type Greeting = `hello ${World}`; // "hello world"
  
  type Color = "red" | "blue";
  type Quantity = "one" | "two";
  type SeussFish = `${Quantity | Color} fish`; 
  // "one fish" | "two fish" | "red fish" | "blue fish"
  ```

#### 2. 键重映射（Key Remapping）
- **映射类型增强**：转换属性名
  ```typescript
  type Getters<T> = {
      [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
  };
  
  interface Person {
      name: string;
      age: number;
  }
  
  type LazyPerson = Getters<Person>;
  // { getName: () => string; getAge: () => number; }
  ```

#### 3. 递归条件类型
- **深度类型操作**：处理嵌套结构
  ```typescript
  type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;
  
  type P1 = Awaited<Promise<string>>;  // string
  type P2 = Awaited<Promise<Promise<number>>>; // number
  ```

## 4.2（2021）

2021年2月发布。

### 核心特性
- **元组中间展开**：更灵活的元组构造
  ```typescript
  type Arr = readonly any[];
  
  function concat<T extends Arr, U extends Arr>(
      arr1: T,
      arr2: U
  ): [...T, ...U] {
      return [...arr1, ...arr2];
  }
  ```

- **更智能的类型别名保留**：改进的错误消息
- **抽象构造签名**：支持抽象类构造
  ```typescript
  abstract class Shape {
      abstract getArea(): number;
  }
  
  type ShapeConstructor = new () => Shape;
  ```

## 4.3（2021）

2021年5月发布。

### 主要特性
- **单独的写入类型（Write Types）**：getter/setter 不同类型
  ```typescript
  class Thing {
      #size = 0;
      
      get size(): number {
          return this.#size;
      }
      
      set size(value: string | number | boolean) {
          let num = Number(value);
          this.#size = num;
      }
  }
  ```

- **`override` 关键字**：明确标记重写方法
  ```typescript
  class Base {
      greet() {
          console.log("Hello!");
      }
  }
  
  class Derived extends Base {
      override greet() {
          console.log("你好!");
      }
  }
  ```

- **静态索引签名**：类的静态属性
  ```typescript
  class MyClass {
      [s: string]: boolean | ((s: string) => boolean);
      
      check(s: string) {
          return this[s] as boolean;
      }
  }
  ```

## 4.4（2021）

2021年8月发布。

### 核心特性
- **控制流分析改进**：别名条件和判别式
  ```typescript
  function foo(arg: unknown) {
      const argIsString = typeof arg === "string";
      
      if (argIsString) {
          // arg 在这里是 string 类型
          console.log(arg.toUpperCase());
      }
  }
  ```

- **符号和模板字符串索引签名**
  ```typescript
  interface Options {
      [key: symbol]: any;
      [key: `data-${string}`]: string;
  }
  ```

- **`useUnknownInCatchVariables`**：catch 子句中使用 `unknown`
  ```typescript
  try {
      // ...
  } catch (e) { // e 是 unknown 而不是 any
      if (e instanceof Error) {
          console.log(e.message);
      }
  }
  ```

## 4.5（2021）

2021年11月发布。

### 主要特性
- **Awaited 类型**：内置 Promise 解包类型
  ```typescript
  type A = Awaited<Promise<string>>; // string
  type B = Awaited<Promise<Promise<number>>>; // number
  ```

- **类型导入名称的支持**
  ```typescript
  import { type SomeType } from "./module";
  ```

- **私有字段存在性检查**：`#field in object`
  ```typescript
  class Person {
      #name: string;
      
      equals(other: unknown) {
          return other && 
                 typeof other === "object" && 
                 #name in other && 
                 this.#name === other.#name;
      }
  }
  ```

## 4.6（2022）

2022年2月发布。

### 核心特性
- **控制流分析改进**：依赖参数的类型守卫
  ```typescript
  function isArrayOfStrings(arr: unknown[]): arr is string[] {
      return arr.every(x => typeof x === "string");
  }
  ```

- **索引访问的改进推断**
- **递归类型检查改进**：更好的性能

## 4.7（2022）

2022年5月发布。

### 主要特性

#### 1. ES 模块支持
- **`"type": "module"` 和 `.mts`/`.cts` 文件**
  ```json
  {
    "compilerOptions": {
      "module": "node16",
      "moduleResolution": "node16"
    }
  }
  ```

#### 2. 计算属性的控制流分析
  ```typescript
  const key = Symbol();
  
  const obj = {
      [key]: Math.random() < 0.5 ? 42 : "hello"
  };
  
  if (typeof obj[key] === "string") {
      // obj[key] 在这里是 string 类型
      let str = obj[key].toUpperCase();
  }
  ```

#### 3. 对象内函数的类型推断改进
  ```typescript
  const obj = {
      values: [1, 2, 3],
      
      // methods 可以引用 values 的类型
      double() {
          return this.values.map(x => x * 2);
      }
  };
  ```

## 4.8（2022）

2022年8月发布。

### 核心特性
- **改进的交叉类型简化**
  ```typescript
  type Foo = { kind: "foo", value: string };
  type Bar = { kind: "bar", value: number };
  
  type FooBar = Foo & Bar; // never（更智能的检测）
  ```

- **`--build` 性能改进**：增量构建优化
- **推断模板字符串的改进**

## 4.9（2022）

2022年11月发布。

### 主要特性

#### 1. satisfies 操作符
- **类型检查但保留推断**：既验证又保留具体类型
  ```typescript
  type Colors = "red" | "green" | "blue";
  type RGB = [number, number, number];
  
  const palette = {
      red: [255, 0, 0],
      green: "#00ff00",
      blue: [0, 0, 255]
  } satisfies Record<Colors, string | RGB>;
  
  // palette.red 的类型是 [number, number, number]
  const redComponent = palette.red[0];
  
  // palette.green 的类型是 string
  const greenNormalized = palette.green.toUpperCase();
  ```

#### 2. 未使用的标签检测
- **检测无用标签**：避免潜在错误

#### 3. accessor 关键字
- **自动访问器**：简化 getter/setter
  ```typescript
  class Person {
      accessor name: string;
      
      constructor(name: string) {
          this.name = name;
      }
  }
  ```

## 5.0（2023）

2023年3月发布，是最新的重大版本。

### 革命性特性

#### 1. 装饰器标准化
- **Stage 3 装饰器**：符合 ECMAScript 标准的装饰器
  ```typescript
  function logged(value: any, context: ClassMethodDecoratorContext) {
      return function (...args: any[]) {
          console.log(`调用 ${String(context.name)}`);
          return value.apply(this, args);
      };
  }
  
  class Calculator {
      @logged
      add(a: number, b: number) {
          return a + b;
      }
  }
  ```

#### 2. const 类型参数
- **泛型中的 const**：保留字面量类型
  ```typescript
  function tuple<const T extends readonly unknown[]>(...args: T): T {
      return args;
  }
  
  const arr = tuple(1, 2, 3);
  // arr 的类型是 readonly [1, 2, 3]
  ```

#### 3. 枚举改进
- **联合枚举的优化**

#### 4. 所有导出都支持 type 修饰符
  ```typescript
  export { type SomeType } from "./module";
  ```

## 5.1（2023）

2023年6月发布。

### 核心特性
- **返回值类型优化**：更简单的函数返回类型
- **JSX 改进**：更好的 React 支持
- **Getter 和 Setter 的类型解耦**：完善独立类型支持

## 5.2（2023）

2023年8月发布。

### 主要特性
- **`using` 声明**：显式资源管理
  ```typescript
  {
      using file = openFile("example.txt");
      // 使用 file
  } // 自动调用 file[Symbol.dispose]()
  ```

- **装饰器元数据**：装饰器的元数据支持
- **元组标签命名改进**

## 5.3（2023）

2023年11月发布。

### 核心特性
- **导入属性（Import Attributes）**
  ```typescript
  import data from "./data.json" with { type: "json" };
  ```

- **`switch(true)` 类型缩窄**：更智能的类型推断
  ```typescript
  function format(value: string | number) {
      switch (true) {
          case typeof value === "string":
              return value.toUpperCase();
          case typeof value === "number":
              return value.toFixed(2);
      }
  }
  ```

- **实例字段的类型缩窄改进**

## 5.4（2024）

2024年3月发布。

### 主要特性
- **`NoInfer` 工具类型**：阻止类型推断
  ```typescript
  function createStreetLight<C extends string>(
      colors: C[],
      defaultColor: NoInfer<C>
  ) {
      // ...
  }
  
  createStreetLight(["red", "yellow", "green"], "red"); // 正确
  // createStreetLight(["red", "yellow", "green"], "blue"); // 错误
  ```

- **保留对象方法中缩窄后的类型**
- **闭包中的类型缩窄改进**

## 5.5（2024）

2024年6月发布。

### 核心特性
- **推断的类型谓词**：自动推断类型守卫
  ```typescript
  function isString(x: unknown) {
      return typeof x === "string";
  }
  
  // TypeScript 自动推断为: function isString(x: unknown): x is string
  ```

- **常量索引访问的控制流缩窄**
- **正则表达式语法检查**：编译时验证正则表达式

## 5.6（2024）

2024年9月发布。

### 主要特性
- **排除空值后的迭代器辅助方法**
  ```typescript
  const numbers = [1, null, 2, undefined, 3].filter(x => x != null);
  // numbers 的类型是 number[]
  ```

- **任意的模块标识符**：支持更多模块名称格式
- **`--noCheck` 编译选项**：跳过类型检查直接生成代码

## 5.7（2024）

2024年11月发布。

### 核心特性
- **路径重写**：改进的模块解析
  ```json
  {
    "compilerOptions": {
      "paths": {
        "@/*": ["./src/*"]
      }
    }
  }
  ```

- **相对类型解析改进**
- **初始化变量检查**：检测未初始化的变量

## 5.8（2025）

2025年2月发布。

### 核心特性

#### 1. 返回表达式分支的精细检查
- **更严格的条件返回类型检查**：条件表达式在 `return` 语句中时，每个分支单独检查
  ```typescript
  declare const untypedCache: Map<any, any>;
  
  function getUrlObject(urlString: string): URL {
      return untypedCache.has(urlString) ?
          untypedCache.get(urlString) :
          urlString;  // 错误! Type 'string' is not assignable to type 'URL'
  }
  ```

#### 2. 支持 `require()` ECMAScript 模块
- **CommonJS 中导入 ESM**：在 `--module nodenext` 模式下支持 `require()` ESM 模块
  ```typescript
  // 在 CommonJS 模块中
  const esmModule = require('./esm-module.mjs');
  // 注意：不能 require() 包含顶级 await 的 ESM 文件
  ```

#### 3. `--module node18` 选项
- **稳定的 Node.js 18 参考点**：为使用 Node.js 18 的用户提供稳定配置
  ```json
  {
    "compilerOptions": {
      "module": "node18"
    }
  }
  ```
  - 与 `nodenext` 的区别：
    - `node18` 不允许 `require()` ESM 模块
    - `node18` 允许 import assertions（已被 import attributes 取代）

#### 4. `--erasableSyntaxOnly` 选项
- **检测非可擦除语法**：检测具有运行时行为的 TypeScript 特定构造
  ```typescript
  class C {
      constructor(public x: number) { }
      // 错误! This syntax is not allowed when 'erasableSyntaxOnly' is enabled
  }
  
  // 以下语法在此模式下会报错：
  // - 枚举（enums）
  // - 命名空间（namespaces）
  // - 参数属性（parameter properties）
  ```

#### 5. `--libReplacement` 标志
- **禁用自动库查找**：提高性能
  ```json
  {
    "compilerOptions": {
      "libReplacement": false
    }
  }
  ```

#### 6. 声明文件中保留计算属性名
- **保留实体名称作为计算属性**：在类中使用变量名作为计算属性
  ```typescript
  export let propName = "theAnswer";
  
  export class MyClass {
      [propName] = 42;  // 现在允许
  }
  
  // 生成的声明文件：
  export declare let propName: string;
  export declare class MyClass {
      [propName]: number;
  }
  ```

### 显著行为变更
- **Import Assertions 限制**：在 `--module nodenext` 模式下，必须使用 `with` 关键字的 import attributes
  ```typescript
  // ❌ 错误
  import data from "./data.json" assert { type: "json" };
  
  // ✅ 正确
  import data from "./data.json" with { type: "json" };
  ```

### 性能优化
- 避免路径规范化时的数组分配
- 优化配置选项验证，提升增量编译性能

## 5.9（2025）

2025年5月发布。

### 核心特性

#### 1. 精简和更新的 `tsc --init`
- **更简洁的配置文件**：生成更有指导性的 `tsconfig.json`
  ```json
  {
    "compilerOptions": {
      "module": "nodenext",
      "target": "esnext",
      "types": [],
      "sourceMap": true,
      "declaration": true,
      "declarationMap": true,
      "noUncheckedIndexedAccess": true,
      "exactOptionalPropertyTypes": true,
      "strict": true,
      "jsx": "react-jsx",
      "verbatimModuleSyntax": true,
      "isolatedModules": true,
      "noUncheckedSideEffectImports": true,
      "moduleDetection": "force",
      "skipLibCheck": true
    }
  }
  ```

#### 2. 支持 `import defer`
- **延迟模块评估**：延迟模块执行直到首次访问其导出
  ```typescript
  import defer * as feature from "./some-feature.js";
  
  // 模块尚未执行
  
  // 访问 specialConstant 时才执行模块
  console.log(feature.specialConstant); // 42
  ```

#### 3. 支持 `--module node20`
- **稳定的 Node.js 20 选项**：模拟 Node.js v20 行为
  ```json
  {
    "compilerOptions": {
      "module": "node20",
      "moduleResolution": "node20"
    }
  }
  ```

#### 4. DOM API 摘要描述
- **基于 MDN 的文档**：许多 DOM API 现在包含快速参考描述，无需跳转到外部文档

#### 5. 可展开的悬停提示（预览）
- **交互式类型信息**：悬停提示中新增 `+` 和 `-` 按钮，可展开或折叠类型信息

#### 6. 可配置的最大悬停长度
- **自定义悬停长度**：通过 VS Code 的 `js/ts.hover.maximumLength` 设置调整

### 性能优化
- **映射器缓存实例化**：缓存类型参数替换过程中的中间实例化
- **优化文件存在性检查**：在大型项目中速度提升约 11%

### 显著行为变更
- **`lib.d.ts` 变更**：`ArrayBuffer` 不再是多个 `TypedArray` 类型的父类型
  ```typescript
  // 可能导致的错误
  // error TS2345: Argument of type 'ArrayBufferLike' is not assignable to parameter of type 'BufferSource'
  
  // 解决方案
  let data = new Uint8Array([0, 1, 2, 3, 4]);
  // someFunc(data)  // 错误
  someFunc(data.buffer)  // 正确
  ```

- **类型参数推断变更**：修复了类型变量推断过程中的"泄漏"问题，可能引入新的类型错误

## 总结

TypeScript 从简单的 JavaScript 超集发展成为一个功能完整、强大的静态类型语言：

关键里程碑：
- **TypeScript 1.0（2014）**：正式发布，建立类型系统基础
- **TypeScript 2.0（2016）**：非空检查、只读属性、控制流分析
- **TypeScript 2.8（2018）**：条件类型、`infer` 关键字
- **TypeScript 3.0（2018）**：`unknown` 类型、项目引用
- **TypeScript 3.7（2019）**：可选链、空值合并
- **TypeScript 4.0（2020）**：可变元组类型、标记元组
- **TypeScript 4.1（2020）**：模板字面量类型
- **TypeScript 5.0（2023）**：标准化装饰器、const 类型参数

重点关注的版本：
- **TypeScript 2.0**：现代 TypeScript 的基础
- **TypeScript 2.8**：高级类型操作的开端
- **TypeScript 3.7**：极大提升开发体验
- **TypeScript 4.1**：类型级别编程的新高度
- **TypeScript 5.0**：拥抱 ECMAScript 标准

## 参考资料
- [TypeScript 官方文档](https://www.typescriptlang.org/docs/)
- [TypeScript GitHub 仓库](https://github.com/microsoft/TypeScript)
- [TypeScript 版本发布说明](https://www.typescriptlang.org/docs/handbook/release-notes/overview.html)
- [TypeScript 路线图](https://github.com/microsoft/TypeScript/wiki/Roadmap)

**祝你变得更强!**
