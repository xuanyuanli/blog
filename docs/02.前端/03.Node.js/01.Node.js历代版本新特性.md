---
title: Node.js历代版本新特性
date: 2025-02-16 21:00:00
permalink: /pages/nodejs-versions/
categories:
  - 前端
  - Node.js
tags:
  - Node.js版本新特性
  - Node.js
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

## 前言

Node.js 诞生于2009年，由 Ryan Dahl 创建，将 Chrome V8 JavaScript 引擎带到服务器端。从最初简单的服务器端运行时，发展到今天成为全栈开发的核心技术之一。

Node.js 采用事件驱动、非阻塞 I/O 模型，使其轻量且高效。凭借 npm 生态系统的支持，Node.js 已经成为现代 Web 开发不可或缺的一部分。

本文系统梳理了 Node.js 各个版本的核心特性和发展历程。对于每个版本，我们会重点介绍那些影响深远的特性和重要的改进。

<!-- more -->

**阅读建议**：
- 标记为 **粗体** 的特性通常是该版本最重要的改进
- Node.js 12、14、16、18、20、22 是 LTS（长期支持）版本，建议重点关注
- 代码示例可以帮助你快速理解新特性的用法

## Node.js 版本发布流程

Node.js 采用定期发布模式，由 Node.js Technical Steering Committee (TSC) 管理。

### 关键特点
- 每年发布两个主要版本（4月和10月）
- 偶数版本（如 18.x、20.x）成为 LTS（长期支持）版本
- 奇数版本为当前版本（Current），支持周期较短
- LTS 版本支持 30 个月（Active LTS 18个月 + Maintenance LTS 12个月）

### 版本周期
- **Current**：6个月，包含最新特性
- **Active LTS**：18个月，接收所有更新
- **Maintenance LTS**：12个月，仅接收关键 bug 修复和安全补丁
- **End-of-Life (EOL)**：不再接收任何更新

### 命名规则
- 版本号采用 `主版本.次版本.补丁版本` 格式（如 20.11.0）
- LTS 版本以元素命名（如 Hydrogen、Iron、Argon）

## 0.x（2009-2015）

Node.js 的早期版本，快速迭代和实验阶段。

### 核心特性
- **基于 V8 引擎**：将 JavaScript 带到服务器端
- **事件驱动架构**：非阻塞 I/O 模型
- **npm 包管理器**：JavaScript 生态系统的基石
- **核心模块**：http、fs、path、stream 等
- **原生模块支持**：通过 C++ Addons 扩展功能

## 4 Argon LTS（2015年9月）

Node.js 和 io.js 合并后的第一个版本，标志着统一的开始。

### 主要特性

#### **ES6 支持**
通过更新 V8 引擎，支持大量 ES6 特性。

```javascript
// 箭头函数
const square = x => x * x;

// 类
class Server {
  constructor(port) {
    this.port = port;
  }
}

// 模板字符串
const message = `Server running on port ${port}`;

// let/const
let count = 0;
const MAX = 100;
```

#### Buffer 改进
Buffer API 更加安全和易用。

```javascript
// 旧方式（不推荐）
const buf1 = new Buffer(10);

// 新方式
const buf2 = Buffer.alloc(10); // 分配并填充 0
const buf3 = Buffer.allocUnsafe(10); // 分配但不填充（更快）
const buf4 = Buffer.from([1, 2, 3]);
const buf5 = Buffer.from('hello', 'utf8');
```

## 6 Boron LTS（2016年4月）

提升性能和稳定性，更多 ES6 支持。

### 主要特性

#### **性能提升**
- V8 引擎升级到 5.0
- 显著的性能改进

#### **ES6 增强支持**
```javascript
// 默认参数
function connect(host = 'localhost', port = 8080) {
  console.log(`Connecting to ${host}:${port}`);
}

// 解构赋值
const { name, version } = require('./package.json');

// 扩展运算符
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];

// Proxy
const handler = {
  get(target, property) {
    return property in target ? target[property] : 'default';
  }
};
const p = new Proxy({}, handler);
```

#### npm 3
- 扁平化依赖树
- 减少磁盘空间占用

## 8 Carbon LTS（2017年5月）

引入 async/await，改变异步编程范式。

### 主要特性

#### **Async/Await 支持**
原生支持 async/await，无需转译器。

```javascript
// Promise 方式
function fetchData() {
  return fetch('/api/data')
    .then(res => res.json())
    .then(data => console.log(data))
    .catch(err => console.error(err));
}

// async/await 方式
async function fetchData() {
  try {
    const res = await fetch('/api/data');
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}
```

#### **util.promisify()**
将回调函数转换为 Promise。

```javascript
const util = require('util');
const fs = require('fs');

// 传统回调方式
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});

// Promisify 方式
const readFileAsync = util.promisify(fs.readFile);
async function read() {
  const data = await readFileAsync('file.txt', 'utf8');
  console.log(data);
}
```

#### N-API
提供稳定的原生模块 API，减少版本间的兼容性问题。

```c
// N-API 示例
napi_value Method(napi_env env, napi_callback_info info) {
  napi_value greeting;
  napi_create_string_utf8(env, "Hello", NAPI_AUTO_LENGTH, &greeting);
  return greeting;
}
```

## 10 Dubnium LTS（2018年4月）

ESM 实验支持和性能改进。

### 主要特性

#### **ESM 模块实验支持**
通过 `.mjs` 扩展名或 `package.json` 中的 `type: "module"` 启用。

```javascript
// math.mjs
export function add(a, b) {
  return a + b;
}

export const PI = 3.14159;

// main.mjs
import { add, PI } from './math.mjs';
console.log(add(2, 3)); // 5
console.log(PI); // 3.14159
```

#### **fs Promises API**
原生 Promise 版本的文件系统 API。

```javascript
const fs = require('fs').promises;

async function readAndWrite() {
  try {
    const data = await fs.readFile('input.txt', 'utf8');
    await fs.writeFile('output.txt', data.toUpperCase());
    console.log('File processed successfully');
  } catch (err) {
    console.error('Error:', err);
  }
}
```

#### **HTTP/2 稳定**
```javascript
const http2 = require('http2');
const fs = require('fs');

const server = http2.createSecureServer({
  key: fs.readFileSync('localhost-privkey.pem'),
  cert: fs.readFileSync('localhost-cert.pem')
});

server.on('stream', (stream, headers) => {
  stream.respond({
    'content-type': 'text/html',
    ':status': 200
  });
  stream.end('<h1>Hello HTTP/2!</h1>');
});

server.listen(8443);
```

## 12 Erbium LTS（2019年4月）

工作线程、ES 模块改进和诊断报告。

### 主要特性

#### **Worker Threads 稳定**
真正的多线程支持，适合 CPU 密集型任务。

```javascript
// main.js
const { Worker } = require('worker_threads');

const worker = new Worker('./worker.js', {
  workerData: { num: 5 }
});

worker.on('message', result => {
  console.log(`Result: ${result}`);
});

worker.on('error', err => {
  console.error('Worker error:', err);
});

// worker.js
const { parentPort, workerData } = require('worker_threads');

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const result = fibonacci(workerData.num);
parentPort.postMessage(result);
```

#### **诊断报告（Diagnostic Reports）**
自动生成诊断报告，帮助调试和问题分析。

```javascript
// 生成报告
process.report.writeReport('./report.json');

// 配置报告触发条件
process.report.reportOnFatalError = true;
process.report.reportOnSignal = true;
process.report.reportOnUncaughtException = true;

// 启动时通过命令行
// node --report-on-fatalerror app.js
```

#### **私有类字段支持**
```javascript
class Counter {
  #count = 0;

  increment() {
    this.#count++;
  }

  getCount() {
    return this.#count;
  }
}

const counter = new Counter();
counter.increment();
console.log(counter.getCount()); // 1
// console.log(counter.#count); // SyntaxError
```

#### **TLS 1.3 支持**
更安全、更快的 TLS 协议。

```javascript
const tls = require('tls');
const fs = require('fs');

const options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),
  minVersion: 'TLSv1.3'
};

const server = tls.createServer(options, socket => {
  socket.write('Welcome!\n');
  socket.pipe(socket);
});

server.listen(8000);
```

## 14 Fermium LTS（2020年4月）

诊断工具改进、可选链和空值合并支持。

### 主要特性

#### **可选链和空值合并**
支持 ES2020 的可选链（`?.`）和空值合并（`??`）操作符。

```javascript
// 可选链
const user = {
  profile: {
    email: 'user@example.com'
  }
};

console.log(user.profile?.email); // 'user@example.com'
console.log(user.settings?.theme); // undefined
console.log(user.getEmail?.()); // undefined（方法不存在）

// 空值合并
const port = process.env.PORT ?? 3000;
const timeout = config.timeout ?? 5000;

// 与 || 的区别
console.log(0 || 100); // 100
console.log(0 ?? 100); // 0
console.log('' ?? 'default'); // ''
```

#### **国际化 API 改进**
```javascript
// Intl.DisplayNames
const regionNames = new Intl.DisplayNames(['zh-CN'], { type: 'region' });
console.log(regionNames.of('US')); // 美国
console.log(regionNames.of('CN')); // 中国

// Intl.DateTimeFormat 日历和数字系统
const formatter = new Intl.DateTimeFormat('zh-CN', {
  calendar: 'chinese',
  numberingSystem: 'arab'
});
```

#### **流改进**
```javascript
const { pipeline } = require('stream');
const { createReadStream, createWriteStream } = require('fs');
const { createGzip } = require('zlib');
const { promisify } = require('util');

const pipe = promisify(pipeline);

async function compress() {
  await pipe(
    createReadStream('input.txt'),
    createGzip(),
    createWriteStream('input.txt.gz')
  );
  console.log('Compression complete');
}

compress().catch(console.error);
```

#### **诊断频道（Diagnostic Channels）**
提供发布-订阅模式的诊断信息。

```javascript
const diagnostics_channel = require('diagnostics_channel');

// 创建频道
const channel = diagnostics_channel.channel('my-app.request');

// 订阅
channel.subscribe(message => {
  console.log('Request:', message);
});

// 发布
if (channel.hasSubscribers) {
  channel.publish({
    url: '/api/users',
    method: 'GET'
  });
}
```

## 16 Gallium LTS（2021年4月）

V8 引擎升级、Timers Promises API 和 Web Crypto API。

### 主要特性

#### **Timers Promises API**
Promise 版本的定时器函数。

```javascript
const { setTimeout, setInterval } = require('timers/promises');

// Promise 版 setTimeout
async function delay() {
  console.log('Start');
  await setTimeout(1000);
  console.log('After 1 second');
}

// 可中止的定时器
async function abortableDelay() {
  const controller = new AbortController();
  const { signal } = controller;

  setTimeout(() => controller.abort(), 500);

  try {
    await setTimeout(1000, undefined, { signal });
    console.log('Completed');
  } catch (err) {
    if (err.name === 'AbortError') {
      console.log('Timeout was aborted');
    }
  }
}

// 异步迭代器
async function tick() {
  for await (const time of setInterval(100, Date.now())) {
    console.log('Tick:', time);
    if (time > Date.now() + 500) break;
  }
}
```

#### **Web Crypto API**
提供 Web 标准的加密 API。

```javascript
const { webcrypto } = require('crypto');
const { subtle } = webcrypto;

async function generateKey() {
  const key = await subtle.generateKey(
    {
      name: 'AES-GCM',
      length: 256
    },
    true,
    ['encrypt', 'decrypt']
  );
  return key;
}

async function encrypt(key, data) {
  const iv = webcrypto.getRandomValues(new Uint8Array(12));
  const encrypted = await subtle.encrypt(
    {
      name: 'AES-GCM',
      iv: iv
    },
    key,
    new TextEncoder().encode(data)
  );
  return { encrypted, iv };
}
```

#### **RegExp Match Indices**
获取正则表达式匹配的索引位置。

```javascript
const regex = /(\d{4})-(\d{2})-(\d{2})/d;
const match = regex.exec('Today is 2024-01-15');

console.log(match.indices); // [[9, 19], [9, 13], [14, 16], [17, 19]]
console.log(match.indices[1]); // [9, 13] - 年份位置
console.log(match.indices[2]); // [14, 16] - 月份位置
```

#### **npm 7**
- Workspaces 支持
- 自动安装 peer dependencies
- package-lock.json v2 格式

```json
// package.json with workspaces
{
  "name": "my-project",
  "workspaces": [
    "packages/*"
  ]
}
```

## 18 Hydrogen LTS（2022年4月）

Fetch API、测试运行器和改进的 ESM 支持。

### 主要特性

#### **Fetch API 原生支持**
无需安装外部依赖即可使用 Fetch API。

```javascript
// 基本用法
const response = await fetch('https://api.example.com/data');
const data = await response.json();

// 带选项的请求
const response = await fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  body: JSON.stringify({ name: 'John', age: 30 })
});

// 错误处理
try {
  const response = await fetch('https://api.example.com/data');
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const data = await response.json();
} catch (err) {
  console.error('Fetch error:', err);
}

// FormData 支持
const formData = new FormData();
formData.append('file', fileBuffer, 'document.pdf');
formData.append('username', 'john');

await fetch('https://api.example.com/upload', {
  method: 'POST',
  body: formData
});
```

#### **Test Runner（实验性）**
内置的测试运行器，无需额外安装测试框架。

```javascript
// test.js
const { test, describe, it } = require('node:test');
const assert = require('node:assert');

describe('Math operations', () => {
  it('should add two numbers', () => {
    assert.strictEqual(2 + 2, 4);
  });

  it('should multiply two numbers', () => {
    assert.strictEqual(3 * 4, 12);
  });
});

test('async test', async (t) => {
  const result = await Promise.resolve(42);
  assert.strictEqual(result, 42);
});

// 运行测试
// node --test test.js
// node --test **/*.test.js
```

#### **V8 10.1**
- `findLast()` 和 `findLastIndex()` 数组方法
- `at()` 方法支持负索引

```javascript
const arr = [1, 2, 3, 4, 5];

// findLast / findLastIndex
const lastEven = arr.findLast(x => x % 2 === 0); // 4
const lastEvenIndex = arr.findLastIndex(x => x % 2 === 0); // 3

// at() 方法
console.log(arr.at(0)); // 1
console.log(arr.at(-1)); // 5
console.log(arr.at(-2)); // 4
```

#### **Watch 模式（实验性）**
自动重启应用程序当文件改变时。

```bash
# 监视模式
node --watch app.js

# 监视模式 + 调试
node --watch --inspect app.js
```

## 20 Iron LTS（2023年4月）

权限模型、稳定的测试运行器和性能改进。

### 主要特性

#### **权限模型（实验性）**
限制 Node.js 进程的文件系统和子进程访问权限。

```bash
# 只允许读取特定目录
node --experimental-permission --allow-fs-read=/app/data app.js

# 只允许写入特定目录
node --experimental-permission --allow-fs-write=/app/logs app.js

# 允许子进程
node --experimental-permission --allow-child-process app.js

# 组合权限
node --experimental-permission \
  --allow-fs-read=/app/data \
  --allow-fs-write=/app/logs \
  app.js
```

#### **稳定的测试运行器**
测试运行器从实验性升级为稳定。

```javascript
const { test, describe, it, before, after, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert');

describe('User API', () => {
  let server;

  before(async () => {
    server = await startServer();
  });

  after(async () => {
    await server.close();
  });

  beforeEach(() => {
    console.log('Running test...');
  });

  it('should create a user', async () => {
    const response = await fetch(`${server.url}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'John' })
    });
    assert.strictEqual(response.status, 201);
  });

  // 跳过测试
  it.skip('should update a user', () => {
    // 暂时跳过
  });

  // 只运行这个测试
  it.only('should delete a user', async () => {
    // 只运行这个
  });
});

// Mock 功能
test('mock function', (t) => {
  const mock = t.mock.fn();
  mock('arg1', 'arg2');
  
  assert.strictEqual(mock.mock.calls.length, 1);
  assert.deepStrictEqual(mock.mock.calls[0].arguments, ['arg1', 'arg2']);
});
```

#### **自定义 ESM 加载器 Hooks**
更强大的模块加载器自定义能力。

```javascript
// loader.mjs
export async function resolve(specifier, context, nextResolve) {
  // 自定义模块解析逻辑
  if (specifier.startsWith('app:')) {
    return {
      url: new URL(specifier.slice(4), import.meta.url).href,
      shortCircuit: true
    };
  }
  return nextResolve(specifier, context);
}

export async function load(url, context, nextLoad) {
  // 自定义模块加载逻辑
  if (url.endsWith('.json')) {
    const content = await fs.promises.readFile(new URL(url), 'utf8');
    return {
      format: 'json',
      source: content,
      shortCircuit: true
    };
  }
  return nextLoad(url, context);
}

// 使用
// node --loader=./loader.mjs app.js
```

#### **V8 11.3**
- 支持 Array 和 TypedArray 的 `toSorted()`, `toReversed()`, `toSpliced()`, `with()` 方法
- 支持 `Array.fromAsync()`

```javascript
// 非破坏性数组方法
const arr = [3, 1, 4, 1, 5];
const sorted = arr.toSorted(); // [1, 1, 3, 4, 5]
const reversed = arr.toReversed(); // [5, 1, 4, 1, 3]
const spliced = arr.toSpliced(1, 2, 9, 2); // [3, 9, 2, 1, 5]
const replaced = arr.with(2, 99); // [3, 1, 99, 1, 5]

console.log(arr); // [3, 1, 4, 1, 5] - 原数组未改变

// Array.fromAsync
async function* generateNumbers() {
  yield 1;
  yield 2;
  yield 3;
}

const numbers = await Array.fromAsync(generateNumbers());
console.log(numbers); // [1, 2, 3]
```

#### **稳定的 Watch 模式**
```bash
# 监视模式已稳定
node --watch server.js

# 监视测试
node --test --watch
```

## 21（2023年10月）

Current 版本，引入实验性特性。

### 主要特性

#### **稳定的 Fetch API**
Fetch API 完全稳定，性能优化。

#### **内置 WebSocket 客户端（实验性）**
```javascript
const ws = new WebSocket('ws://localhost:8080');

ws.onopen = () => {
  console.log('Connected');
  ws.send('Hello Server');
};

ws.onmessage = (event) => {
  console.log('Received:', event.data);
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};

ws.onclose = () => {
  console.log('Connection closed');
};
```

#### **导航器 API（实验性）**
```javascript
// 全局 navigator 对象
console.log(navigator.userAgent);
console.log(navigator.platform);
console.log(navigator.language);
```

## 22 Jod LTS（2024年4月）

网络 API 增强和性能改进。

### 主要特性

#### **require() ESM 支持（实验性）**
在 CommonJS 中直接 `require()` ESM 模块。

```javascript
// 传统方式（异步）
const module = await import('./esm-module.mjs');

// 新方式（同步，实验性）
const module = require('./esm-module.mjs');
```

#### **Maglev 编译器**
V8 的新中间层编译器，提升启动性能。

```bash
# 启用 Maglev
node --maglev app.js
```

#### **WebSocket 客户端稳定**
内置 WebSocket 客户端 API 稳定。

```javascript
// 完整示例
const ws = new WebSocket('ws://localhost:8080');

ws.addEventListener('open', () => {
  console.log('Connected');
  ws.send(JSON.stringify({ type: 'hello', data: 'world' }));
});

ws.addEventListener('message', (event) => {
  const message = JSON.parse(event.data);
  console.log('Received:', message);
});

ws.addEventListener('error', (error) => {
  console.error('Error:', error);
});

ws.addEventListener('close', (event) => {
  console.log('Closed:', event.code, event.reason);
});

// 发送二进制数据
ws.send(new Uint8Array([1, 2, 3, 4]));
```

#### **Node.js 观察 API（实验性）**
提供性能监控和观察能力。

```javascript
const { PerformanceObserver } = require('perf_hooks');

// 观察性能指标
const obs = new PerformanceObserver((items) => {
  items.getEntries().forEach((entry) => {
    console.log(entry.name, entry.duration);
  });
});

obs.observe({ entryTypes: ['measure', 'function'] });

// 标记和测量
performance.mark('start');
// ... 执行操作
performance.mark('end');
performance.measure('operation', 'start', 'end');
```

## 23（2024年10月）

Current 版本，持续改进和优化。

### 主要特性

#### **默认启用 ES 模块检测**
自动检测 `.js` 文件是 CommonJS 还是 ES 模块。

```javascript
// package.json 中的 type 字段变得更智能
{
  "type": "module"
}

// 自动检测 imports/exports
```

#### **SQLite 支持（实验性）**
内置 SQLite 数据库支持。

```javascript
const { Database } = require('node:sqlite');

const db = new Database(':memory:');

// 创建表
db.exec(`
  CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE
  )
`);

// 插入数据
const stmt = db.prepare('INSERT INTO users (name, email) VALUES (?, ?)');
stmt.run('John Doe', 'john@example.com');
stmt.run('Jane Smith', 'jane@example.com');

// 查询数据
const users = db.prepare('SELECT * FROM users').all();
console.log(users);

// 关闭数据库
db.close();
```

#### **测试覆盖率报告**
内置测试覆盖率支持。

```bash
# 生成覆盖率报告
node --test --experimental-test-coverage

# 指定覆盖率输出格式
node --test --experimental-test-coverage --test-reporter=lcov
```

## 24（2025年4月）

Current 版本，将于 2025年10月 成为 LTS 版本。

### 主要特性

#### **V8 引擎升级到 13.6**
带来多个重要的 JavaScript 新特性。

```javascript
// Float16Array 支持
const float16 = new Float16Array([1.5, 2.5, 3.5]);
console.log(float16[0]); // 1.5

// RegExp.escape - 转义正则特殊字符
const userInput = 'a.b*c?d';
const escaped = RegExp.escape(userInput);
const regex = new RegExp(escaped); // 匹配字面量 "a.b*c?d"

// Error.isError - 检查是否为 Error 对象
console.log(Error.isError(new Error('test'))); // true
console.log(Error.isError(new TypeError('test'))); // true
console.log(Error.isError({ message: 'not an error' })); // false
```

#### **TypeScript 支持（实验性）**
通过类型剥离（Type Stripping）直接运行 `.ts` 文件。

```bash
# 运行 TypeScript 文件
node --experimental-strip-types index.ts

# 支持需要转换的 TypeScript 特性（enum、namespace 等）
node --experimental-transform-types index.ts
```

```typescript
// index.ts
function greet(name: string): string {
  return `Hello, ${name}!`;
}

interface User {
  id: number;
  name: string;
}

const user: User = { id: 1, name: 'John' };
console.log(greet(user.name));
```

**注意**：
- `--experimental-strip-types` 只处理可擦除的类型注解
- `enum`、`namespace`、`const enum` 和参数属性需要 `--experimental-transform-types`
- 复杂项目仍建议使用 `tsc` 或构建工具

#### **内置 .env 文件支持**
无需 `dotenv` 等外部库即可加载环境变量。

```bash
# .env
PORT=3000
DB_HOST=localhost
DB_USER=admin
API_KEY=secret123
```

```javascript
// 加载 .env 文件
// node --env-file=.env app.js

console.log(process.env.PORT); // 3000
console.log(process.env.DB_HOST); // localhost

// 支持多个 .env 文件
// node --env-file=.env --env-file=.env.local app.js
```

#### **npm 11**
性能、安全性和现代 JavaScript 包兼容性提升。

```bash
# npm 11 的主要改进
# - 更快的安装速度
# - 改进的依赖解析
# - 更好的 ESM 支持
# - 增强的安全性检查
```

#### **AsyncLocalStorage 使用 AsyncContextFrame**
默认使用 `AsyncContextFrame` 实现，提升异步上下文追踪的效率和可靠性。

```javascript
const { AsyncLocalStorage } = require('async_hooks');
const asyncLocalStorage = new AsyncLocalStorage();

// 更可靠的上下文传播
function handleRequest(req, res) {
  const store = { requestId: Math.random(), userId: req.userId };
  
  asyncLocalStorage.run(store, async () => {
    await processRequest();
    await saveToDatabase();
    // 所有异步操作都能访问到 store
  });
}

async function saveToDatabase() {
  const store = asyncLocalStorage.getStore();
  console.log('Request ID:', store.requestId);
  // 即使跨越多个异步边界，上下文仍然可用
}
```

#### **URLPattern API 全局可用**
无需导入即可使用 `URLPattern` 进行 URL 匹配和数据提取。

```javascript
// 创建 URL 模式
const pattern = new URLPattern({ pathname: '/users/:id' });

// 匹配 URL
const result = pattern.exec('https://example.com/users/123');
console.log(result.pathname.groups.id); // '123'

// 复杂模式
const apiPattern = new URLPattern({
  pathname: '/api/:version/:resource/:id?',
  search: 'page=:page'
});

const match = apiPattern.exec('https://api.example.com/api/v1/users/42?page=2');
console.log(match.pathname.groups.version); // 'v1'
console.log(match.pathname.groups.resource); // 'users'
console.log(match.pathname.groups.id); // '42'
console.log(match.search.groups.page); // '2'

// 测试 URL 是否匹配
const blogPattern = new URLPattern({ pathname: '/blog/:slug' });
console.log(blogPattern.test('https://example.com/blog/hello-world')); // true
console.log(blogPattern.test('https://example.com/about')); // false
```

#### **权限模型改进**
从实验性转向更稳定状态，CLI 标志简化。

```bash
# 旧方式
node --experimental-permission --allow-fs-read=/app/data app.js

# 新方式（简化）
node --permission --allow-fs-read=/app/data app.js

# 限制文件系统访问
node --permission \
  --allow-fs-read=/app/data \
  --allow-fs-write=/app/logs \
  app.js

# 限制网络访问
node --permission --allow-net=api.example.com app.js

# 限制环境变量访问
node --permission --allow-env=NODE_ENV,PORT app.js

# 禁止子进程
node --permission --no-allow-child-process app.js
```

#### **测试运行器增强**
自动等待子测试完成，无需手动 `await` 测试 Promise。

```javascript
const { describe, it, test } = require('node:test');
const assert = require('node:assert');

describe('User Service', () => {
  // 不再需要手动 await
  it('creates a user', () => {
    const user = createUser({ name: 'John' });
    assert.strictEqual(user.name, 'John');
  });

  // 子测试自动等待
  describe('validation', () => {
    it('validates email', async () => {
      const isValid = await validateEmail('test@example.com');
      assert.ok(isValid);
    });

    it('rejects invalid email', async () => {
      const isValid = await validateEmail('invalid');
      assert.strictEqual(isValid, false);
    });
  });
});

// 并行测试
test('parallel tests', async (t) => {
  // 子测试自动等待，无需手动 Promise.all
  await t.test('test 1', async () => {
    await delay(100);
    assert.ok(true);
  });

  await t.test('test 2', async () => {
    await delay(100);
    assert.ok(true);
  });
});
```

#### **Undici 7**
改进的 HTTP 客户端，支持更新的协议和更好的开箱即用性能。

```javascript
const { request, fetch } = require('undici');

// 使用 Undici 的 request
const { statusCode, headers, body } = await request('https://api.example.com/data');
console.log('Status:', statusCode);

// Undici 提供的高性能 fetch
const response = await fetch('https://api.example.com/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'John' })
});

const data = await response.json();

// HTTP/2 和 HTTP/3 支持
const { Pool } = require('undici');
const pool = new Pool('https://api.example.com', {
  connections: 10,
  pipelining: 1
});
```

#### **稳定的 SQLite 支持**
内置 SQLite 从实验性升级为稳定。

```javascript
import { DatabaseSync } from 'node:sqlite';

// 创建数据库
const db = new DatabaseSync(':memory:');

// 创建表（STRICT 模式）
db.exec(`
  CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    created_at INTEGER
  ) STRICT
`);

// 准备语句（防止 SQL 注入）
const insert = db.prepare('INSERT INTO users (name, email, created_at) VALUES (?, ?, ?)');

// 插入数据
insert.run('John Doe', 'john@example.com', Date.now());
insert.run('Jane Smith', 'jane@example.com', Date.now());

// 查询数据
const selectAll = db.prepare('SELECT * FROM users');
const users = selectAll.all();
console.log(users);

// 查询单行
const selectOne = db.prepare('SELECT * FROM users WHERE id = ?');
const user = selectOne.get(1);
console.log(user);

// 事务支持
db.exec('BEGIN');
try {
  insert.run('Alice', 'alice@example.com', Date.now());
  insert.run('Bob', 'bob@example.com', Date.now());
  db.exec('COMMIT');
} catch (err) {
  db.exec('ROLLBACK');
  console.error('Transaction failed:', err);
}

// 关闭数据库
db.close();
```

**注意**：内置 SQLite 适合轻量级应用、嵌入式数据库、开发和测试。生产环境的复杂应用仍建议使用 PostgreSQL、MySQL 等。

#### **Promise 版本标准包**
所有标准模块都提供 Promise-based API。

```javascript
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as crypto from 'node:crypto/promises';

// 顶层 await（ESM 中）
const content = await fs.readFile('package.json', 'utf-8');
const pkg = JSON.parse(content);

// 文件操作
await fs.writeFile('output.txt', 'Hello World');
await fs.mkdir('new-dir', { recursive: true });
await fs.copyFile('source.txt', 'dest.txt');

// 加密操作
const key = await crypto.generateKey('hmac', { length: 256 });
const hash = await crypto.subtle.digest('SHA-256', Buffer.from('data'));
```

#### **内置调试器增强**
与 Chrome DevTools 更深度集成。

```bash
# 启动调试器
node --inspect-brk app.js

# 自定义调试端口
node --inspect-brk=9229 app.js

# 在 Chrome 中打开 chrome://inspect
# 或访问 http://localhost:9229/json/list 获取调试信息
```

```javascript
// 程序中触发断点
debugger;

// 条件断点
function processData(data) {
  if (data.length > 1000) {
    debugger; // 仅在数据量大时暂停
  }
  // 处理数据
}
```

## 总结

Node.js 从服务器端 JavaScript 运行时发展到全栈开发平台，经历了巨大的变化：

- **早期（0.x-v6）**：奠定基础，ES6 支持，npm 生态建立
- **v8-v10**：async/await、HTTP/2、ESM 实验支持
- **v12-v14**：Worker Threads、诊断工具、可选链
- **v16-v18**：Web 标准 API（Fetch、Crypto）、测试运行器
- **v20-v23**：权限模型、WebSocket、SQLite、性能优化
- **v24**：TypeScript 原生支持、.env 文件、稳定的 SQLite、权限模型改进

重点关注的版本：
- **Node.js 18 LTS**（已 EOL，2025年4月30日）：Fetch API、测试运行器、现代化的 Web API 支持
- **Node.js 20 LTS**：权限模型、稳定的测试工具、性能改进
- **Node.js 22 LTS**：WebSocket 稳定、require() ESM 支持
- **Node.js 24 Current**（2025年10月将成为 LTS）：TypeScript 支持、.env 文件、稳定的 SQLite、URLPattern API

推荐使用 LTS 版本进行生产部署，Current 版本用于体验最新特性。Node.js 18 已停止支持，建议立即升级到 Node.js 20 或更高版本。

## 参考资料
- [Node.js 官方文档](https://nodejs.org/en/docs/)
- [Node.js Release Schedule](https://nodejs.org/en/about/releases/)
- [Node.js GitHub](https://github.com/nodejs/node)
- [Node.js Changelog](https://github.com/nodejs/node/blob/main/CHANGELOG.md)
- [V8 Blog](https://v8.dev/blog)

**祝你变得更强!**
