---
title: CSS工程化-性能优化
date: 2019-11-21 14:00:00
permalink: /pages/css-performance/
categories: 
  - 前端
  - HTML & CSS
tags: 
  - CSS
  - 性能优化
  - 工程化
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

CSS性能优化是提升Web应用加载速度和用户体验的关键环节。优化得当的CSS不仅能加快页面渲染，还能减少资源消耗，提升整体性能。

本文将深入介绍CSS性能优化的各个方面，包括关键CSS、代码分割、压缩、避免重排重绘、选择器优化等，帮助你构建高性能的Web应用。

<!-- more -->

## 一、CSS加载性能优化

### 1.1 关键CSS（Critical CSS）

关键CSS是指首屏渲染所需的最小CSS集合，内联到HTML中可以消除渲染阻塞。

**什么是关键CSS**：

```html
<!DOCTYPE html>
<html>
<head>
  <!-- 内联关键CSS -->
  <style>
    /* 首屏必需的样式 */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    
    .header {
      background: #333;
      color: white;
      padding: 20px;
    }
    
    .hero {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
  
  <!-- 异步加载非关键CSS -->
  <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="styles.css"></noscript>
</head>
<body>
  <!-- 首屏内容 -->
</body>
</html>
```

**提取关键CSS的方法**：

1. **手动提取**：识别首屏样式并内联
2. **自动化工具**：
   - [Critical](https://github.com/addyosmani/critical)
   - [Critters](https://github.com/GoogleChromeLabs/critters)
   - [PurgeCSS](https://purgecss.com/)

```javascript
// 使用Critical提取关键CSS
const critical = require('critical');

critical.generate({
  inline: true,
  base: 'dist/',
  src: 'index.html',
  dest: 'index-critical.html',
  width: 1300,
  height: 900,
  css: ['dist/styles.css']
});
```

**关键CSS最佳实践**：

```html
<!-- ✅ 推荐：内联关键CSS -->
<head>
  <style>
    /* 关键CSS < 14KB */
    .above-fold { /* 首屏样式 */ }
  </style>
  
  <!-- 异步加载其他CSS -->
  <link rel="preload" href="main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
</head>

<!-- ❌ 避免：所有CSS都阻塞渲染 -->
<head>
  <link rel="stylesheet" href="large-bundle.css">
</head>
```

### 1.2 CSS代码分割

将CSS按需拆分，减少首次加载体积。

**按路由分割**：

```javascript
// 使用Vite代码分割
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  build: {
    cssCodeSplit: true, // 启用CSS代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor-styles': ['normalize.css']
        }
      }
    }
  }
});

// 动态导入CSS
import('./home.css').then(() => {
  // CSS已加载
});
```

**按组件分割**：

```javascript
// Vue中按组件懒加载CSS
const HomePage = defineAsyncComponent(() => import('./HomePage.vue'));

// HomePage组件
import './HomePage.css';
export default {
  name: 'HomePage',
  template: '<div>Home</div>'
}
```

**媒体查询分割**：

```html
<!-- 按媒体查询拆分CSS -->
<link rel="stylesheet" href="base.css">
<link rel="stylesheet" href="mobile.css" media="(max-width: 767px)">
<link rel="stylesheet" href="desktop.css" media="(min-width: 768px)">
<link rel="stylesheet" href="print.css" media="print">
```

### 1.3 CSS压缩与优化

**压缩CSS**：

```bash
# 使用cssnano压缩
npm install cssnano --save-dev
```

```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('cssnano')({
      preset: ['default', {
        discardComments: {
          removeAll: true,
        },
        normalizeWhitespace: true,
        colormin: true,
        minifyFontValues: true,
        minifySelectors: true,
      }]
    })
  ]
};
```

**压缩效果对比**：

```css
/* 压缩前 (1000字节) */
.button {
  background-color: #667eea;
  padding-top: 10px;
  padding-right: 20px;
  padding-bottom: 10px;
  padding-left: 20px;
  border-radius: 4px;
}

/* 压缩后 (65字节) */
.button{background-color:#667eea;padding:10px 20px;border-radius:4px}
```

**移除未使用的CSS**：

```bash
# 使用PurgeCSS移除未使用的样式
npm install @fullhuman/postcss-purgecss --save-dev
```

```javascript
// postcss.config.js
const purgecss = require('@fullhuman/postcss-purgecss')({
  content: [
    './src/**/*.html',
    './src/**/*.jsx',
    './src/**/*.tsx',
  ],
  defaultExtractor: content => content.match(/[\w-/:]+(?<!:)/g) || [],
  safelist: ['html', 'body', /^is-/, /^has-/]
});

module.exports = {
  plugins: [
    ...process.env.NODE_ENV === 'production' ? [purgecss] : []
  ]
};
```

### 1.4 资源提示（Resource Hints）

**预加载（Preload）**：

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>

<!-- 预加载并应用CSS -->
<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
```

**预连接（Preconnect）**：

```html
<!-- 提前建立连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
```

**DNS预解析（DNS-Prefetch）**：

```html
<!-- 提前解析DNS -->
<link rel="dns-prefetch" href="https://cdn.example.com">
```

**预获取（Prefetch）**：

```html
<!-- 预获取下一页可能用到的资源 -->
<link rel="prefetch" href="next-page.css">
```

## 二、渲染性能优化

### 2.1 避免重排（Reflow）

重排是浏览器重新计算元素位置和几何属性的过程，成本高昂。

**触发重排的操作**：

```javascript
// ❌ 触发重排的操作
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

const height = element.offsetHeight; // 强制重排
const width = element.clientWidth;   // 强制重排

element.classList.add('active');
element.innerHTML = 'New Content';
```

**优化策略**：

```javascript
// ✅ 批量修改样式
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';

// 或使用类
element.className = 'new-styles';

// ✅ 缓存布局信息
const height = element.offsetHeight;
const width = element.clientWidth;
// 使用缓存的值，避免重复读取

// ✅ 使用transform代替位置属性
// ❌ 触发重排
element.style.left = '100px';

// ✅ 使用transform
element.style.transform = 'translateX(100px)';
```

**离线DOM操作**：

```javascript
// ✅ 使用DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
container.appendChild(fragment); // 只触发一次重排

// ✅ 克隆节点后修改
const clone = element.cloneNode(true);
clone.style.width = '100px';
clone.style.height = '100px';
element.parentNode.replaceChild(clone, element);

// ✅ 隐藏元素后修改
element.style.display = 'none';
// 进行大量修改
element.style.display = 'block';
```

### 2.2 避免重绘（Repaint）

重绘是更新元素外观时发生的过程，比重排成本低。

**触发重绘的属性**：

```css
/* 触发重绘的CSS属性 */
color
background
background-color
background-image
border-color
box-shadow
outline
visibility
```

**优化策略**：

```css
/* ✅ 使用transform和opacity（只触发合成） */
.element {
  /* ❌ 触发重绘 */
  background: red;
  
  /* ✅ 只触发合成 */
  transform: scale(1.1);
  opacity: 0.9;
}

/* ✅ 使用will-change提示浏览器 */
.animated {
  will-change: transform, opacity;
}

/* 动画结束后移除 */
.animated.done {
  will-change: auto;
}
```

### 2.3 GPU加速

利用GPU进行图层合成，提升渲染性能。

**触发GPU加速的属性**：

```css
/* 触发GPU加速（创建合成层） */
.accelerated {
  /* 3D transform */
  transform: translate3d(0, 0, 0);
  transform: translateZ(0);
  
  /* will-change */
  will-change: transform;
  
  /* opacity + animation */
  opacity: 0.99;
  
  /* filter */
  filter: blur(0);
  
  /* video、canvas、iframe */
}
```

**GPU加速最佳实践**：

```css
/* ✅ 动画使用transform和opacity */
@keyframes slideIn {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}

/* ❌ 避免动画触发重排的属性 */
@keyframes badAnimation {
  from {
    left: -100px; /* 触发重排 */
  }
  to {
    left: 0;
  }
}

/* ✅ 使用will-change优化 */
.hover-card {
  transition: transform 0.3s;
}

.hover-card:hover {
  will-change: transform;
  transform: scale(1.05);
}
```

**注意事项**：

```css
/* ❌ 避免过度使用will-change */
* {
  will-change: transform, opacity; /* 消耗大量内存 */
}

/* ✅ 只在需要时使用 */
.interactive-element:hover {
  will-change: transform;
}

.interactive-element {
  /* 动画结束后重置 */
  will-change: auto;
}
```

### 2.4 CSS动画性能

::: demo [vanilla]
```html
<html>
  <div class="animation-demo-e8g7b6">
    <div class="comparison-e8g7b6">
      <div class="box-e8g7b6 bad-animation-e8g7b6">
        <h4>❌ 低性能动画</h4>
        <p>使用left/top</p>
      </div>
      
      <div class="box-e8g7b6 good-animation-e8g7b6">
        <h4>✅ 高性能动画</h4>
        <p>使用transform</p>
      </div>
    </div>
  </div>
</html>
<style>
.animation-demo-e8g7b6 {
  padding: 20px;
}

.comparison-e8g7b6 {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
}

.box-e8g7b6 {
  background: white;
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  text-align: center;
}

.box-e8g7b6 h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
}

.box-e8g7b6 p {
  margin: 0;
  color: #7f8c8d;
  font-size: 14px;
}

/* ❌ 低性能：触发重排 */
.bad-animation-e8g7b6 {
  position: relative;
  animation: moveWithLayout-e8g7b6 2s ease-in-out infinite;
}

@keyframes moveWithLayout-e8g7b6 {
  0%, 100% { left: 0; }
  50% { left: 20px; }
}

/* ✅ 高性能：只触发合成 */
.good-animation-e8g7b6 {
  animation: moveWithTransform-e8g7b6 2s ease-in-out infinite;
  will-change: transform;
}

@keyframes moveWithTransform-e8g7b6 {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(20px); }
}
</style>
```
:::

## 三、选择器性能优化

### 3.1 选择器效率

**选择器性能排序（从快到慢）**：

```css
/* 1. ID选择器（最快） */
#header {}

/* 2. 类选择器 */
.button {}

/* 3. 标签选择器 */
div {}

/* 4. 相邻兄弟选择器 */
h1 + p {}

/* 5. 子选择器 */
ul > li {}

/* 6. 后代选择器 */
ul li {}

/* 7. 通配符选择器（最慢） */
* {}

/* 8. 属性选择器 */
[type="text"] {}

/* 9. 伪类选择器 */
a:hover {}
```

### 3.2 优化选择器

**避免过度限定**：

```css
/* ❌ 过度限定 */
div.container {}
ul.nav li.nav-item {}
div#header {}

/* ✅ 简化选择器 */
.container {}
.nav-item {}
#header {}
```

**避免深层嵌套**：

```css
/* ❌ 深层嵌套 */
.page .container .sidebar .widget .title {}

/* ✅ 扁平化 */
.widget-title {}
```

**避免标签限定类**：

```css
/* ❌ 标签限定 */
div.error {}
p.intro {}

/* ✅ 只用类 */
.error {}
.intro {}
```

**避免通配符**：

```css
/* ❌ 全局通配符 */
* {
  margin: 0;
  padding: 0;
}

/* ✅ 针对性重置 */
body, h1, h2, h3, p {
  margin: 0;
  padding: 0;
}
```

### 3.3 现代选择器性能

**注意:has()性能**：

```css
/* :has()可能影响性能，谨慎使用 */
/* ⚠️ 可能较慢 */
.container:has(.error) {
  border-color: red;
}

/* ✅ 优先使用类 */
.container.has-error {
  border-color: red;
}
```

**合理使用:is()和:where()**：

```css
/* ✅ 简化选择器 */
:is(h1, h2, h3) a {
  color: blue;
}

/* 等同于 */
h1 a, h2 a, h3 a {
  color: blue;
}
```

## 四、CSS架构性能

### 4.1 减少样式重复

**使用CSS变量**：

```css
/* ❌ 硬编码重复 */
.button-primary {
  background: #667eea;
  border-color: #667eea;
}

.link-primary {
  color: #667eea;
}

.badge-primary {
  background: #667eea;
}

/* ✅ 使用变量 */
:root {
  --color-primary: #667eea;
}

.button-primary {
  background: var(--color-primary);
  border-color: var(--color-primary);
}

.link-primary {
  color: var(--color-primary);
}

.badge-primary {
  background: var(--color-primary);
}
```

**复用样式模式**：

```css
/* ✅ 工具类方法 */
.flex { display: flex; }
.flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.p-2 { padding: 16px; }
```

### 4.2 避免@import

```css
/* ❌ @import会阻塞并行下载 */
@import url('reset.css');
@import url('typography.css');
@import url('layout.css');

/* ✅ 使用link标签 */
```

```html
<link rel="stylesheet" href="reset.css">
<link rel="stylesheet" href="typography.css">
<link rel="stylesheet" href="layout.css">
```

### 4.3 合并与拆分平衡

**HTTP/1.1时代**：

```html
<!-- ✅ 合并CSS减少请求 -->
<link rel="stylesheet" href="bundle.css">
```

**HTTP/2时代**：

```html
<!-- ✅ 可以拆分，利用多路复用 -->
<link rel="stylesheet" href="critical.css">
<link rel="stylesheet" href="layout.css">
<link rel="stylesheet" href="components.css">
```

## 五、字体性能优化

### 5.1 字体加载策略

**font-display属性**：

```css
@font-face {
  font-family: 'CustomFont';
  src: url('font.woff2') format('woff2');
  
  /* font-display策略 */
  font-display: swap;
  /* auto: 浏览器默认行为 */
  /* block: 短时间阻塞，然后无限期显示 */
  /* swap: 立即显示回退字体，字体加载后替换 */
  /* fallback: 短时间阻塞，有限时间内替换 */
  /* optional: 短时间阻塞，之后由浏览器决定 */
}
```

**策略对比**：

```css
/* ✅ 推荐：快速显示文本 */
font-display: swap;

/* ⚠️ 可能导致闪烁 */
font-display: block;

/* ✅ 平衡性能和体验 */
font-display: fallback;

/* ✅ 慢速网络下不加载字体 */
font-display: optional;
```

### 5.2 字体优化

**使用现代字体格式**：

```css
@font-face {
  font-family: 'MyFont';
  src: url('font.woff2') format('woff2'),     /* 现代浏览器 */
       url('font.woff') format('woff'),       /* 兼容 */
       url('font.ttf') format('truetype');    /* 后备 */
}
```

**子集化字体**：

```css
/* 只包含需要的字符 */
@font-face {
  font-family: 'MyFont';
  src: url('font-subset.woff2') format('woff2');
  unicode-range: U+0020-007F; /* 只包含基本拉丁字符 */
}
```

**预加载关键字体**：

```html
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
```

## 六、工具与测量

### 6.1 性能分析工具

**Chrome DevTools**：

1. **Coverage工具**：查看未使用的CSS
   - 打开DevTools → More tools → Coverage
   - 录制并分析未使用的代码

2. **Performance面板**：
   - 记录页面加载
   - 分析渲染性能
   - 识别长任务和重排

3. **Lighthouse**：
   - 综合性能评分
   - 具体优化建议

**命令行工具**：

```bash
# 分析CSS大小
npm install -g cssstats
cssstats styles.css

# 检查未使用的CSS
npm install -g purgecss
purgecss --css styles.css --content index.html

# CSS复杂度分析
npm install -g stylestats
stylestats styles.css
```

### 6.2 性能监控

**关键指标**：

```javascript
// 使用Performance API测量
const perfData = performance.getEntriesByType('navigation')[0];

console.log('CSS加载时间:', 
  perfData.responseEnd - perfData.fetchStart
);

// CSS阻塞时间
const cssLinks = document.querySelectorAll('link[rel="stylesheet"]');
cssLinks.forEach(link => {
  const entry = performance.getEntriesByName(link.href)[0];
  console.log('CSS阻塞时长:', entry.duration);
});

// 首次内容绘制（FCP）
const paintEntries = performance.getEntriesByType('paint');
const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint');
console.log('FCP:', fcp.startTime);
```

**性能预算**：

```javascript
// vite.config.js - 使用rollup-plugin-visualizer
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    vue(),
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    })
  ],
  build: {
    chunkSizeWarningLimit: 244, // CSS文件不超过244KB
    rollupOptions: {
      output: {
        manualChunks(id) {
          // 根据需要拆分chunk
        }
      }
    }
  }
});
```

## 七、实战优化案例

### 7.1 优化前后对比

**优化前**：

```css
/* 文件大小: 500KB */
/* 未使用的CSS: 60% */
/* 选择器复杂度高 */

body div.container div.content div.sidebar ul.menu li.menu-item a.menu-link {
  color: #667eea;
  text-decoration: none;
  padding-top: 10px;
  padding-right: 15px;
  padding-bottom: 10px;
  padding-left: 15px;
}

.button {
  background-color: #667eea;
  background-image: linear-gradient(135deg, #667eea, #764ba2);
}

/* 大量重复样式 */
.card-1 { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
.card-2 { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
.card-3 { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
```

**优化后**：

```css
/* 文件大小: 50KB (压缩后) */
/* 未使用的CSS: 0% */
/* 选择器简化 */

:root {
  --color-primary: #667eea;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.1);
}

.menu-link {
  color: var(--color-primary);
  text-decoration: none;
  padding: 10px 15px;
}

.button {
  background: linear-gradient(135deg, #667eea, #764ba2);
}

/* 工具类复用 */
.shadow-sm { box-shadow: var(--shadow-sm); }
```

**性能提升**：

```
指标               优化前    优化后    提升
-------------------------------------------
CSS文件大小        500KB     50KB      90%
首次内容绘制(FCP)  2.5s      0.8s      68%
最大内容绘制(LCP)  4.2s      1.5s      64%
总阻塞时间(TBT)    850ms     120ms     86%
Lighthouse分数     45        92        +47
```

### 7.2 完整优化流程

**第一步：审计现状**：

```bash
# 运行Lighthouse
lighthouse https://example.com --view

# 分析CSS覆盖率
# DevTools → Coverage → 记录

# 检查关键渲染路径
# DevTools → Performance → 记录页面加载
```

**第二步：提取关键CSS**：

```javascript
// 使用Critical
const critical = require('critical');

critical.generate({
  inline: true,
  base: 'dist/',
  src: 'index.html',
  dest: 'index-critical.html',
  width: 1300,
  height: 900
});
```

**第三步：移除未使用CSS**：

```javascript
// PurgeCSS配置
module.exports = {
  content: ['./src/**/*.html', './src/**/*.js'],
  css: ['./src/**/*.css'],
  defaultExtractor: content => content.match(/[\w-/:]+(?<!:)/g) || []
};
```

**第四步：压缩优化**：

```javascript
// PostCSS配置
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano')({
      preset: 'default'
    })
  ]
};
```

**第五步：异步加载**：

```html
<!-- 关键CSS内联 -->
<style>
  /* 关键CSS */
</style>

<!-- 异步加载其他CSS -->
<link rel="preload" href="main.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="main.css"></noscript>
```

## 八、最佳实践总结

### 8.1 加载性能清单

✅ **必做**：
- [ ] 提取并内联关键CSS（< 14KB）
- [ ] 异步加载非关键CSS
- [ ] 移除未使用的CSS
- [ ] 压缩CSS文件
- [ ] 使用现代CSS格式
- [ ] 启用Gzip/Brotli压缩

✅ **推荐**：
- [ ] 使用CSS代码分割
- [ ] 预加载关键资源
- [ ] 使用CDN分发
- [ ] 设置合理的缓存策略
- [ ] 优化字体加载

### 8.2 渲染性能清单

✅ **必做**：
- [ ] 避免使用触发重排的属性做动画
- [ ] 使用transform和opacity做动画
- [ ] 批量修改DOM
- [ ] 避免强制同步布局

✅ **推荐**：
- [ ] 使用will-change优化动画
- [ ] 启用GPU加速
- [ ] 减少选择器复杂度
- [ ] 使用CSS containment

### 8.3 维护性能清单

✅ **必做**：
- [ ] 设置性能预算
- [ ] 定期审计CSS
- [ ] 监控性能指标
- [ ] 使用自动化工具

✅ **推荐**：
- [ ] 建立性能监控体系
- [ ] 在CI/CD中集成性能检查
- [ ] 团队培训和规范

### 8.4 性能优化金字塔

```
             优先级
               ↑
         [ 关键CSS内联 ]
      [ 移除未使用的CSS ]
    [ 压缩和代码分割 ]
  [ 优化选择器和架构 ]
[ 字体和图片优化 ]
[ 高级优化技巧 ]
```

## 九、总结

CSS性能优化是一个持续的过程，需要从多个维度进行：

**加载性能**：
- 关键CSS内联，减少阻塞
- 代码分割，按需加载
- 压缩优化，减小体积
- 移除冗余，提高效率

**渲染性能**：
- 避免重排重绘
- 使用GPU加速
- 优化动画性能
- 简化选择器

**工程化**：
- 自动化工具
- 性能监控
- 持续优化
- 团队规范

**关键原则**：
1. 测量优先：先测量再优化
2. 循序渐进：从影响大的开始
3. 持续监控：建立性能指标
4. 平衡取舍：性能与开发效率

通过系统化的性能优化，可以显著提升Web应用的加载速度和用户体验。记住，性能优化永无止境，但要把精力投入到最有价值的地方。

**祝你变得更强!**
