
阮一峰老师的写的[Bash 脚本教程](https://wangdoc.com/bash/)已经非常完善了，这里是我做的一个笔记。

<!-- more -->

## 历史
Shell是一个命令行环境，也是一个命令解释器。  
常用的Shell有：
- Bourne Shell（sh）
- Bourne Again shell（bash）
- Z Shell（zsh）
- Friendly Interactive Shell（fish）

bash是最常用的Shell，主要讲解它。

## 基本语法
echo命令：
- 支持多行，使用双引号
- -n 取消末尾回车符
- -e 解释执行，默认的双引号或单引号会把特殊字符编程普通字符，比如\n

命令格式：
- 组成：命令+空格+参数
- 分号表示结束
- &&表示前命令成功，后命令才执行；||&&表示前命令失败，后命令才执行

快捷键：
- Ctrl + L：清除屏幕并将当前行移到页面顶部。
- Ctrl + C：中止当前正在执行的命令。
- Shift + PageUp：向上滚动。
- Shift + PageDown：向下滚动。
- Ctrl + U：从光标位置删除到行首。
- Ctrl + K：从光标位置删除到行尾。
- Ctrl + W：删除光标位置前一个单词。
- Ctrl + D：关闭 Shell 会话。
- ↑，↓：浏览已执行命令的历史记录。

## 模式扩展
波浪线~：
- 自动扩展成当前用户的主目录
- ~user表示扩展成用户user的主目录
- ~+会扩展成当前所在的目录，等同于pwd命令

字符扩展，正则的简易版本：
- ?代表单个字符
- *代表多个字符
- [...]多字符
- [start-end]范围
- {...}序列
- {start..end} 连续序列
- `shopt -s extglob`开启之后，可以控制模式匹配的次数
  - ?(pattern-list)：模式匹配零次或一次。比如 ls abc?(.)txt
  - *(pattern-list)：模式匹配零次或多次。
  - +(pattern-list)：模式匹配一次或多次。
  - @(pattern-list)：只匹配一次模式。
  - !(pattern-list)：匹配给定模式以外的任何内容。

字符类扩展：
- [[:alnum:]]：匹配任意英文字母与数字
- [[:alpha:]]：匹配任意英文字母
- [[:blank:]]：空格和 Tab 键。
- [[:cntrl:]]：ASCII 码 0-31 的不可打印字符。
- [[:digit:]]：匹配任意数字 0-9。
- [[:graph:]]：A-Z、a-z、0-9 和标点符号。
- [[:lower:]]：匹配任意小写字母 a-z。
- [[:print:]]：ASCII 码 32-127 的可打印字符。
- [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。
- [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。
- [[:upper:]]：匹配任意大写字母 A-Z。
- [[:xdigit:]]：16进制字符（A-F、a-f、0-9）

变量与命令扩展：
- $开头视为变量，也可以${}表示
- $(...)扩展为命令运行，也可以放在反引号之中（古老写法）

## 引号和转义
转义：
- echo $date输出的变量，echo \$date,输出的字符串
- 反斜杠还可以表示一些不可打印的字符。注意使用-e
  - \a：响铃
  - \b：退格
  - \n：换行
  - \r：回车
  - \t：制表符
- 反斜杠还可以把换行符转义为特殊字符，从而实现一行命令写为多行

引号：
- 单引号会把所有特殊字符都变成普通字符。比如echo '$SHELL' = $SHELL
- 双引号同单引号，但美元符号（$）、反引号（`）和反斜杠（\）除外，这三个符合还是会被扩展。比如echo "$SHELL" = /bin/bash
- 双引号会转义换行符，用来实现多行文本
- 双引号会保留输出格式，比如echo "$(cal)"，会显示一个格式化的日历

here文档：
```shell
<< token
text
token
```
一般配合tee或cat命令使用。
还有一个变体，使用三个小于号（<<<）表示字符串：cat <<< 'hi there'

## 变量
变量操作：
- evn或printenv显示所有环境变量
- set显示所有变量和bash函数
- 创建变量：variable=value
- 变量本身也是变量，可以使用${!varname}的语法将其展开
- unset用来删除变量
- export命令用来向子 Shell 输出变量
- 一些特殊变量
  - $? 上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功
  - $$ 当前 Shell 的进程 ID
  - $_ 上一个命令的最后一个参数
  - $! 最近一个后台执行的异步命令的进程 ID
  - $0 当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）
  - $- 当前 Shell 的启动参数
  - $# 脚本的参数数量
  - $@ 脚本的参数值
- 变量的默认值
  - ${varname:-word} 如果变量varname存在且不为空，则返回它的值，否则返回word
  - ${varname:=word} 如果变量varname存在且不为空，则返回它的值，否则将它设为word，并且返回word
  - ${varname:+word} 如果变量名存在且不为空，则返回word，否则返回空值
  - ${varname:?message} 如果变量varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行
  - 四种语法如果用在脚本中，变量名的部分可以用数字1到9，表示脚本的参数
- declare声明一些特殊类型的变量
- let命令可以直接执行算术表达式

## 字符串操作
字符串操作：
- ${#varname} 取长度
- ${varname:offset:length} substring方法
- ${variable#pattern} 头部模式匹配，删除非贪婪匹配到的部分，返回剩余部分。
- ${variable##pattern} 头部模式匹配，删除贪婪匹配（最长匹配）到的部分，返回剩余部分。
- ${variable/#pattern/string} 头部模式的替换
- ${variable%pattern} 尾部模式匹配，非贪婪
- ${variable%%pattern} 尾部模式匹配，贪婪
- ${variable/%pattern/string} 尾部模式的替换
- ${variable/pattern/string} 全局替换，但只替换第一个匹配
- ${variable//pattern/string} 全局替换，替换全部出现的匹配
- ${varname^^} 转为大写
- ${varname,,} 转为小写

## 算术运算
算术运算：
- ((foo = 5 + 5))，只支持计算整数
- $[...] 是以前的写法，不建议使用
- echo $((2 + 2))
- 支持的算术运算符：+ - * / % ** ++ --
- 支持的位运算符：<< >> & | ~ ^
- 支持的逻辑运算符：> < >= <= == != && || ! expr1?expr2:expr3

## 脚本入门
Shebang行：
- 也就是第一行，用于指定解释器。一般为 !#/bin/sh 或 !#/bin/bash
- #!/usr/bin/env NAME，表示查找解释器的目录。比如#!/usr/bin/env node是指定node解释器，但node必须在环境变量中才行

脚本参数：
- 对于 script.sh word1 word2 word3 来说，脚本内部有一些特殊变量来引用参数
  - $0：脚本文件名，即script.sh。
  - $1~$9：对应脚本的第一个参数到第九个参数。
  - $#：参数的总数。
  - $@：全部的参数，参数之间使用空格分隔。
  - $*：全部的参数，参数之间使用变量$IFS值的第一个字符分隔，默认为空格，但是可以自定义。
- shift用来改变脚本参数，每次执行都会移除脚本当前的第一个参数（$1），使得后面的参数向前一位，即$2变成$1、$3变成$2、$4变成$3，以此类推
- getops取出脚本所有的带有前置连词线（-）的参数。示例：
```shell
while getopts 'lha:' OPTION; do
  case "$OPTION" in
    l)
      echo "linuxconfig"
      ;;

    h)
      echo "h stands for h"
      ;;

    a)
      avalue="$OPTARG"
      echo "The value provided is $OPTARG"
      ;;
    ?)
      echo "script usage: $(basename $0) [-l] [-h] [-a somevalue]" >&2
      exit 1
      ;;
  esac
done
shift "$(($OPTIND - 1))"
```
$OPTARG保存的就是参数值
- 参数终止符 --,用来转义，把-变为普通参数。比如`cat -- -f``cat -- --f`

指令：
- exit：退出当前脚本
- source：重新加载一个配置文件，也可以在脚本中加载一个外部库。简写是`.`
- alias：别名

read指令：
将用户的输入存入一个变量
```shell
# 读取输入到一个变量
read text

# 读取输入到多个变量
read fn ln

# 不跟变量，使用$REPLY来取值
read 
echo "REPLY = '$REPLY'"

# 读取文件内容，按行
filename='/etc/hosts'
while read myline
do
  echo "$myline"
done < $filename
```
参数：
- -t：设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行
- -p：指定用户输入的提示信息
- -a：把用户的输入赋值给一个数组，从零号位置开始
- -n：指定只读取若干个字符作为变量值，而不是整行读取
- -d：delimiter：定义字符串delimiter的第一个字符作为用户输入的结束，而不是一个换行符
- -r：raw 模式，表示不把用户输入的反斜杠字符解释为转义字符
- -s：使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息
- -u fd：使用文件描述符fd作为输入

IFS用来指定分割标识，默认是空格
```shell
#!/bin/bash
# read-ifs: read fields from a file

FILE=/etc/passwd

read -p "Enter a username > " user_name
file_info="$(grep "^$user_name:" $FILE)"

if [ -n "$file_info" ]; then
  IFS=":" read user pw uid gid name home shell <<< "$file_info"
  echo "User = '$user'"
  echo "UID = '$uid'"
  echo "GID = '$gid'"
  echo "Full Name = '$name'"
  echo "Home Dir. = '$home'"
  echo "Shell = '$shell'"
else
  echo "No such user '$user_name'" >&2
  exit 1
fi
```

