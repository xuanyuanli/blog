---
title: Reactor 3指南
date: 2023-11-21 20:43:26
permalink: /pages/c97521/
categories:
  - 后端
  - Spring
  - 核心
tags:
  - 
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---


<!-- more -->

参照官网教程进行整理：https://projectreactor.io/docs/core/release/reference/gettingStarted.html


以下是 Reactor 如何体现响应式编程概念的详细说明：

##### 1. **函数式编程风格**
Reactor 采用了函数式编程风格，通过声明式的方式定义数据流的处理逻辑。核心操作符（如 `map`、`filter`、`flatMap` 等）允许开发者以链式调用的方式组合操作。

- **示例**：
  ```java
  Flux.just("apple", "banana", "orange")
      .filter(fruit -> fruit.length() > 5)
      .map(String::toUpperCase)
      .subscribe(System.out::println);
  ```
  这里，`Flux` 是一个数据流，`filter` 和 `map` 是函数式操作符，`subscribe` 是订阅操作。

- **特点**：
    - 不可变性：操作符不会修改原始数据流，而是返回新的流。
    - 链式调用：通过方法链组合操作，代码简洁易读。

##### 2. **观察者模式**
Reactor 基于观察者模式实现了发布-订阅模型。`Flux` 和 `Mono` 是发布者（Publisher），`subscribe` 是订阅者（Subscriber）。

- **核心组件**：
    - **Publisher**：数据流的源头，如 `Flux` 和 `Mono`。
    - **Subscriber**：订阅数据流并处理数据。
    - **Subscription**：订阅关系，用于控制数据流的请求和取消。

- **示例**：
  ```java
  Flux.range(1, 10)
      .subscribe(
          value -> System.out.println("Received: " + value), // 处理数据
          error -> System.err.println("Error: " + error),    // 处理错误
          () -> System.out.println("Completed")              // 处理完成
      );
  ```

- **特点**：
    - 异步非阻塞：数据流在订阅时才开始执行。
    - 事件驱动：通过回调函数处理数据、错误和完成事件。

##### 3. **错误处理和容错**
Reactor 提供了丰富的错误处理机制，确保数据流在发生错误时能够优雅地恢复或终止。

- **错误处理操作符**：
    - `onErrorReturn`：发生错误时返回一个默认值。
    - `onErrorResume`：发生错误时切换到另一个流。
    - `onErrorMap`：将错误转换为另一种类型。
    - `retry`：重试操作。

- **示例**：
  ```java
  Flux.just(1, 2, 0, 4)
      .map(i -> 10 / i)
      .onErrorResume(e -> {
          System.err.println("Error: " + e.getMessage());
          return Flux.just(-1);
      })
      .subscribe(System.out::println);
  ```

- **特点**：
    - 容错性强：通过操作符灵活处理错误。
    - 可恢复性：支持重试和回退逻辑。

##### 4. **拆分和组合**
Reactor 提供了丰富的操作符来拆分和组合数据流，支持复杂的流处理逻辑。

- **拆分操作**：
    - `flatMap`：将每个元素映射为一个流，并将所有流合并。
    - `groupBy`：按条件将流拆分为多个子流。

- **组合操作**：
    - `merge`：合并多个流。
    - `zip`：将多个流的元素按顺序组合。
    - `concat`：按顺序连接多个流。

- **示例**：
  ```java
  Flux<Integer> flux1 = Flux.range(1, 3);
  Flux<Integer> flux2 = Flux.range(4, 3);
  Flux.zip(flux1, flux2, (a, b) -> a + b)
      .subscribe(System.out::println);
  ```

- **特点**：
    - 灵活性：支持多种流操作。
    - 可组合性：通过操作符构建复杂的数据流处理逻辑。

##### 5. **背压策略**
Reactor 实现了 **Reactive Streams** 的背压（Backpressure）机制，允许消费者控制数据流的速度，避免生产者过快导致消费者过载。

- **背压策略**：
    - `onBackpressureBuffer`：将多余的数据缓存在缓冲区。
    - `onBackpressureDrop`：丢弃无法处理的数据。
    - `onBackpressureLatest`：只保留最新的数据。

- **示例**：
  ```java
  Flux.range(1, 100)
      .onBackpressureBuffer(10) // 缓冲区大小为 10
      .subscribe(System.out::println);
  ```

- **特点**：
    - 流量控制：消费者可以动态调整数据流的速度。
    - 资源保护：避免内存溢出和系统过载。

##### 6. **异步和并发**
Reactor 支持异步和非阻塞的操作，能够高效地利用系统资源。

- **异步操作**：
    - `publishOn`：指定后续操作在指定的调度器上执行。
    - `subscribeOn`：指定订阅操作在指定的调度器上执行。

- **示例**：
  ```java
  Flux.range(1, 10)
      .publishOn(Schedulers.parallel()) // 在并行线程中执行
      .subscribe(System.out::println);
  ```

- **特点**：
    - 高性能：充分利用多核 CPU 和异步 I/O。
    - 灵活性：支持多种调度策略（如并行、单线程、弹性线程池等）。



在 Spring 的 Reactor 中，控制执行线程是通过 **调度器（Scheduler）** 来实现的。Reactor 提供了多种调度器，允许开发者灵活地控制数据流的执行线程，从而优化性能和资源利用率。以下是控制执行线程的详细方法：

---

### 1. **调度器（Scheduler）**
Reactor 提供了多种内置的调度器，用于指定操作在哪个线程或线程池中执行。

- **常用调度器**：
    - `Schedulers.immediate()`：在当前线程执行。
    - `Schedulers.single()`：在单个共享线程中执行。
    - `Schedulers.parallel()`：在并行线程池中执行，适合 CPU 密集型任务。
    - `Schedulers.elastic()`：在弹性线程池中执行，适合 I/O 密集型任务。
    - `Schedulers.boundedElastic()`：在有限的弹性线程池中执行，避免资源耗尽。
    - `Schedulers.fromExecutorService(ExecutorService)`：从自定义的线程池创建调度器。

---

### 2. **控制执行线程的方法**
Reactor 提供了两个核心操作符来控制执行线程：`publishOn` 和 `subscribeOn`。

#### **`publishOn`**
`publishOn` 用于指定**后续操作**的执行线程。它会影响操作符链中位于它之后的所有操作。

- **示例**：
  ```java
  Flux.range(1, 10)
      .map(i -> {
          System.out.println("Map in thread: " + Thread.currentThread().getName());
          return i * 2;
      })
      .publishOn(Schedulers.parallel()) // 切换到并行线程池
      .subscribe(i -> System.out.println("Subscribed in thread: " + Thread.currentThread().getName()));
  ```
  输出：
  ```
  Map in thread: main
  Subscribed in thread: parallel-1
  ```

- **特点**：
    - 只影响后续操作。
    - 可以多次使用，每次都会切换线程。

#### **`subscribeOn`**
`subscribeOn` 用于指定**整个数据流**的订阅执行线程。它会影响从数据源到订阅的整个操作链。

- **示例**：
  ```java
  Flux.range(1, 10)
      .map(i -> {
          System.out.println("Map in thread: " + Thread.currentThread().getName());
          return i * 2;
      })
      .subscribeOn(Schedulers.parallel()) // 整个流在并行线程池中执行
      .subscribe(i -> System.out.println("Subscribed in thread: " + Thread.currentThread().getName()));
  ```
  输出：
  ```
  Map in thread: parallel-1
  Subscribed in thread: parallel-1
  ```

- **特点**：
    - 影响整个操作链。
    - 只能使用一次，多次调用只有第一次生效。

---

### 3. **结合 `publishOn` 和 `subscribeOn`**
`publishOn` 和 `subscribeOn` 可以结合使用，以实现更细粒度的线程控制。

- **示例**：
  ```java
  Flux.range(1, 10)
      .subscribeOn(Schedulers.single()) // 整个流在单一线程中执行
      .map(i -> {
          System.out.println("Map in thread: " + Thread.currentThread().getName());
          return i * 2;
      })
      .publishOn(Schedulers.parallel()) // 切换到并行线程池
      .subscribe(i -> System.out.println("Subscribed in thread: " + Thread.currentThread().getName()));
  ```
  输出：
  ```
  Map in thread: single-1
  Subscribed in thread: parallel-1
  ```

---

### 4. **自定义调度器**
如果需要更灵活的线程控制，可以使用自定义的线程池创建调度器。

- **示例**：
  ```java
  ExecutorService customExecutor = Executors.newFixedThreadPool(4);
  Scheduler customScheduler = Schedulers.fromExecutorService(customExecutor);

  Flux.range(1, 10)
      .publishOn(customScheduler)
      .subscribe(i -> System.out.println("Subscribed in thread: " + Thread.currentThread().getName()));

  customExecutor.shutdown(); // 关闭线程池
  ```

---

### 5. **线程切换的最佳实践**
- **CPU 密集型任务**：使用 `Schedulers.parallel()`。
- **I/O 密集型任务**：使用 `Schedulers.boundedElastic()`。
- **避免阻塞主线程**：使用 `subscribeOn` 将耗时操作切换到其他线程。
- **细粒度控制**：使用 `publishOn` 在操作链中多次切换线程。

---

### 6. **总结**
在 Reactor 中，控制执行线程的核心方法如下：
- 使用 `publishOn` 切换后续操作的执行线程。
- 使用 `subscribeOn` 切换整个数据流的执行线程。
- 结合 `publishOn` 和 `subscribeOn` 实现更细粒度的线程控制。
- 使用内置调度器或自定义调度器优化线程资源。

通过合理使用调度器和线程控制操作符，可以充分发挥 Reactor 的异步非阻塞特性，构建高性能的响应式应用程序。
