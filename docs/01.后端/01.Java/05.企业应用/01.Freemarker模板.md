---
title: Freemarker模板
date: 2022-09-20 22:06:13
permalink: /pages/1b9f29/
categories:
  - 后端
  - Java
  - 企业应用
tags:
  - Freemarker
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

Freemarker是一个用Java编写的开源模板引擎，适用于动态web页面生成以及各种文本输出。最早发布于2000年，经过多年的发展，Freemarker已成为Java领域广泛使用的模板引擎之一。

<!-- more -->

## Freemarker模板简介

### 1 主要特点与优势

- **易学易用**：Freemarker的语法简洁明了，学习成本较低。
- **性能高效**：Freemarker具有出色的性能表现，模板渲染速度快。
- **功能丰富**：Freemarker提供了丰富的指令和内置函数，支持条件判断、循环遍历等复杂逻辑。
- **灵活可扩展**：Freemarker可以轻松地与Java代码集成，可以自定义函数和指令。
- **与前端技术良好兼容**：Freemarker可以与HTML、CSS、JavaScript等前端技术无缝结合，帮助开发者快速搭建Web应用。

### 2 应用场景

Freemarker模板引擎广泛应用于各种Java Web应用，如电商平台、企业官网、个人博客、社交网站等。除此之外，Freemarker还可用于生成代码、文档、邮件模板等其他文本输出场景。

## Freemarker模板的基本语法

### 1 模板文件结构

Freemarker模板文件以`.ftl`或`.ftlh`（用于HTML）和`.ftlx`（用于XML）为扩展名。模板文件可以包含静态文本、表达式、指令等元素，用于生成动态内容。

### 2 数据模型

数据模型是模板引擎从Java代码中获取的数据，通常采用键值对（key-value）的形式存储。Freemarker可以访问数据模型中的值，以生成动态内容。

### 3 注释

Freemarker支持单行和多行注释。注释内容不会出现在最终生成的文本中。

```markdown
<#-- 单行注释 -->

<#--
  多行注释
-->
```

### 4 变量

Freemarker支持变量，可以从数据模型中获取值并在模板中使用。

```markdown
${变量名}
```

### 5 字符串

Freemarker支持字符串，可以使用单引号或双引号包围文本。

```markdown
'单引号字符串'
"双引号字符串"
```

### 6 数字

Freemarker支持整数和浮点数。

```markdown
123
3.14
```

### 7 布尔值

Freemarker支持布尔值`true`和`false`。

```markdown
true
false
```

### 8 序列和哈希

Freemarker支持序列（类似于Java的List）和哈希（类似于Java的Map）数据结构。

```markdown
序列：["Apple", "Banana", "Cherry"]
哈希：{"name": "John", "age": 30}
```

### 9 表达式

Freemarker支持各种表达式，包括算术表达式、比较表达式和逻辑表达式。这些表达式可以在条件判断和循环遍历等指令中使用。

```markdown
算术表达式：${a + b}
比较表达式：${a == b}
逻辑表达式：${a && b} <#-- 支持与或非、三元运算 -->
```

## Freemarker模板指令

### 1 条件指令

####  a if指令

`if`指令用于条件判断，根据条件的真假决定是否执行某段代码。

```markdown
<#if condition>
  // 条件为真时执行的代码
</#if>
```

####  b elseif和else指令

`elseif`和`else`指令可以与`if`指令配合使用，实现多条件判断。

```markdown
<#if condition1>
  // condition1为真时执行的代码
<#elseif condition2>
  // condition1为假且condition2为真时执行的代码
<#else>
  // 所有条件均为假时执行的代码
</#if>
```

### 2 循环指令

#### a list指令

`list`指令用于遍历序列或哈希，实现循环输出。

```markdown
<#list sequence as item>
  // 循环体，使用item变量访问当前元素
</#list>
```

还可以配合seq、break、items、else、continue等指令一起使用。参考：

### 3 包含与宏指令

#### a include指令

`include`指令用于在当前模板中包含另一个模板的内容。

```markdown
<#include "path/to/template.ftl">
```

#### b import指令

`import`指令用于引入另一个模板的宏（macro）。

```markdown
<#import "path/to/template.ftl" as namespace>
```

#### c macro指令

`macro`指令用于定义宏，宏可以包含一段可重复使用的代码片段。

```markdown
<#macro macroName param1 param2>
  // 宏的内容
</#macro>
```

调用宏的方法如下：

```markdown
<@macroName param1=value1 param2=value2/>
```

示例：
```injectedfreemarker
<#macro shout text>
  ${text?upper_case}!
</#macro>

---

<@shout text="hello"/>
```

### 4 其他常用指令

#### a assign指令

`assign`指令用于在模板中定义变量。

```markdown
<#assign variableName = value>
```

#### b switch指令

`switch`指令用于多条件分支判断。

```markdown
<#switch variable>
  <#case value1>
    // 当变量等于value1时执行的代码
  <#case value2>
    // 当变量等于value2时执行的代码
  <#default>
    // 当变量不等于任何给定值时执行的代码
</#switch>
```

#### c escape指令

`escape`指令用于转义特殊字符，防止跨站脚本攻击（XSS）等安全问题。

```markdown
<#escape x as x?html>
  // 转义后的内容，所有特殊字符将被替换为HTML实体
</#escape>
```

### 3.5 自定义指令

除了Freemarker内置的指令之外，还可以编写自定义指令来扩展功能。

自定义指令需要实现`freemarker.template.TemplateDirectiveModel`接口，然后在Java代码中将自定义指令添加到数据模型中。

```java
public class CustomDirective implements TemplateDirectiveModel {
    @Override
    public void execute(Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body)
            throws TemplateException, IOException {
        // 自定义指令的实现
    }
}
```

在模板中使用自定义指令：

```markdown
<@customDirective param1=value1 param2=value2/>
```

## 内置函数

Freemarker提供了许多内置函数，用于处理字符串、数字、日期、序列等数据类型。这些内置函数可以对变量进行操作，以生成所需的输出。

```markdown
${变量名?内置函数}
```

#### a 字符串函数
以下是各个字符串函数的参数和功能介绍：

- `boolean(str)`：将一个字符串转换为布尔类型。参数 `str` 是要转换的字符串。如果字符串是 `true`、`yes`、`y`、`t`、`1`，则返回 `true`，否则返回 `false`。
- `cap_first(str)`：将一个字符串的首字母大写。参数 `str` 是要大写首字母的字符串。
- `c(str)`：将一个对象转换成字符串。参数 `str` 是要转换的对象。
- `cn(str)`：将一个对象转换成字符串，并将 `null` 值转换为空字符串。参数 `str` 是要转换的对象。
- `c_lower_case(str)`：将一个字符串的第一个单词转换成小写字母。参数 `str` 是要转换的字符串。
- `c_upper_case(str)`：将一个字符串的第一个单词转换成大写字母。参数 `str` 是要转换的字符串。
- `capitalize(str)`：将一个字符串的首字母大写。参数 `str` 是要大写首字母的字符串。
- `chop_linebreak(str)`：去除一个字符串末尾的换行符（如果有）。参数 `str` 是要去除换行符的字符串。
- `contains(str, search)`：判断一个字符串是否包含指定的子字符串。参数 `str` 是要判断的字符串，`search` 是要查找的子字符串。
- `date(date, format)`：将一个日期对象格式化成字符串。参数 `date` 是要格式化的日期对象，`format` 是日期格式模板。
- `time(time, format)`：将一个时间对象格式化成字符串。参数 `time` 是要格式化的时间对象，`format` 是时间格式模板。
- `datetime(datetime, format)`：将一个日期时间对象格式化成字符串。参数 `datetime` 是要格式化的日期时间对象，`format` 是日期时间格式模板。
- `ends_with(str, suffix)`：判断一个字符串是否以指定的后缀结尾。参数 `str` 是要判断的字符串，`suffix` 是要查找的后缀。
- `ensure_ends_with(str, suffix)`：确保一个字符串以指定的后缀结尾，如果没有则添加。参数 `str` 是要处理的字符串，`suffix` 是要添加的后缀。
- `ensure_starts_with(str, prefix)`：确保一个字符串以指定的前缀开头，如果没有则添加。参数 `str` 是要处理的字符串，`prefix` 是要添加的前缀。
- `esc(str)`：对一个字符串进行 HTML 和 XML 转义，将一些特殊字符转换成 HTML 或 XML 实体。参数 `str` 是要转义的字符串。
- `groups(str, pattern)`：在一个字符串中查找指定正则表达式的匹配，并返回匹配的分组。参数 `str` 是要查找的字符串，`pattern` 是正则表达式。
- `html(str)`：对一个字符串进行 HTML 转义，将一些特殊字符转换成 HTML 实体。参数 `str` 是要转义的字符串。
- `index_of(str, search)`：查找一个字符串中指定子字符串第一次出现的位置。参数 `str` 是要查找的字符串，`search` 是要查找的子字符串。
- `j_string(str)`：对一个字符串进行 JSON 转义，将一些特殊字符转换成 JSON 字符串中的转义字符。参数 `str` 是要转义的字符串。
- `js_string(str)`：对一个字符串进行 JavaScript 转义，将一些特殊字符转换成 JavaScript 字符串中的转义字符。参数 `str` 是要转义的字符串。
- `json_string(obj)`：将一个对象转换成 JSON 字符串。参数 `obj` 是要转换的对象。
- `keep_after(str, search)`：保留一个字符串中指定子字符串后面的内容。参数 `str` 是要处理的字符串，`search` 是要保留的子字符串。
- `keep_after_last(str, search)`：保留一个字符串中最后一个指定子字符串后面的内容。参数 `str` 是要处理的字符串，`search` 是要保留的子字符串。
- `keep_before(str, search)`：保留一个字符串中指定子字符串前面的内容。参数 `str` 是要处理的字符串，`search` 是要保留的子字符串。
- `keep_before_last(str, search)`：保留一个字符串中最后一个指定子字符串前面的内容。参数 `str` 是要处理的字符串，`search` 是要保留的子字符串。
- `last_index_of(str, search)`：查找一个字符串中指定子字符串最后一次出现的位置。参数 `str` 是要查找的字符串，`search` 是要查找的子字符串。
- `left_pad(str, width, pad)`：在一个字符串左侧添加指定的填充字符，使其达到指定的宽度。参数 `str` 是要填充的字符串，`width` 是要填充到的宽度，`pad` 是填充字符。
- `length(str)`：获取一个字符串的长度。参数 `str` 是要获取长度的字符串。
- `lower_case(str)`：将一个字符串转换成小写字母。参数 `str` 是要转换的字符串。
- `matches(str, pattern)`：判断一个字符串是否匹配指定的正则表达式。参数 `str` 是要判断的字符串，`pattern` 是正则表达式。
- `no_esc(str)`：对一个字符串进行无转义输出，不进行任何转义。参数 `str` 是要输出的字符串。
- `number(str)`：将一个字符串转换成数字。参数 `str` 是要转换的字符串。
- `replace(str, search, replace)`：将一个字符串中所有出现的目标字符串替换成另一个字符串。参数 `str` 是原始字符串，`search` 是要被替换的目标字符串，`replace` 是替换目标字符串的字符串。
- `right_pad(str, width, pad)`：在一个字符串右侧添加指定的填充字符，使其达到指定的宽度。参数 `str` 是要填充的字符串，`width` 是要填充到的宽度，`pad` 是填充字符。
- `remove_beginning(str, remove)`：去除一个字符串开头的指定子字符串。参数 `str` 是要处理的字符串，`remove` 是要去除的子字符串。
- `remove_ending(str, remove)`：去除一个字符串末尾的指定子字符串。参数 `str` 是要处理的字符串，`remove` 是要去除的子字符串。
- `rtf(str)`：对一个字符串进行 RTF 转义，将一些特殊字符转换成 RTF 控制字符。参数 `str` 是要转义的字符串。
- `split(str, delimiter)`：将一个字符串按照指定的分隔符拆分成一个字符串列表。参数 `str` 是要拆分的字符串，`delimiter` 是分隔符。
- `starts_with(str, prefix)`：判断一个字符串是否以指定的前缀开头。参数 `str` 是要判断的字符串，`prefix` 是要查找的前缀。
- `string(str)`：将一个对象转换成字符串。参数 `str` 是要转换的对象。
- `substring(str, beginIndex, endIndex)`：获取一个字符串的子串。参数 `str` 是要获取子串的字符串，`beginIndex` 是起始下标（包括该下标的字符），`endIndex` 是结束下标（不包括该下标的字符）。
- `trim(str)`：去除一个字符串两侧的空格。参数 `str` 是要去除空格的字符串。
- `truncate(str, maxLength)`：将一个字符串截断到指定的最大长度。参数 `str` 是要截断的字符串，`maxLength` 是最大长度。
- `truncate_auto(str, maxLength, suffix)`：将一个字符串截断到指定的最大长度，并添加指定的后缀。如果字符串本身已经小于等于最大长度，则不进行截断。参数 `str` 是要截断的字符串，`maxLength` 是最大长度，`suffix` 是要添加的后缀。
- `truncate_words(str, maxLength, suffix)`：将一个字符串按照空格拆分成单词列表，将单词列表缩略到指定的最大长度，并添加指定的后缀。参数 `str` 是要处理的字符串，`maxLength` 是最大长度，`suffix` 是要添加的后缀。
- `uncap_first(str)`：将一个字符串的首字母转换成小写字母。参数 `str` 是要转换的字符串。
- `upper_case(str)`：将一个字符串转换成大写字母。参数 `str` 是要转换的字符串。
- `url(str)`：对一个字符串进行 URL 转义，将一些特殊字符转换成 URL 编码。参数 `str` 是要转义的字符串。
- `url_path(str)`：对一个字符串进行 URL 路径转义，将一些特殊字符转换成 URL 编码。参数 `str` 是要转义的字符串。
- `word_list(str)`：将一个字符串按照空格拆分成单词列表。参数 `str` 是要拆分的字符串。

#### b 数字函数
- `abs(num)`：返回一个数的绝对值。参数 `num` 是要求绝对值的数字。
- `c(num)`：将一个对象转换成数值类型。参数 `num` 是要转换的对象。
- `cn(num)`：将一个对象转换成数值类型，并将 `null` 值转换为 0。参数 `num` 是要转换的对象。
- `is_infinite(num)`：判断一个数是否为无穷大。参数 `num` 是要判断的数字。
- `is_nan(num)`：判断一个数是否为 NaN（Not a Number）。参数 `num` 是要判断的数字。
- `lower_abc(num)`：将一个数转换成小写字母表中对应的字母。参数 `num` 是要转换的数字，转换规则为 1 对应 `a`，2 对应 `b`，以此类推。
- `round(num, scale, roundingMode)`：对一个数进行四舍五入。参数 `num` 是要四舍五入的数字，`scale` 是小数点后保留的位数，`roundingMode` 是取整模式，可以是 `halfUp`、`halfDown`、`halfEven`、`up`、`down` 中的一种。
- `floor(num)`：对一个数进行向下取整。参数 `num` 是要取整的数字。
- `ceiling(num)`：对一个数进行向上取整。参数 `num` 是要取整的数字。
- `string(num)`：将一个对象转换成字符串。参数 `num` 是要转换的对象，通常为数值类型。
- `upper_abc(num)`：将一个数转换成大写字母表中对应的字母。参数 `num` 是要转换的数字，转换规则为 1 对应 `A`，2 对应 `B`，以此类推。

#### c 日期函数
- `date(date)`：从一个日期/时间/日期时间值中提取出日期部分。参数 `date` 是要提取日期部分的日期/时间/日期时间值。
- `time(date)`：从一个日期/时间/日期时间值中提取出时间部分。参数 `date` 是要提取时间部分的日期/时间/日期时间值。
- `datetime(date)`：将一个日期/时间/日期时间值转换成日期时间格式的字符串。参数 `date` 是要转换的日期/时间/日期时间值。
- `date_if_unknown(date, fallback)`：从一个日期/时间/日期时间值中提取出日期部分，如果提取不到，则返回指定的备选值。参数 `date` 是要提取日期部分的日期/时间/日期时间值，`fallback` 是备选值。
- `time_if_unknown(date, fallback)`：从一个日期/时间/日期时间值中提取出时间部分，如果提取不到，则返回指定的备选值。参数 `date` 是要提取时间部分的日期/时间/日期时间值，`fallback` 是备选值。
- `datetime_if_unknown(date, fallback)`：将一个日期/时间/日期时间值转换成日期时间格式的字符串，如果转换失败，则返回指定的备选值。参数 `date` 是要转换的日期/时间/日期时间值，`fallback` 是备选值。
- `iso_...`：ISO 格式化日期/时间/日期时间值的函数。可以有以下变种：
    - `iso_date(date)`：将一个日期/时间/日期时间值转换成 ISO 8601 格式的日期字符串，例如 `2019-12-31`。
    - `iso_time(date)`：将一个日期/时间/日期时间值转换成 ISO 8601 格式的时间字符串，例如 `12:34:56.789`。
    - `iso_datetime(date)`：将一个日期/时间/日期时间值转换成 ISO 8601 格式的日期时间字符串，例如 `2019-12-31T12:34:56.789+08:00`。
- `string(date)`：将一个日期/时间/日期时间值转换成字符串。参数 `date` 是要转换的日期/时间/日期时间值。

#### d 布尔函数
- `c(bool)`：将一个对象转换成布尔类型。参数 `bool` 是要转换的对象。
- `cn(bool)`：将一个对象转换成布尔类型，并将 `null` 值转换为 `false`。参数 `bool` 是要转换的对象。
- `string(bool)`：将一个对象转换成字符串。参数 `bool` 是要转换的对象，通常为布尔类型。
- `then(condition, thenValue, elseValue)`：根据条件返回指定的值。如果条件为真，则返回 `thenValue`，否则返回 `elseValue`。参数 `condition` 是要判断的条件，可以是布尔类型或布尔表达式；`thenValue` 是条件为真时返回的值；`elseValue` 是条件为假时返回的值。

#### e 序列函数
- `chunk(seq, chunkSize)`：将一个序列按照指定的大小拆分成多个子序列。参数 `seq` 是要拆分的序列，`chunkSize` 是每个子序列的大小。
- `drop_while(seq, condition)`：从一个序列中删除满足条件的前缀，直到遇到第一个不满足条件的元素。参数 `seq` 是要处理的序列，`condition` 是一个布尔表达式，表示要删除的元素应该满足的条件。
- `filter(seq, condition)`：从一个序列中筛选出满足条件的元素，返回一个新的序列。参数 `seq` 是要筛选的序列，`condition` 是一个布尔表达式，表示要筛选的元素应该满足的条件。
- `first(seq)`：返回一个序列的第一个元素。参数 `seq` 是要取第一个元素的序列。
- `join(seq, separator)`：将一个序列中的所有元素用指定的分隔符连接成一个字符串。参数 `seq` 是要连接的序列，`separator` 是分隔符。
- `last(seq)`：返回一个序列的最后一个元素。参数 `seq` 是要取最后一个元素的序列。
- `map(seq, transform)`：对一个序列中的每个元素应用指定的转换函数，返回一个新的序列。参数 `seq` 是要转换的序列，`transform` 是转换函数。
- `min(seq)`：返回一个序列中的最小值。参数 `seq` 是要查找最小值的序列。
- `max(seq)`：返回一个序列中的最大值。参数 `seq` 是要查找最大值的序列。
- `reverse(seq)`：将一个序列中的元素顺序颠倒，返回一个新的序列。参数 `seq` 是要翻转的序列。
- `seq_contains(seq, value)`：判断一个序列是否包含指定的值。参数 `seq` 是要查找的序列，`value` 是要查找的值。
- `seq_index_of(seq, value)`：返回一个序列中第一次出现指定值的下标，如果没有找到则返回 -1。参数 `seq` 是要查找的序列，`value` 是要查找的值。
- `seq_last_index_of(seq, value)`：返回一个序列中最后一次出现指定值的下标，如果没有找到则返回 -1。参数 `seq` 是要查找的序列，`value` 是要查找的值。
- `size(seq)`：返回一个序列中元素的个数。参数 `seq` 是要计算大小的序列。
- `sort(seq)`：对一个序列进行升序排序，返回一个新的序列。参数 `seq` 是要排序的序列。
- `sort_by(seq, transform)`：对一个序列中的元素进行转换，然后根据转换结果进行升序排序，返回一个新的序列。参数 `seq` 是要排序的序列，`transform` 是转换函数，它将序列中的每个元素转换为排序用的值。转换函数可以是一个 lambda 表达式或是一个自定义函数。
- `take_while(seq, condition)`：从一个序列中取出满足条件的前缀，直到遇到第一个不满足条件的元素。参数 `seq` 是要处理的序列，`condition` 是一个布尔表达式，表示要取出的元素应该满足的条件。

#### f 哈希表函数
- `keys(map)`：返回一个哈希表中所有键组成的列表。参数 `map` 是要获取键列表的哈希表。
- `values(map)`：返回一个哈希表中所有值组成的列表。参数 `map` 是要获取值列表的哈希表。

对于list指令，也可以把键值一次性赋值：`<#list attrs as key, value>...<#list>`

#### g 循环变量函数
list指令对应着Java的foreach。对于其中的循环变量，有如下函数：
- `counter`：返回当前循环的计数器值，从 1 开始计数。
- `has_next`：判断当前循环是否有下一个元素，返回一个布尔值。
- `index`：返回当前循环的索引值，从 0 开始计数。
- `is_even_item`：判断当前循环的计数器值是否为偶数，返回一个布尔值。
- `is_first`：判断当前循环是否为第一个元素，返回一个布尔值。
- `is_last`：判断当前循环是否为最后一个元素，返回一个布尔值。
- `is_odd_item`：判断当前循环的计数器值是否为奇数，返回一个布尔值。
- `item_cycle(list)`：按照顺序循环遍历一个列表中的所有元素，并在列表的末尾重新开始。参数 `list` 是要循环遍历的列表。
- `item_parity`：判断当前循环的计数器值是偶数还是奇数，并返回对应的字符串 `"even"` 或 `"odd"`。
- `item_parity_cap`：判断当前循环的计数器值是偶数还是奇数，并返回对应的字符串 `"Even"` 或 `"Odd"`，首字母大写。

#### h XML节点函数
- `ancestors(node)`：返回一个节点的所有祖先节点。参数 `node` 是要获取祖先节点的节点。
- `children(node)`：返回一个节点的所有子节点。参数 `node` 是要获取子节点的节点。
- `node_name(node)`：返回一个节点的名称。参数 `node` 是要获取名称的节点。
- `next_sibling(node)`：返回一个节点的下一个同级节点。参数 `node` 是要获取下一个同级节点的节点。
- `node_namespace(node)`：返回一个节点的命名空间。参数 `node` 是要获取命名空间的节点。
- `node_type(node)`：返回一个节点的类型。参数 `node` 是要获取类型的节点。
- `parent(node)`：返回一个节点的父节点。参数 `node` 是要获取父节点的节点。
- `previous_sibling(node)`：返回一个节点的上一个同级节点。参数 `node` 是要获取上一个同级节点的节点。
- `root(node)`：返回一个节点所在的文档的根节点。参数 `node` 是要获取根节点的节点。

#### i switch函数
独立于类型的函数只有switch一个。

- `switch(case1, result1, case2, result2, ... caseN, resultN, defaultResult)`：按照指定的值或表达式进行匹配，返回匹配到的结果。

用法：
```injectedfreemarker
<#list ['r', 'w', 'x', 's'] as flag>
  ${flag?switch('r', 'readable', 'w' 'writable', 'x', 'executable', 'unknown flag: ' + flag)}
</#list>
```

#### j 专家函数
以下是一些通常不该用到的内置函数，但是在调试或者高级宏中可能会用到他们。

- `absolute_template_name(template)`：返回模板的绝对路径。参数 `template` 是模板名称。
- `api(name)`：在模板中引入 Java API 类。参数 `name` 是 Java 类的名称。
- `has_api(name)`：判断是否存在指定的 Java API 类。参数 `name` 是 Java 类的名称。
- `byte(value)`：将一个值转换为字节类型。
- `double(value)`：将一个值转换为双精度浮点数类型。
- `float(value)`：将一个值转换为单精度浮点数类型。
- `int(value)`：将一个值转换为整型。
- `long(value)`：将一个值转换为长整型。
- `short(value)`：将一个值转换为短整型。
- `eval(expression)`：执行一个表达式，并返回表达式的值。参数 `expression` 是要执行的表达式。
- `eval_json(expression)`：将 JSON 字符串转换为对象，并执行一个表达式。参数 `expression` 是要执行的表达式，它可以包括 JSON 对象的属性和方法调用。
- `has_content(value)`：判断一个值是否为空。如果值为字符串类型，则忽略空格和换行符，只要包含任意字符就返回 `true`；如果值为集合类型，则只要包含任意元素就返回 `true`；如果值为 `null`，则返回 `false`。
- `interpret(expression)`：将一个字符串解析为模板，并执行解析后的模板。参数 `expression` 是要解析的字符串。
- `is_...(value)`：一组函数，用于判断一个值是否属于某种类型，包括 `is_boolean`、`is_date`、`is_hash`、`is_list`、`is_macro`、`is_node`、`is_number`、`is_sequence`、`is_string` 等。
- `markup_string(string)`：将一个字符串解析为标记字符串，并返回标记字符串对象。参数 `string` 是要解析的字符串。
- `namespace(prefix)`：返回指定前缀的命名空间。参数 `prefix` 是命名空间前缀。
- `new(className, args)`：创建一个新的对象。参数 `className` 是对象的类名，`args` 是对象的构造函数参数。
- `number_to_date(value, pattern)`、`number_to_time(value, pattern)`、`number_to_datetime(value, pattern)`：将一个数字转换为日期、时间或日期时间，并返回格式化后的字符串。参数 `value` 是要转换的数字，`pattern` 是日期、时间或日期时间的格式化字符串。
- `sequence(start, end)`：创建一个指定范围的整数序列。参数 `start` 是序列的起始值，`end` 是序列的结束值（不包含）。
- `with_args(arguments, expression)`：执行一个表达式，并将参数传递给表达式。参数 `arguments` 是一个列表，包含参数的名称和值，`expression` 是要执行的表达式。
- `with_args_last(arguments, expression)`：执行一个表达式，并将参数传递给表达式。与 `with_args` 函数不同之处在于，最后一个参数的值会被作为可变参数传递给表达式。参数 `arguments` 是一个列表，包含参数的名称和值，最后一个参数的名称应为 `...`，`expression` 是要执行的表达式。

## 特殊变量引用
