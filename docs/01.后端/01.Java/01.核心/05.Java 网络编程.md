
https://juejin.cn/post/6844903685563088903

本文主要探讨Java网络编程，其实这部分内容也属于Java IO，但是因为本身体量较大，内容较多，又是Java开发的重点，所以单独成一章来写。  
文中会涉及到IO的基础知识，如果你对他们还没有掌握，请参考：[Java IO](/pages/88c2d0/)  
文章分为两部分：Socket编程和HTTP编程。
<!-- more -->

## 网络协议分层
在了解具体的Java网络编程之前，我们需要对网络协议有一个初步的认识。  
因为网络协议的复杂性，所以要分层，结构如下：
![clipboard](https://cdn.staticaly.com/gh/xuanyuanli/Img@master/picx/clipboard.dajuo1m0w88.jpg)

实践当中，TCP/IP四层协议见得比较多。简单来说，四层协议的作用如下：
- 数据链路层：解决路由器、交换机之间的互联问题
- 网络层：解决主机之间的互联问题
- 传输层：解决程序之间的互联问题
- 应用层：解决上层内容之间的互联问题

## Socket编程
Socket是TCP/IP协议栈中不同主机应用进程之间进行双向通信的端点抽象。  
Socket编程是传输层的编程，主要解决主机-应用进程之间通信的问题。  
比如主机A中的Client程序要与主机B中的Server程序进行通信，Client发送“我要吃肉”，Server回复“地主家没有余粮了”。

### 1、传统IO
在传统Java IO中的实现，服务端：
```java
    void server(){
        try (ServerSocket server = new ServerSocket(8888);) {
            while (true){
                Socket socket = server.accept();
                InputStream is = socket.getInputStream();
                OutputStream os = socket.getOutputStream();
                Scanner scanner = new Scanner(is);
                PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, StandardCharsets.UTF_8), true);

                while (scanner.hasNextLine()) {
                    String line = scanner.nextLine();
                    if (line.startsWith("我要吃肉")){
                        pw.println("地主家没有余粮了");
                    }else {
                        pw.println("我不知道你在说什么");
                    }
                    if ("exit".equals(line)) {
                        pw.println("exit");
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```
客户端：
```java
    void client(){
        try (Socket socket = new Socket("localhost", 8888);
                InputStream is = socket.getInputStream();
                OutputStream outputStream = socket.getOutputStream();) {
            PrintWriter pw = new PrintWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8), true);
            Scanner scanner = new Scanner(is, StandardCharsets.UTF_8);
            pw.println("我要吃肉");
            pw.println("exit");
            boolean done = false;
            while (!done && scanner.hasNextLine()) {
                String line = scanner.nextLine();
                System.out.println(line);
                if (line.equals("exit")){
                    done = true;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```
上面的server程序只能为一个客户端服务，如果要为多个客户端服务，需要引入多线程：
```java
try (ServerSocket server = new ServerSocket(8888)) {

    while (true) {
        Socket socket = server.accept();
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
              // 套接字处理程序
            }
        });
        thread.start();
    }
} catch (IOException e) {
    e.printStackTrace();
}
```
每一个Client都启动一个线程有点浪费，也可以考虑引入线程池。  

### 2、NIO
传统IO是阻塞IO，应对几百个连接的普通应用，还是得心应手的。如果连接数急剧上升，那么按照传统IO的方式编程，线程的上下文切换的开销会很大。  
为了解决传统IO的问题，Java 1.4引入了NIO，NIO 利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，这样就可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。  
服务端示例：
```java
    void server() throws IOException {
        Selector selector = Selector.open();

        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);

        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
        serverSocket.bind(address);
        while (true) {
            selector.select();
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = keys.iterator();
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                if (key.isAcceptable()) {
                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();
                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);
                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);
                } else if (key.isReadable()) {
                    SocketChannel sChannel = (SocketChannel) key.channel();
                    String line = readDataFromSocketChannel(sChannel);
                    if (line.startsWith("我要吃肉")){
                        sChannel.write(StandardCharsets.UTF_8.encode("地主家没有余粮了"));
                    }else {
                        sChannel.write(StandardCharsets.UTF_8.encode("我不知道你在说什么"));
                    }
                    sChannel.close();
                }
                keyIterator.remove();
            }
        }
    }

    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();
        while (true) {
            buffer.clear();
            int n = sChannel.read(buffer);
            if (n <= 0) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            data.append(StandardCharsets.UTF_8.decode(buffer));
            buffer.clear();
        }
        return data.toString();
    }
```
NIO的逻辑是：
- Selector是一个调度器
- 创建ServerSocketChannel，并向Selector注册。SelectionKey.OP_ACCEPT表示关注的是新请求，ssChannel.configureBlocking(false)表示非阻塞
- Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒
- 唤醒之后，对key进行批量处理。如果key是连接事件，则把此通道上注册为数据读取；如果key是读取事件，则进行对应的处理


客户端的逻辑基本没变化：
```java
    void client() throws IOException {
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream out = socket.getOutputStream();
        out.write("我要吃肉".getBytes());
        Scanner scanner = new Scanner(socket.getInputStream(), StandardCharsets.UTF_8);
        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            System.out.println(line);
        }
        out.close();
    }
```

### 3、AIO


## HTTP编程



