---
title: Java集合
date: 2022-08-06 10:17:02
permalink: /pages/d2e513/
categories:
  - Java
  - 核心
tags:
  - Java集合
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

本文主要讲解JDK内部集合类、Apache Commons Collection中的集合类、Guava中的集合类、并发集合类、Redission分布式集合类。  
<!-- more -->

## JDK内部集合
### 1、数组
两种初始化方法：
```java
// 方式1
String[] arr = new String[2];

// 方式1
String[] arr = new String[]{"", ""};
```
多维数组：
```java
String[][] arr = new String[2][3];
```
用法：
```java
// 访问元素
arr[0]

// 循环-方式1
for (String s : arr) {
    ...
}

// 循环-方式2
for (int i = 0; i < arr.length; i++) {
    String s = arr[i];
    ...
}
// 循环-方式3
Arrays.stream(arr).forEach(s -> {});

// 循环-倒序
for (int i = arr.length - 1; i >= 0; i--) {
    String s = arr[i];
    ...
}
```
Arrays工具类中的方法：
- stream&emsp;数组转为Stream流
- copyOfRange&emsp;将指定数组的指定范围复制到新数组中
- copyOf&emsp;复制指定的数组，截断或填充空值（如有必要），使副本具有指定的长度
- binarySearch&emsp;二分搜索
- fill&emsp;将指定的值分配给数组的每个元素
- setAll&emsp;和fill类似，不过指定值为自定义Function
- sort&emsp;升序排序
- spliterator&emsp;拆分器。大多数情况下，你都不需要使用到这个方法，他主要是跟StreamSupport配合使用。参考[java8 Stream之Spliterator](https://blog.csdn.net/weixin_38308374/article/details/112972462)
- parallelPrefix&emsp;使用提供的函数并行累积给定数组的每个元素。相当于并行的reduce操作
- parallelSetAll&emsp;setAll的并行版本
- parallelSort&emsp;sort的并行版本
- toString、equals、hashCode&emsp;共用基础方法，不多说。此外这三个方法还有对应的deep系列，分别是deepToString、deepEquals、deepHashCode


这其中要重点说一下数组拷贝，其实Java中数组拷贝最终都是调用`System.arraycopy()`方法，这个方法的性能是非常高的，因为它是直接对内存进行复制。所以关于数组复制尽量调用此方法。      
需要注意的是`System.arraycopy()`属于浅复制，也就是复制对象和二维数组的时候复制的是引用，修改复制后的对象会影响到原始对象。  


数组特点：
- 访问速度快。插入和查询时间复杂度是O(1)
- 初始化之后长度不可变，不支持动态扩容


### 2、List
为了解决数组动态扩容的问题，产生了List集合。  
主要有两个实现类：
- ArrayList&emsp;数组实现。遍历和随机访问效率高
- LinkedList&emsp;链表实现。插入和删除效率高

初始化：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(3);

// java9之后。of方法返回的是不可变List
List<Integer> list = List.of(2,3)
```

List继承自Collection接口，Collection继承自Iterable接口。  
Iterable中的方法：
- iterator&emsp;迭代器。有了他我们就可以使用foreach循环了
- forEach&emsp;java8之后新增方法，lambda式的forEach 
- spliterator&emsp;拆分器

Collection中的方法：
- size&emsp;获得集合中的元素数
- isEmpty&emsp;此集合是否不包含任何元素
- contains&emsp;是否包含指定元素
- toArray&emsp;转换为array数组。toArray默认返回时Object数组，但他有两个重载方法，可以返回指定类型的数组
```java
String[] arr = list.toArray(new String[]{});
String[] arr2 = list.toArray(i->new String[]{});
```
- add&emsp;添加元素
- remove&emsp;删除元素
- containsAll&emsp;是否包含指定的所有元素
- addAll&emsp;添加指定的所有元素
- removeAll&emsp;删除指定的所有元素
- removeIf&emsp;删除满足条件的元素
- retainAll&emsp;保留指定的所有元素，其他元素则删除
- clear&emsp;清空集合
- stream&emsp;获得stream流
- parallelStream&emsp;获得并行stream流

List中的方法：
- addAll(i,col)&emsp;指定位置添加元素
- replaceAll&emsp;按照指定规则替换所有元素
- sort&emsp;根据Comparator进行排序。在java8中使用lambda表达式特别方便
```java
// 对于基本类型
list.sort(String::compareTo);
//对于Comparator<String> compare = String::compareTo;你可能会比较迷惑，其实他的转换过程是这样的
BiFunction<String, String, Integer> bf = String::compareTo;
Comparator<String> compare = (Comparator<String>) bf;  // 可以看到Comparator函数接口的结果和BiFunction是相似的，java做了简化处理


// 对于Bean
list.sort(Comparator.comparing(TUser::getId))
```
- get&emsp;获得指定位置元素
- set&emsp;设置指定位置元素
- add(i,e)&emsp;添加指定位置元素。会导致原先此位置的元素后移
- remove(i)&emsp;删除指定位置元素。如果List中泛型为Integer，这里会和Collection中的remove有一个冲突，具体这么做
```java
// 调用的是Collection.remove
intList.remove(Integer.valueOf(2));

// 调用的是List.remove
intList.remove(5);
```
- indexOf&emsp;指定元素第一次出现时的索引
- lastIndexOf&emsp;指定元素最后一次出现时的索引
- listIterator&emsp;获得ListIterator，支持在迭代期间修改列表
- subList&emsp;返回指定位置范围的视图

List还有两个静态方法：
- of&emsp;java9之后支持。获得不可修改的列表
- copyOf&emsp;java11之后支持。拷贝一个不可修改的列表

### 3、Set
Set是不包含重复元素的集合。继承自Collection接口，主要实现类：
- HashSet&emsp;不保证迭代顺序和插入顺序一致。内部借助HashMap来实现
- LinkedHashSet&emsp;能保证迭代顺序和插入顺序一致。内部借助LinkedHashMap来实现
- TreeSet&emsp;元素按照自然顺序或者提供的Comparator来排序

初始化：
```java
// 方式1
Set<String> set = new HashSet<>();
set.add("a");
set.add("b");

// 方式2。返回不可变Set
Set<Integer> integers = Set.of(1, 2);
```

HashSet和LinkedHashSet没有自己独立的方法，参考Collection接口即可。  
Set接口有of和copyOf方法，功能同List。  
TreeSet继承自NavigableSet，NavigableSet继承自SortedSet。我们来看看他们其中的方法。  

SortedSet提供了对元素排序的功能，其中的方法有：
- subSet&emsp;返回此集合部分的视图，其元素范围从fromElement （包括）到toElement （不包括）
- headSet&emsp;返回此集合中元素严格小于toElement的部分的视图
- tailSet&emsp;返回此集合中元素大于或等于fromElement的部分的视图
- first&emsp;第一个元素
- last&emsp;最后一个元素

NavigableSet是对SortedSet的导航扩展，报告给定搜索目标的最接近匹配。参考[NavigableSet Api](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/NavigableSet.html)

Set和List都继承自Collection接口，JDK提供了Collections工具类，其中有一些常用的方法：
- sort&emsp;自然排序
- binarySearch&emsp;二分搜索
- reverse&emsp;反转集合顺序
- shuffle&emsp;打乱顺序（洗牌）
- swap&emsp;根据下标交换指定元素的位置
- copy&emsp;列表拷贝
- min&emsp;根据排序规则，取得最小值
- max&emsp;根据排序规则，取得最大值
- rotate&emsp;旋转，元素的位置将要被重新调整为(i - distance) mod list.size()。用于快速元素移动很有效
```java
List<Integer> list = Lists.newArrayList(1, 2, 3, 4);
// 将元素整体后移一位
Collections.rotate(list, 1);     // [4, 1, 2, 3]
// 将元素整体前移一位
Collections.rotate(list, -1);     // [2, 3, 4, 1]
// 仅移动部分区间数据
Collections.rotate(list.subList(1,3),1);    // [1, 3, 2, 4]
```
- replaceAll&emsp;替换集合中旧值为新值
- indexOfSubList&emsp;列表级别的indexOf
- unmodifiableCollection&emsp;变为不可修改集合。还有系列方法：unmodifiableSet、unmodifiableSortedSet、unmodifiableNavigableSet、unmodifiableMap等
- synchronizedCollection&emsp;变为现场安全的集合。系统方法同上。Java1.5之后新增了同步容器ConcurrentMap等，所以不再推荐使用此系列方法
- checkedCollection&emsp;返回指定集合的动态类型安全视图，只允许插入指定的类型。系列方法同上
- emptyIterator&emsp;返回一个没有元素的迭代器。还有系列方法：emptySet、emptyList、emptyMap等
- singleton&emsp;返回一个只包含指定对象的不可变集合。还有系列方法：singletonList、singletonMap
- nCopies&emsp;n个对象副本组成的不可变列表
- reverseOrder&emsp;排序辅助方法，返回逆序的Comparator
- enumeration&emsp;返回集合的Enumeration对象
- list&emsp;Enumeration对象转换为List对象
- frequency&emsp;返回指定集合中等于指定对象的元素数，其实可以叫getCount
- disjoint&emsp;两集合没有共同的元素，则返回true


### 4、Map
Map是键值对，每个键最多映射到一个值上。主要实现类有：
- HashMap&emsp;基于哈希表的实现，允许null键和null值。内部使用数组+链表的数据结构，为了保证性能，Java8之后链表元素数量大于阈值会变为红黑树
- LinkedHashMap&emsp;保证了迭代顺序和插入顺序一致，允许null键和null值。内部使用哈希表+双向链表实现
- TreeMap&emsp;键值按照自然顺序或者提供的Comparator来排序，不允许null键，允许null值。内部使用红黑树来实现
- HashTable&emsp;线程安全的哈希表，因为性能太差，不推荐使用。讲到并发集合的时候，用ConcurrentMap替代它

Map接口有of和copyOf方法，功能同List。此外还有两个静态方法：entry和ofEntries。  
初始化：
```java
// 方式1
Map<String, Integer> map = new HashMap<>();
map.put("a",1);
map.put("b",2);
        
// 方式2。返回不可变Map
Map<Integer, Integer> integerMap = Map.of(1, 2);

// 方式3。返回不可变Map
Map<String, Integer> stringIntegerMap = Map.ofEntries(Map.entry("a", 1), Map.entry("b", 2));
```

Map接口的方法：
- size&emsp;键值数量
- isEmpty&emsp;是否为空字典
- containsKey&emsp;是否包含指定键
- containsValue&emsp;是否包含指定值
- get&emsp;根据键获得值
- put&emsp;添加键值
- remove&emsp;删除键值
- putAll&emsp;批量添加
- clear&emsp;清空键值字典
- keySet&emsp;获得键Set
- values&emsp;获得值集合
- entrySet&emsp;获得键值对Set，泛型为Map.Entry
- getOrDefault&emsp;安全的get，没有值则返回默认值
- forEach&emsp;foreach的lambda版本
- replaceAll&emsp;替换匹配的所有元素
- putIfAbsent&emsp;字典中不存在此键，则添加；否则不做操作
- replace&emsp;替换
- computeIfAbsent&emsp;putIfAbsent的Function版本
- computeIfPresent&emsp;当指定键存在时，重新计算新值
- compute&emsp;尝试计算指定键及其当前映射值的映射
- merge&emsp;旧值替换为新值，或直接赋值

后四个方法为Java 8中新增的，有必要演示一下：
```java
// 基础数据
Map<String, Object> map = new HashMap<>();
map.put("name", "Jack");
map.put("age", 25);

// computeIfAbsent：name不会被插入成功。因为已经存在了name键
map.computeIfAbsent("name", k -> k + " random");    // 返回值为"Jack"。map：{name=Jack, age=25}
map.computeIfAbsent("score", k -> 90);  // 返回值为90。map：{name=Jack, age=25, score=90}
        
// computeIfPresent：name会被插入成功,会替换掉旧值
map.computeIfPresent("name", (k,v) -> k + " random");   // 返回值为"name random"。map：{name=name random, age=25}
// 可以按照你想要的规则进行替换
map.computeIfPresent("name", (k,v) -> v + " random");   // {name=Jack random, age=25}
map.computeIfPresent("name", (k,v) -> k + v);   // {name=name Jack, age=25}
// 替换新值为null的话键值会被删除
map.computeIfPresent("name", (k,v) -> null);    // 返回值为null。map：{age=25}
// 插入一个不存在的键值会失败
map.computeIfPresent("score", (k,v) -> 90); // 返回值为null。map：{name=Jack, age=25}

// compute：可定制的计算，computeIfPresent的增强版，可以获得现有的k，v对齐进行操作
...

// merge：合并。如果存在旧值，则使用BiFunction进行替换；否则赋予新值
map.merge("score", 80, (k, v) -> v + 5);    //map：{name=Jack, age=25, score=80}
```

HashMap和LinkedHashMap没有自己独有的方法，只是实现了Map接口。  
TreeMap还实现了NavigableMap->SortedMap，参考[NavigableMap Api](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/NavigableMap.html)

### 5、其他
Queue接口定义了队列，有offer、poll、peek等队列专有方法。主要实现类有PriorityQueue（优先级队列）。      
Deque继承自Queue，定义了双端队列，有offer/poll/peek-First/Last等系列方法，主要实现类是ArrayDeque、LinkedList。

Stack是Java中栈的实现类，有push、pop、peek等专有方法。  

## Apache Commons Collection集合
Apache Commons系列工具包是Java开发中常用的工具包，其中关于集合方面的扩展要使用到commons-collections4：
```java
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-collections4</artifactId>
    <version>4.4</version>
</dependency>
```
此工具工具包主要提供了三方面的扩展

### 1、工具类
主要是SetUtils、ListUtils、CollectionUtils、MapUtils。这些工具类有一些方法在Java8之后有点过时了，比如：
```java
List<Integer> list = List.of(1, 2, 3, 4);
// select方法
List<Integer> select = ListUtils.select(list, e -> e > 2);
// java8之后这么做
select = list.stream().filter(e->e>2).collect(Collectors.toList());
```
其他诸如filter、transform、getCardinalityMap等方法，用Stream操作会更简单一些。  

下面列出一些提高效率的便利方法：
- subtract 取得差集
- disjunction 获得彼此差集之后的并集
- intersection 取得交集
- union 取得并集
- containsAny 包含任何
- permutations  返回列表的所有排列组合，大小是列表大小的阶乘级别，注意性能和内存问题

### 2、容器类
Bag 会记录对象在集合中出现的次数，用法：
```java
Bag bag = new HashBag();
bag.add("ONE", 6);  // 添加6次
bag.remove("ONE", 2);  // 删除2次
bag.getCount("ONE");  // 返回4
```
主要实现类有HashBag和TreeBag（自然排序）

---

List的扩展，主要有如下类：
- CursorableLinkedList 提供了可修改的迭代器。在JDK的List.listIterator中提供了类似功能
- FixedSizeList 固定大小的List，add、remove、clear和retain操作是不被支持的，set方法是允许的但是不会影响列表大小
- GrowthList 可以使其在因set或add操作造成索引超出异常时无缝的增加列表长度，可以避免大多数的IndexOutOfBoundsException
- LazyList 可以自动增长，但只发生在get时--允许指定一个Factory获得超出索引位置的值
- PredicatedList 添加元素时进行校验
- SetUniqueList 不允许重复元素的列表
- TransformedList 在set和add时对元素进行转换后再添加
- TreeList 实现了一个快速插入、删除，同时查询性能也可观的List

看完之后，怎么说呢？这些类用的频率都不太高，但又弃之可惜。

--- 

Set的扩展有如下类：
- CompositeSet 多个Set的组合视图
- 剩余的Predicated、Transformed、Unmodifiable和List一样，不赘言

--- 

Map的扩展有如下类：
- CaseInsensitiveMap 大小写不敏感的Map，会把键都转换为小写
- CompositeMap 多个Map的组合视图
- DefaultedMap 键不存在，返回默认对象
- FixedSizeMap 固定大小的Map
- IdentityMap 匹配键值不是通过==，而是equals
- MultiKeyMap 允许多个键关联到一个值上
- MultiValueMap 允许多个值关联到一个键上
- BidiMap 双向Map，可以通过值查找键。主要实现类是DualHashBidiMap、TreeBidiMap
- LRUMap 固定大小Map，容器满了之后删除最近最少使用（Least Recently Used）的元素
- LazyMap/PredicatedMap/TransformedMap/TypedMap/UnmodifiableMap，逻辑同List扩展一样，不赘言

### 3、辅助类
主要是Comparator、Predicate、Transformer等辅助类，这些辅助类在Java8 Stream面前都显得有些过时了，不赘言

## Guava集合
如果说commons-collections4是村花的话，那么Guava就是大城市中的女神了。  
Guava中使用最广泛的就是他的集合类。  

https://github.com/google/guava/wiki

## 并发集合

## Redission分布式集合
