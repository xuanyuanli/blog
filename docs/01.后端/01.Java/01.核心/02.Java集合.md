---
title: Java集合
date: 2022-08-06 10:17:02
permalink: /pages/d2e513/
categories:
  - Java
  - 核心
tags:
  - Java集合
author: 
  name: 轩辕李
  link: https://github.com/xuanyuanli
---

本文主要讲解JDK内部集合类、Apache Commons Collection中的集合类、Guava中的集合类、并发集合类、Redission分布式集合类。  
<!-- more -->

## JDK内部集合
### 1、数组
两种初始化方法：
```java
// 方式1
String[] arr = new String[2];

// 方式1
String[] arr = new String[]{"", ""};
```
多维数组：
```java
String[][] arr = new String[2][3];
```
用法：
```java
// 访问元素
arr[0]

// 循环-方式1
for (String s : arr) {
    ...
}

// 循环-方式2
for (int i = 0; i < arr.length; i++) {
    String s = arr[i];
    ...
}
// 循环-方式3
Arrays.stream(arr).forEach(s -> {});

// 循环-倒序
for (int i = arr.length - 1; i >= 0; i--) {
    String s = arr[i];
    ...
}
```
Arrays工具类中的方法：
- stream&emsp;数组转为Stream流
- copyOfRange&emsp;将指定数组的指定范围复制到新数组中
- copyOf&emsp;复制指定的数组，截断或填充空值（如有必要），使副本具有指定的长度
- binarySearch&emsp;二分搜索
- fill&emsp;将指定的值分配给数组的每个元素
- setAll&emsp;和fill类似，不过指定值为自定义Function
- sort&emsp;升序排序
- spliterator&emsp;拆分器。大多数情况下，你都不需要使用到这个方法，他主要是跟StreamSupport配合使用。参考[java8 Stream之Spliterator](https://blog.csdn.net/weixin_38308374/article/details/112972462)
- parallelPrefix&emsp;使用提供的函数并行累积给定数组的每个元素。相当于并行的reduce操作
- parallelSetAll&emsp;setAll的并行版本
- parallelSort&emsp;sort的并行版本
- toString、equals、hashCode&emsp;共用基础方法，不多说。此外这三个方法还有对应的deep系列，分别是deepToString、deepEquals、deepHashCode


这其中要重点说一下数组拷贝，其实Java中数组拷贝最终都是调用`System.arraycopy()`方法，这个方法的性能是非常高的，因为它是直接对内存进行复制。所以关于数组复制尽量调用此方法。      
需要注意的是`System.arraycopy()`属于浅复制，也就是复制对象和二维数组的时候复制的是引用，修改复制后的对象会影响到原始对象。  


数组特点：
- 访问速度快。插入和查询时间复杂度是O(1)
- 初始化之后长度不可变，不支持动态扩容


### 2、List
为了解决数组动态扩容的问题，产生了List集合。  
主要有两个实现类：
- ArrayList&emsp;数组实现。遍历和随机访问效率高
- LinkedList&emsp;链表实现。插入和删除效率高

初始化：
```java
List<Integer> list = new ArrayList<>();
list.add(2);
list.add(3);

// java9之后。of方法返回的是不可变List
List<Integer> list = List.of(2,3)
```

List继承自Collection接口，Collection继承自Iterable接口。  
Iterable中的方法：
- iterator&emsp;迭代器。有了他我们就可以使用foreach循环了
- forEach&emsp;java8之后新增方法，lambda式的forEach 
- spliterator&emsp;拆分器

Collection中的方法：
- size&emsp;获得集合中的元素数
- isEmpty&emsp;此集合是否不包含任何元素
- contains&emsp;是否包含指定元素
- toArray&emsp;转换为array数组。toArray默认返回时Object数组，但他有两个重载方法，可以返回指定类型的数组
```java
String[] arr = list.toArray(new String[]{});
String[] arr2 = list.toArray(i->new String[]{});
```
- add&emsp;添加元素
- remove&emsp;删除元素
- containsAll&emsp;是否包含指定的所有元素
- addAll&emsp;添加指定的所有元素
- removeAll&emsp;删除指定的所有元素
- removeIf&emsp;删除满足条件的元素
- retainAll&emsp;保留指定的所有元素，其他元素则删除
- clear&emsp;清空集合
- stream&emsp;获得stream流
- parallelStream&emsp;获得并行stream流

List中的方法：
- addAll(i,col)&emsp;指定位置添加元素
- replaceAll&emsp;按照指定规则替换所有元素
- sort&emsp;根据Comparator进行排序。在java8中使用lambda表达式特别方便
```java
// 对于基本类型
list.sort(String::compareTo);
//对于Comparator<String> compare = String::compareTo;你可能会比较迷惑，其实他的转换过程是这样的
BiFunction<String, String, Integer> bf = String::compareTo;
Comparator<String> compare = (Comparator<String>) bf;  // 可以看到Comparator函数接口的结果和BiFunction是相似的，java做了简化处理


// 对于Bean
list.sort(Comparator.comparing(TUser::getId))
```
- get&emsp;获得指定位置元素
- set&emsp;设置指定位置元素
- add(i,e)&emsp;添加指定位置元素。会导致原先此位置的元素后移
- remove(i)&emsp;删除指定位置元素。如果List中泛型为Integer，这里会和Collection中的remove有一个冲突，具体这么做
```java
// 调用的是Collection.remove
intList.remove(Integer.valueOf(2));

// 调用的是List.remove
intList.remove(5);
```
- indexOf&emsp;指定元素第一次出现时的索引
- lastIndexOf&emsp;指定元素最后一次出现时的索引
- listIterator&emsp;获得ListIterator，支持在迭代期间修改列表
- subList&emsp;返回指定位置范围的视图

List还有两个静态方法：
- of&emsp;java9之后支持。获得不可修改的列表
- copyOf&emsp;java11之后支持。拷贝一个不可修改的列表

### 3、Set
Set是不包含重复元素的集合。继承自Collection接口，主要实现类：
- HashSet&emsp;不保证迭代顺序和插入顺序一致。内部借助HashMap来实现
- LinkedHashSet&emsp;能保证迭代顺序和插入顺序一致。内部借助LinkedHashMap来实现
- TreeSet&emsp;元素按照自然顺序或者提供的Comparator来排序

初始化：
```java
// 方式1
Set<String> set = new HashSet<>();
set.add("a");
set.add("b");

// 方式2。返回不可变Set
Set<Integer> integers = Set.of(1, 2);
```

HashSet和LinkedHashSet没有自己独立的方法，参考Collection接口即可。  
Set接口有of和copyOf方法，功能同List。  
TreeSet继承自NavigableSet，NavigableSet继承自SortedSet。我们来看看他们其中的方法。  

SortedSet提供了对元素排序的功能，其中的方法有：
- subSet&emsp;返回此集合部分的视图，其元素范围从fromElement （包括）到toElement （不包括）
- headSet&emsp;返回此集合中元素严格小于toElement的部分的视图
- tailSet&emsp;返回此集合中元素大于或等于fromElement的部分的视图
- first&emsp;第一个元素
- last&emsp;最后一个元素

NavigableSet是对SortedSet的导航扩展，报告给定搜索目标的最接近匹配。参考[NavigableSet Api](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/NavigableSet.html)

### 4、Map
Map是键值对，每个键最多映射到一个值上。主要实现类有：
- HashMap&emsp;基于哈希表的实现，允许null键和null值。内部使用数组+链表的数据结构，为了保证性能，Java8之后链表元素数量大于阈值会变为红黑树
- LinkedHashMap&emsp;保证了迭代顺序和插入顺序一致，允许null键和null值。内部使用哈希表+双向链表实现
- TreeMap&emsp;键值按照自然顺序或者提供的Comparator来排序，不允许null键，允许null值。内部使用红黑树来实现
- HashTable&emsp;线程安全的哈希表，因为性能太差，不推荐使用。讲到并发集合的时候，用ConcurrentMap替代它

Map接口有of和copyOf方法，功能同List。此外还有两个静态方法：entry和ofEntries。  
初始化：
```java
// 方式1
Map<String, Integer> map = new HashMap<>();
map.put("a",1);
map.put("b",2);
        
// 方式2。返回不可变Map
Map<Integer, Integer> integerMap = Map.of(1, 2);

// 方式3。返回不可变Map
Map<String, Integer> stringIntegerMap = Map.ofEntries(Map.entry("a", 1), Map.entry("b", 2));
```

Map接口的方法：
- size&emsp;键值数量
- isEmpty&emsp;是否为空字典
- containsKey&emsp;是否包含指定键
- containsValue&emsp;是否包含指定值
- get&emsp;根据键获得值
- put&emsp;添加键值
- remove&emsp;删除键值
- putAll&emsp;批量添加
- clear&emsp;清空键值字典
- keySet&emsp;获得键Set
- values&emsp;获得值集合
- entrySet&emsp;获得键值对Set，泛型为Map.Entry
- getOrDefault&emsp;安全的get，没有值则返回默认值
- forEach&emsp;foreach的lambda版本
- replaceAll&emsp;替换匹配的所有元素
- putIfAbsent&emsp;字典中不存在此键，则添加；否则不做操作
- replace&emsp;替换
- computeIfAbsent&emsp;putIfAbsent的Function版本
- computeIfPresent&emsp;当指定键存在时，重新计算新值
- compute&emsp;尝试计算指定键及其当前映射值的映射
- merge&emsp;旧值替换为新值，或直接赋值

后四个方法为Java 8中新增的，有必要演示一下：
```java
// 基础数据
Map<String, Object> map = new HashMap<>();
map.put("name", "Jack");
map.put("age", 25);

// computeIfAbsent：name不会被插入成功。因为已经存在了name键
map.computeIfAbsent("name", k -> k + " random");    // 返回值为"Jack"。map：{name=Jack, age=25}
map.computeIfAbsent("score", k -> 90);  // 返回值为90。map：{name=Jack, age=25, score=90}
        
// computeIfPresent：name会被插入成功,会替换掉旧值
map.computeIfPresent("name", (k,v) -> k + " random");   // 返回值为"name random"。map：{name=name random, age=25}
// 可以按照你想要的规则进行替换
map.computeIfPresent("name", (k,v) -> v + " random");   // {name=Jack random, age=25}
map.computeIfPresent("name", (k,v) -> k + v);   // {name=name Jack, age=25}
// 替换新值为null的话键值会被删除
map.computeIfPresent("name", (k,v) -> null);    // 返回值为null。map：{age=25}
// 插入一个不存在的键值会失败
map.computeIfPresent("score", (k,v) -> 90); // 返回值为null。map：{name=Jack, age=25}

// compute：可定制的计算，computeIfPresent的增强版，可以获得现有的k，v对齐进行操作
...

// merge：合并。如果存在旧值，则使用BiFunction进行替换；否则赋予新值
map.merge("score", 80, (k, v) -> v + 5);    //map：{name=Jack, age=25, score=80}
```

HashMap和LinkedHashMap没有自己独有的方法，只是实现了Map接口。  
TreeMap还实现了NavigableMap->SortedMap，参考[NavigableMap Api](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/NavigableMap.html)

## Apache Commons Collection集合
https://commons.apache.org/proper/commons-collections/userguide.html

## Guava集合
https://github.com/google/guava/wiki

## 并发集合

## Redission分布式集合
