

要执行异步任务，流程一般是让被调者立即返回，让它在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再去尝试获得需要的数据。  
在Java中，异步任务用Future接口来表示。  

<!-- more -->

## Future
先来看一个Future用法的演示：
```
    void future() throws ExecutionException, InterruptedException {
        FutureTask<Double> futureTask = new FutureTask<>(() -> {
            Thread.sleep(3000);
            return Math.pow(10, 2);
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
    }
```
FutureTask继承自RunnableFuture，RunnableFuture继承Runnable和Future。  
Future的主要方法：
- cancel。取消
- isCanceled。是否已取消
- isDone。是否已完成
- get。获得结果，会阻塞
- get(timeout)。带超时时间的获得结果，如果超时，则抛出异常

其实线程池的submit方法也使用了FutureTask来对任务进行封装：
```java
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
```

## Future增强版之CompletableFuture
Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。  
CompletableFuture实现了CompletionStage接口，从而实现了一个超大型的工具类。  
先看一下基本的用法：
```java
        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(this::fetchPrice);
        cf.thenApply(d->d+10)
        .thenApply(d->d*2)
        .thenAccept((result) -> System.out.println("price: " + result))
        .exceptionally((e) -> {
            e.printStackTrace();
            return null;
        });
```
执行了一个异步任务，然后对他进行了加工（thenApply），对结果进行了接受（thenAccept），对异常进行了处理（exceptionally）。  

CompletableFuture中的方法众多，下面按照类别来进行介绍。  

### 创建类
- completeFuture。可以用于创建默认返回值
- runAsync。异步执行，无返回值
- supplyAsync。异步执行，有返回值
- anyOf。任意一个执行完成，就可以进行下一步动作
- allOf。全部完成所有任务，才可以进行下一步任务

代码演示：
```java
        // 直接值
        CompletableFuture<String> f1 = CompletableFuture.completedFuture("hello");
        // 无返回值
        CompletableFuture<Void> f2 = CompletableFuture.runAsync(() -> System.out.println(1));
        // 有返回值
        CompletableFuture<Integer> f3 = CompletableFuture.supplyAsync(() -> 100);
        // 并行执行，最早的一个任务完成即返回
        CompletableFuture<Object> anyOf = CompletableFuture.anyOf(f1, f2, f3);
        // 并行执行，所有的任务完成才返回
        CompletableFuture<Void> allOf = CompletableFuture.allOf(f1, f2, f3);
```

### 状态取值类
- join。等待合并结果
- get。合并等待结果，可以增加超时时间。get和join区别：join只会抛出unchecked异常，get会返回具体的异常
- getNow。如果结果计算完成或者异常了，则返回结果或异常；否则，返回给定的默认值
- isCancelled。是否已取消
- isCompletedExceptionally。是否执行异常
- isDone。是否执行完成

### 控制类
- complete。直接完成任务，让get可以直接获取到值
- completeExceptionally。直接抛出异常，结束任务执行
- cancel。取消任务

### 接续类
- thenApply, thenApplyAsync。对执行结果进行再包装
- thenAccept, thenAcceptAsync。对执行结果进行接受和利用
- thenRun, thenRunAsync。对执行结果下一步的执行
- thenCombine, thenCombineAsync。把任务和另一个任务进行组合，有入参，有返回值
- thenAcceptBoth, thenAcceptBothAsync。把任务和另一个任务进行组合，有入参，无返回值
- runAfterBoth, runAfterBothAsync。把任务和另一个任务进行组合，无入参，无返回值
- applyToEither, applyToEitherAsync。
- acceptEither, acceptEitherAsync。
- runAfterEither, runAfterEitherAsync。
- thenCompose, thenComposeAsync。
- whenComplete, whenCompleteAsync。
- handle, handleAsync。
- exceptionally。

代码演示：
```java
        CompletableFuture<String> rice = CompletableFuture.supplyAsync(()->{
            System.out.println("开始制作米饭，并获得煮熟的米饭");
            return "煮熟的米饭";
        });
        //煮米饭的同时呢，我又做了牛奶
        CompletableFuture mike = CompletableFuture.supplyAsync(()->{
            System.out.println("开始热牛奶，并获得加热的牛奶");
            return "加热的牛奶";
        });
        // 我想两个都好了，才吃早饭，thenCombineAsync有入参，有返回值
        mike.thenCombineAsync(rice,(m,r)->{
            System.out.println("我收获了早饭："+m+","+r);
            return String.valueOf(m) + r;
        });
        // 有入参，无返回值
        mike.thenAcceptBothAsync(rice,(m,r)->{
            System.out.println("我收获了早饭："+m+","+r);
        });
        // 无入参，无返回值
        mike.runAfterBothAsync(rice,()->{
            System.out.println("我收获了早饭");
        });
```

## CompletionService
