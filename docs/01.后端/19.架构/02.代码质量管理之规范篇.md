
## 为何要进行代码质量管理
从实践经验上来看，代码质量管理主要要达到以下目的：
- 可维护性：高质量的代码更易于维护和扩展。通过进行代码质量管理，你可以确保代码结构良好、易于理解，从而降低维护成本和项目风险。
- 可读性：高质量的代码具有良好的可读性，这有助于开发团队更快地理解和修改代码。代码质量管理有助于确保代码的一致性和可读性，提高团队协作效率。
- 可靠性和稳定性：通过进行代码质量管理，可以降低软件缺陷的数量，从而提高软件的可靠性和稳定性。这对于用户体验和满意度至关重要。
- 性能：代码质量管理有助于发现潜在的性能问题，从而提高软件的性能。良好的性能对于用户体验和应用程序的成功至关重要。
- 安全性：代码质量管理可以帮助你发现和修复潜在的安全漏洞，从而提高软件的安全性。安全性对于保护用户数据和防止恶意攻击至关重要。
- 开发效率：通过进行代码质量管理，你可以提高开发团队的效率，减少因低质量代码而导致的浪费时间和精力。
- 持续改进：代码质量管理有助于发现问题和改进点，从而促使开发团队不断改进软件质量。这有助于提高产品竞争力和满足客户需求。
- 团队协作和知识共享：代码质量管理有助于建立团队协作和知识共享的文化，通过代码审查和团队讨论来共同解决问题和提高代码质量。

那么反过来推算，不进行代码质量管理，就难免陷入维护性差、可读性差、可靠性差、性能差、安全性差、效率低下、团队合作困难等的泥沼。  

如果进行了良好的代码质量管理，那么就能有效的避免代码中坏味道的发酵，可以让团队成员更加的peace，可以让世界更加的美好。

代码质量管理话题比较大，这篇文章先来谈谈代码规范，无规矩不成方圆，有规矩则世界大同。

## 应用架构规范
宏观的系统架构主要解决复杂性问题，那是一个庞大的话题。   
这里主要谈一下应用架构。每个公司的应用架构可能有所不同，常见的有传统三层、整洁架构、领域驱动设计等。

而不管什么样的架构设计，核心原则是基本一致的：也就是以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。  

我以典型的ERP系统业务架构来举例，分层结构如下：

![image](https://cdn.staticaly.com/gh/xuanyuanli/Img@master/picx/image.5rb3g3lxhro0.jpg)

- Adapter、Web、OpenApi 包含了中断适配层、Web展示层、开发接口层
- Service 业务逻辑服务层
- Domain 领域层，借鉴了领域驱动设计的概念名称，但是目前没有完全遵从领域驱动设计的思想。Domain层的作用：沉淀复杂逻辑和公共方法
- Dao 持久层，与数据库交互


### 层级规范
- 不能跨层调用
- 下一层不能调用上一层
- 对于Adapter和Web来说，一个页面对应一个Controller。【弹性：大部分情况下是如此，如果一个页面包含强关联的子页面，则考虑放在一个Controller中即可】
- 一个Controller对应一个Service，不能出现一个Controller聚合多个Service的情况，最好不出现一个Service被多个Controller引用的情况
- 关于Domain层，主要用来沉淀复杂逻辑和公共方法
- Service层可以聚合Domain和Dao
- persistence层中的Dao方法尽量为原子性操作。有一些简单逻辑的方法，建议也写在持久层，便于复用
- 凡是涉及到事务，必须写在Service或Domain层，并且加上@Transactional(rollbackFor = Exception.class)注解


### 数据模型规范
- Entiry 数据实体类，和数据库表一一对应，普通Bean，不用固定后缀
- PO 持久化对象，数据库查询结果对应的对象
- Query（Qry） 读取命令
- Command（Cmd） 写入命令
- BO 业务对象，Service层输出的对象
- DO 领域对象，Domain层输出的对象
- DTO 数据传输对象，Adapter层输出的对象

### package与类设计规范
- Service接口都以Api结尾，放在api包下
- Service实现类都以Service结尾，放在service包下
- Controller都以Controller结尾，放在controller包下
- Controller以一组页面为一个package，有自己独立的包名。对于ERP来说，一级菜单对应一个package，比如用户管理就在controller.usermanager下；对于Adapter来说，一组页面对应一个package，比如游客数据就在controller.tourist下，会员中心就在controller.buyermember下
- Service的包名结构：同一个业务体系下的Service有一个独立的package，比如erpweb、appadapter、pcweb；在系统级别以下，package对应controller的包名来建立。比如api.erpweb.usermanager和service.erpweb.usermanager
- 前后端分离项目中的Controller的返回值是DTO；前后端不分离的项目中使用MVC模式，Controller和View可以直接使用BO
- 一个Qry对应一个Service中的方法；一个Cmd对应一个逻辑处理类（CmdExe）。【弹性：复杂情况下用到CmdExe，这样利于解构和可读性。一般情况下，Cmd的实现可以放在Service中】
- Api的入参必须是Qry或Cmd。【弹性：只有一个参数或逻辑简单的情况下，可以直接用原始类型入参，但也不允许超过3个参数】
- Api的每个方法有独立的Cmd（Qry)和BO返回值，不允许复用Cmd（Qry）和BO。【弹性：如果有复用的数据模型，必须严格控制，写好注释】
- 所有Controller、Service、Domain、Dao对应的数据模型都应该放到所属接口中（作为内部类），不要单独放到package中。【弹性：一些共用的数据模型允许放到common package中，但要严格控制，写好注释】

备注：严格控制的意思是必须经过架构师的同意，否则代码提交会被驳回

## Java 代码规范
- package名必须全小写；类名以大写开头的驼峰命名；方法名、参数名、变量名以小写驼峰命名；常量、枚举以全大写+下划线方式命名
- Long类型必须以大写L结尾；Double类型必须以大写D结尾；Float类型必须以大写F结尾
- 不允许在程序任何地方中使用： 1）java.sql.Date 2）java.sql.Time 3）java.sql.Timestamp
- 代码格式统一使用Google Java Formater规范，IDEA上安装google-java-formater插件；每行最大为160，需要在IDEA中进行设置
- IDEA中安装Alibaba Java Coding Guidelines插件。【弹性：可以选择关闭某些检查，但要严格控制】
- IDEA中检查不允许关闭。【弹性：可以选择关闭某些检查，但要严格控制】
- 项目中有core基础包，所有的工具类都在其中沉淀，不允许自定义工具类，统一在core中进行管理。如果要使用新工具类，请找架构师

备注：
- 严格控制部分，反馈到架构师后，架构师假如公示列表中，并对每项予以说明
- core基础包要进行版本管理和发行说明
- core基础包最好要分包，比如core-poi、core-image、core-pdf等

## Mysql 规范

## Redis 规范

## RESTful（前后端交互） 规范


## Swagger 规范

## 测试规范

